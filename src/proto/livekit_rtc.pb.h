// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: livekit_rtc.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_livekit_5frtc_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_livekit_5frtc_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "livekit_models.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_livekit_5frtc_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_livekit_5frtc_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[29]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_livekit_5frtc_2eproto;
namespace livekit {
class AddTrackRequest;
struct AddTrackRequestDefaultTypeInternal;
extern AddTrackRequestDefaultTypeInternal _AddTrackRequest_default_instance_;
class ConnectionQualityInfo;
struct ConnectionQualityInfoDefaultTypeInternal;
extern ConnectionQualityInfoDefaultTypeInternal _ConnectionQualityInfo_default_instance_;
class ConnectionQualityUpdate;
struct ConnectionQualityUpdateDefaultTypeInternal;
extern ConnectionQualityUpdateDefaultTypeInternal _ConnectionQualityUpdate_default_instance_;
class DataChannelInfo;
struct DataChannelInfoDefaultTypeInternal;
extern DataChannelInfoDefaultTypeInternal _DataChannelInfo_default_instance_;
class ICEServer;
struct ICEServerDefaultTypeInternal;
extern ICEServerDefaultTypeInternal _ICEServer_default_instance_;
class JoinResponse;
struct JoinResponseDefaultTypeInternal;
extern JoinResponseDefaultTypeInternal _JoinResponse_default_instance_;
class LeaveRequest;
struct LeaveRequestDefaultTypeInternal;
extern LeaveRequestDefaultTypeInternal _LeaveRequest_default_instance_;
class MuteTrackRequest;
struct MuteTrackRequestDefaultTypeInternal;
extern MuteTrackRequestDefaultTypeInternal _MuteTrackRequest_default_instance_;
class ParticipantUpdate;
struct ParticipantUpdateDefaultTypeInternal;
extern ParticipantUpdateDefaultTypeInternal _ParticipantUpdate_default_instance_;
class RoomUpdate;
struct RoomUpdateDefaultTypeInternal;
extern RoomUpdateDefaultTypeInternal _RoomUpdate_default_instance_;
class SessionDescription;
struct SessionDescriptionDefaultTypeInternal;
extern SessionDescriptionDefaultTypeInternal _SessionDescription_default_instance_;
class SignalRequest;
struct SignalRequestDefaultTypeInternal;
extern SignalRequestDefaultTypeInternal _SignalRequest_default_instance_;
class SignalResponse;
struct SignalResponseDefaultTypeInternal;
extern SignalResponseDefaultTypeInternal _SignalResponse_default_instance_;
class SimulateScenario;
struct SimulateScenarioDefaultTypeInternal;
extern SimulateScenarioDefaultTypeInternal _SimulateScenario_default_instance_;
class SpeakersChanged;
struct SpeakersChangedDefaultTypeInternal;
extern SpeakersChangedDefaultTypeInternal _SpeakersChanged_default_instance_;
class StreamStateInfo;
struct StreamStateInfoDefaultTypeInternal;
extern StreamStateInfoDefaultTypeInternal _StreamStateInfo_default_instance_;
class StreamStateUpdate;
struct StreamStateUpdateDefaultTypeInternal;
extern StreamStateUpdateDefaultTypeInternal _StreamStateUpdate_default_instance_;
class SubscribedQuality;
struct SubscribedQualityDefaultTypeInternal;
extern SubscribedQualityDefaultTypeInternal _SubscribedQuality_default_instance_;
class SubscribedQualityUpdate;
struct SubscribedQualityUpdateDefaultTypeInternal;
extern SubscribedQualityUpdateDefaultTypeInternal _SubscribedQualityUpdate_default_instance_;
class SubscriptionPermission;
struct SubscriptionPermissionDefaultTypeInternal;
extern SubscriptionPermissionDefaultTypeInternal _SubscriptionPermission_default_instance_;
class SubscriptionPermissionUpdate;
struct SubscriptionPermissionUpdateDefaultTypeInternal;
extern SubscriptionPermissionUpdateDefaultTypeInternal _SubscriptionPermissionUpdate_default_instance_;
class SyncState;
struct SyncStateDefaultTypeInternal;
extern SyncStateDefaultTypeInternal _SyncState_default_instance_;
class TrackPermission;
struct TrackPermissionDefaultTypeInternal;
extern TrackPermissionDefaultTypeInternal _TrackPermission_default_instance_;
class TrackPublishedResponse;
struct TrackPublishedResponseDefaultTypeInternal;
extern TrackPublishedResponseDefaultTypeInternal _TrackPublishedResponse_default_instance_;
class TrackUnpublishedResponse;
struct TrackUnpublishedResponseDefaultTypeInternal;
extern TrackUnpublishedResponseDefaultTypeInternal _TrackUnpublishedResponse_default_instance_;
class TrickleRequest;
struct TrickleRequestDefaultTypeInternal;
extern TrickleRequestDefaultTypeInternal _TrickleRequest_default_instance_;
class UpdateSubscription;
struct UpdateSubscriptionDefaultTypeInternal;
extern UpdateSubscriptionDefaultTypeInternal _UpdateSubscription_default_instance_;
class UpdateTrackSettings;
struct UpdateTrackSettingsDefaultTypeInternal;
extern UpdateTrackSettingsDefaultTypeInternal _UpdateTrackSettings_default_instance_;
class UpdateVideoLayers;
struct UpdateVideoLayersDefaultTypeInternal;
extern UpdateVideoLayersDefaultTypeInternal _UpdateVideoLayers_default_instance_;
}  // namespace livekit
PROTOBUF_NAMESPACE_OPEN
template<> ::livekit::AddTrackRequest* Arena::CreateMaybeMessage<::livekit::AddTrackRequest>(Arena*);
template<> ::livekit::ConnectionQualityInfo* Arena::CreateMaybeMessage<::livekit::ConnectionQualityInfo>(Arena*);
template<> ::livekit::ConnectionQualityUpdate* Arena::CreateMaybeMessage<::livekit::ConnectionQualityUpdate>(Arena*);
template<> ::livekit::DataChannelInfo* Arena::CreateMaybeMessage<::livekit::DataChannelInfo>(Arena*);
template<> ::livekit::ICEServer* Arena::CreateMaybeMessage<::livekit::ICEServer>(Arena*);
template<> ::livekit::JoinResponse* Arena::CreateMaybeMessage<::livekit::JoinResponse>(Arena*);
template<> ::livekit::LeaveRequest* Arena::CreateMaybeMessage<::livekit::LeaveRequest>(Arena*);
template<> ::livekit::MuteTrackRequest* Arena::CreateMaybeMessage<::livekit::MuteTrackRequest>(Arena*);
template<> ::livekit::ParticipantUpdate* Arena::CreateMaybeMessage<::livekit::ParticipantUpdate>(Arena*);
template<> ::livekit::RoomUpdate* Arena::CreateMaybeMessage<::livekit::RoomUpdate>(Arena*);
template<> ::livekit::SessionDescription* Arena::CreateMaybeMessage<::livekit::SessionDescription>(Arena*);
template<> ::livekit::SignalRequest* Arena::CreateMaybeMessage<::livekit::SignalRequest>(Arena*);
template<> ::livekit::SignalResponse* Arena::CreateMaybeMessage<::livekit::SignalResponse>(Arena*);
template<> ::livekit::SimulateScenario* Arena::CreateMaybeMessage<::livekit::SimulateScenario>(Arena*);
template<> ::livekit::SpeakersChanged* Arena::CreateMaybeMessage<::livekit::SpeakersChanged>(Arena*);
template<> ::livekit::StreamStateInfo* Arena::CreateMaybeMessage<::livekit::StreamStateInfo>(Arena*);
template<> ::livekit::StreamStateUpdate* Arena::CreateMaybeMessage<::livekit::StreamStateUpdate>(Arena*);
template<> ::livekit::SubscribedQuality* Arena::CreateMaybeMessage<::livekit::SubscribedQuality>(Arena*);
template<> ::livekit::SubscribedQualityUpdate* Arena::CreateMaybeMessage<::livekit::SubscribedQualityUpdate>(Arena*);
template<> ::livekit::SubscriptionPermission* Arena::CreateMaybeMessage<::livekit::SubscriptionPermission>(Arena*);
template<> ::livekit::SubscriptionPermissionUpdate* Arena::CreateMaybeMessage<::livekit::SubscriptionPermissionUpdate>(Arena*);
template<> ::livekit::SyncState* Arena::CreateMaybeMessage<::livekit::SyncState>(Arena*);
template<> ::livekit::TrackPermission* Arena::CreateMaybeMessage<::livekit::TrackPermission>(Arena*);
template<> ::livekit::TrackPublishedResponse* Arena::CreateMaybeMessage<::livekit::TrackPublishedResponse>(Arena*);
template<> ::livekit::TrackUnpublishedResponse* Arena::CreateMaybeMessage<::livekit::TrackUnpublishedResponse>(Arena*);
template<> ::livekit::TrickleRequest* Arena::CreateMaybeMessage<::livekit::TrickleRequest>(Arena*);
template<> ::livekit::UpdateSubscription* Arena::CreateMaybeMessage<::livekit::UpdateSubscription>(Arena*);
template<> ::livekit::UpdateTrackSettings* Arena::CreateMaybeMessage<::livekit::UpdateTrackSettings>(Arena*);
template<> ::livekit::UpdateVideoLayers* Arena::CreateMaybeMessage<::livekit::UpdateVideoLayers>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace livekit {

enum SignalTarget : int {
  PUBLISHER = 0,
  SUBSCRIBER = 1,
  SignalTarget_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SignalTarget_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SignalTarget_IsValid(int value);
constexpr SignalTarget SignalTarget_MIN = PUBLISHER;
constexpr SignalTarget SignalTarget_MAX = SUBSCRIBER;
constexpr int SignalTarget_ARRAYSIZE = SignalTarget_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SignalTarget_descriptor();
template<typename T>
inline const std::string& SignalTarget_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SignalTarget>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SignalTarget_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SignalTarget_descriptor(), enum_t_value);
}
inline bool SignalTarget_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SignalTarget* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SignalTarget>(
    SignalTarget_descriptor(), name, value);
}
enum StreamState : int {
  ACTIVE = 0,
  PAUSED = 1,
  StreamState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  StreamState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool StreamState_IsValid(int value);
constexpr StreamState StreamState_MIN = ACTIVE;
constexpr StreamState StreamState_MAX = PAUSED;
constexpr int StreamState_ARRAYSIZE = StreamState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StreamState_descriptor();
template<typename T>
inline const std::string& StreamState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StreamState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StreamState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StreamState_descriptor(), enum_t_value);
}
inline bool StreamState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StreamState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StreamState>(
    StreamState_descriptor(), name, value);
}
// ===================================================================

class SignalRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.SignalRequest) */ {
 public:
  inline SignalRequest() : SignalRequest(nullptr) {}
  ~SignalRequest() override;
  explicit constexpr SignalRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignalRequest(const SignalRequest& from);
  SignalRequest(SignalRequest&& from) noexcept
    : SignalRequest() {
    *this = ::std::move(from);
  }

  inline SignalRequest& operator=(const SignalRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignalRequest& operator=(SignalRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignalRequest& default_instance() {
    return *internal_default_instance();
  }
  enum MessageCase {
    kOffer = 1,
    kAnswer = 2,
    kTrickle = 3,
    kAddTrack = 4,
    kMute = 5,
    kSubscription = 6,
    kTrackSetting = 7,
    kLeave = 8,
    kUpdateLayers = 10,
    kSubscriptionPermission = 11,
    kSyncState = 12,
    kSimulate = 13,
    MESSAGE_NOT_SET = 0,
  };

  static inline const SignalRequest* internal_default_instance() {
    return reinterpret_cast<const SignalRequest*>(
               &_SignalRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SignalRequest& a, SignalRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SignalRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignalRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignalRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignalRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignalRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SignalRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignalRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.SignalRequest";
  }
  protected:
  explicit SignalRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOfferFieldNumber = 1,
    kAnswerFieldNumber = 2,
    kTrickleFieldNumber = 3,
    kAddTrackFieldNumber = 4,
    kMuteFieldNumber = 5,
    kSubscriptionFieldNumber = 6,
    kTrackSettingFieldNumber = 7,
    kLeaveFieldNumber = 8,
    kUpdateLayersFieldNumber = 10,
    kSubscriptionPermissionFieldNumber = 11,
    kSyncStateFieldNumber = 12,
    kSimulateFieldNumber = 13,
  };
  // .livekit.SessionDescription offer = 1;
  bool has_offer() const;
  private:
  bool _internal_has_offer() const;
  public:
  void clear_offer();
  const ::livekit::SessionDescription& offer() const;
  PROTOBUF_NODISCARD ::livekit::SessionDescription* release_offer();
  ::livekit::SessionDescription* mutable_offer();
  void set_allocated_offer(::livekit::SessionDescription* offer);
  private:
  const ::livekit::SessionDescription& _internal_offer() const;
  ::livekit::SessionDescription* _internal_mutable_offer();
  public:
  void unsafe_arena_set_allocated_offer(
      ::livekit::SessionDescription* offer);
  ::livekit::SessionDescription* unsafe_arena_release_offer();

  // .livekit.SessionDescription answer = 2;
  bool has_answer() const;
  private:
  bool _internal_has_answer() const;
  public:
  void clear_answer();
  const ::livekit::SessionDescription& answer() const;
  PROTOBUF_NODISCARD ::livekit::SessionDescription* release_answer();
  ::livekit::SessionDescription* mutable_answer();
  void set_allocated_answer(::livekit::SessionDescription* answer);
  private:
  const ::livekit::SessionDescription& _internal_answer() const;
  ::livekit::SessionDescription* _internal_mutable_answer();
  public:
  void unsafe_arena_set_allocated_answer(
      ::livekit::SessionDescription* answer);
  ::livekit::SessionDescription* unsafe_arena_release_answer();

  // .livekit.TrickleRequest trickle = 3;
  bool has_trickle() const;
  private:
  bool _internal_has_trickle() const;
  public:
  void clear_trickle();
  const ::livekit::TrickleRequest& trickle() const;
  PROTOBUF_NODISCARD ::livekit::TrickleRequest* release_trickle();
  ::livekit::TrickleRequest* mutable_trickle();
  void set_allocated_trickle(::livekit::TrickleRequest* trickle);
  private:
  const ::livekit::TrickleRequest& _internal_trickle() const;
  ::livekit::TrickleRequest* _internal_mutable_trickle();
  public:
  void unsafe_arena_set_allocated_trickle(
      ::livekit::TrickleRequest* trickle);
  ::livekit::TrickleRequest* unsafe_arena_release_trickle();

  // .livekit.AddTrackRequest add_track = 4;
  bool has_add_track() const;
  private:
  bool _internal_has_add_track() const;
  public:
  void clear_add_track();
  const ::livekit::AddTrackRequest& add_track() const;
  PROTOBUF_NODISCARD ::livekit::AddTrackRequest* release_add_track();
  ::livekit::AddTrackRequest* mutable_add_track();
  void set_allocated_add_track(::livekit::AddTrackRequest* add_track);
  private:
  const ::livekit::AddTrackRequest& _internal_add_track() const;
  ::livekit::AddTrackRequest* _internal_mutable_add_track();
  public:
  void unsafe_arena_set_allocated_add_track(
      ::livekit::AddTrackRequest* add_track);
  ::livekit::AddTrackRequest* unsafe_arena_release_add_track();

  // .livekit.MuteTrackRequest mute = 5;
  bool has_mute() const;
  private:
  bool _internal_has_mute() const;
  public:
  void clear_mute();
  const ::livekit::MuteTrackRequest& mute() const;
  PROTOBUF_NODISCARD ::livekit::MuteTrackRequest* release_mute();
  ::livekit::MuteTrackRequest* mutable_mute();
  void set_allocated_mute(::livekit::MuteTrackRequest* mute);
  private:
  const ::livekit::MuteTrackRequest& _internal_mute() const;
  ::livekit::MuteTrackRequest* _internal_mutable_mute();
  public:
  void unsafe_arena_set_allocated_mute(
      ::livekit::MuteTrackRequest* mute);
  ::livekit::MuteTrackRequest* unsafe_arena_release_mute();

  // .livekit.UpdateSubscription subscription = 6;
  bool has_subscription() const;
  private:
  bool _internal_has_subscription() const;
  public:
  void clear_subscription();
  const ::livekit::UpdateSubscription& subscription() const;
  PROTOBUF_NODISCARD ::livekit::UpdateSubscription* release_subscription();
  ::livekit::UpdateSubscription* mutable_subscription();
  void set_allocated_subscription(::livekit::UpdateSubscription* subscription);
  private:
  const ::livekit::UpdateSubscription& _internal_subscription() const;
  ::livekit::UpdateSubscription* _internal_mutable_subscription();
  public:
  void unsafe_arena_set_allocated_subscription(
      ::livekit::UpdateSubscription* subscription);
  ::livekit::UpdateSubscription* unsafe_arena_release_subscription();

  // .livekit.UpdateTrackSettings track_setting = 7;
  bool has_track_setting() const;
  private:
  bool _internal_has_track_setting() const;
  public:
  void clear_track_setting();
  const ::livekit::UpdateTrackSettings& track_setting() const;
  PROTOBUF_NODISCARD ::livekit::UpdateTrackSettings* release_track_setting();
  ::livekit::UpdateTrackSettings* mutable_track_setting();
  void set_allocated_track_setting(::livekit::UpdateTrackSettings* track_setting);
  private:
  const ::livekit::UpdateTrackSettings& _internal_track_setting() const;
  ::livekit::UpdateTrackSettings* _internal_mutable_track_setting();
  public:
  void unsafe_arena_set_allocated_track_setting(
      ::livekit::UpdateTrackSettings* track_setting);
  ::livekit::UpdateTrackSettings* unsafe_arena_release_track_setting();

  // .livekit.LeaveRequest leave = 8;
  bool has_leave() const;
  private:
  bool _internal_has_leave() const;
  public:
  void clear_leave();
  const ::livekit::LeaveRequest& leave() const;
  PROTOBUF_NODISCARD ::livekit::LeaveRequest* release_leave();
  ::livekit::LeaveRequest* mutable_leave();
  void set_allocated_leave(::livekit::LeaveRequest* leave);
  private:
  const ::livekit::LeaveRequest& _internal_leave() const;
  ::livekit::LeaveRequest* _internal_mutable_leave();
  public:
  void unsafe_arena_set_allocated_leave(
      ::livekit::LeaveRequest* leave);
  ::livekit::LeaveRequest* unsafe_arena_release_leave();

  // .livekit.UpdateVideoLayers update_layers = 10;
  bool has_update_layers() const;
  private:
  bool _internal_has_update_layers() const;
  public:
  void clear_update_layers();
  const ::livekit::UpdateVideoLayers& update_layers() const;
  PROTOBUF_NODISCARD ::livekit::UpdateVideoLayers* release_update_layers();
  ::livekit::UpdateVideoLayers* mutable_update_layers();
  void set_allocated_update_layers(::livekit::UpdateVideoLayers* update_layers);
  private:
  const ::livekit::UpdateVideoLayers& _internal_update_layers() const;
  ::livekit::UpdateVideoLayers* _internal_mutable_update_layers();
  public:
  void unsafe_arena_set_allocated_update_layers(
      ::livekit::UpdateVideoLayers* update_layers);
  ::livekit::UpdateVideoLayers* unsafe_arena_release_update_layers();

  // .livekit.SubscriptionPermission subscription_permission = 11;
  bool has_subscription_permission() const;
  private:
  bool _internal_has_subscription_permission() const;
  public:
  void clear_subscription_permission();
  const ::livekit::SubscriptionPermission& subscription_permission() const;
  PROTOBUF_NODISCARD ::livekit::SubscriptionPermission* release_subscription_permission();
  ::livekit::SubscriptionPermission* mutable_subscription_permission();
  void set_allocated_subscription_permission(::livekit::SubscriptionPermission* subscription_permission);
  private:
  const ::livekit::SubscriptionPermission& _internal_subscription_permission() const;
  ::livekit::SubscriptionPermission* _internal_mutable_subscription_permission();
  public:
  void unsafe_arena_set_allocated_subscription_permission(
      ::livekit::SubscriptionPermission* subscription_permission);
  ::livekit::SubscriptionPermission* unsafe_arena_release_subscription_permission();

  // .livekit.SyncState sync_state = 12;
  bool has_sync_state() const;
  private:
  bool _internal_has_sync_state() const;
  public:
  void clear_sync_state();
  const ::livekit::SyncState& sync_state() const;
  PROTOBUF_NODISCARD ::livekit::SyncState* release_sync_state();
  ::livekit::SyncState* mutable_sync_state();
  void set_allocated_sync_state(::livekit::SyncState* sync_state);
  private:
  const ::livekit::SyncState& _internal_sync_state() const;
  ::livekit::SyncState* _internal_mutable_sync_state();
  public:
  void unsafe_arena_set_allocated_sync_state(
      ::livekit::SyncState* sync_state);
  ::livekit::SyncState* unsafe_arena_release_sync_state();

  // .livekit.SimulateScenario simulate = 13;
  bool has_simulate() const;
  private:
  bool _internal_has_simulate() const;
  public:
  void clear_simulate();
  const ::livekit::SimulateScenario& simulate() const;
  PROTOBUF_NODISCARD ::livekit::SimulateScenario* release_simulate();
  ::livekit::SimulateScenario* mutable_simulate();
  void set_allocated_simulate(::livekit::SimulateScenario* simulate);
  private:
  const ::livekit::SimulateScenario& _internal_simulate() const;
  ::livekit::SimulateScenario* _internal_mutable_simulate();
  public:
  void unsafe_arena_set_allocated_simulate(
      ::livekit::SimulateScenario* simulate);
  ::livekit::SimulateScenario* unsafe_arena_release_simulate();

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:livekit.SignalRequest)
 private:
  class _Internal;
  void set_has_offer();
  void set_has_answer();
  void set_has_trickle();
  void set_has_add_track();
  void set_has_mute();
  void set_has_subscription();
  void set_has_track_setting();
  void set_has_leave();
  void set_has_update_layers();
  void set_has_subscription_permission();
  void set_has_sync_state();
  void set_has_simulate();

  inline bool has_message() const;
  inline void clear_has_message();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union MessageUnion {
    constexpr MessageUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::livekit::SessionDescription* offer_;
    ::livekit::SessionDescription* answer_;
    ::livekit::TrickleRequest* trickle_;
    ::livekit::AddTrackRequest* add_track_;
    ::livekit::MuteTrackRequest* mute_;
    ::livekit::UpdateSubscription* subscription_;
    ::livekit::UpdateTrackSettings* track_setting_;
    ::livekit::LeaveRequest* leave_;
    ::livekit::UpdateVideoLayers* update_layers_;
    ::livekit::SubscriptionPermission* subscription_permission_;
    ::livekit::SyncState* sync_state_;
    ::livekit::SimulateScenario* simulate_;
  } message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class SignalResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.SignalResponse) */ {
 public:
  inline SignalResponse() : SignalResponse(nullptr) {}
  ~SignalResponse() override;
  explicit constexpr SignalResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignalResponse(const SignalResponse& from);
  SignalResponse(SignalResponse&& from) noexcept
    : SignalResponse() {
    *this = ::std::move(from);
  }

  inline SignalResponse& operator=(const SignalResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignalResponse& operator=(SignalResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignalResponse& default_instance() {
    return *internal_default_instance();
  }
  enum MessageCase {
    kJoin = 1,
    kAnswer = 2,
    kOffer = 3,
    kTrickle = 4,
    kUpdate = 5,
    kTrackPublished = 6,
    kLeave = 8,
    kMute = 9,
    kSpeakersChanged = 10,
    kRoomUpdate = 11,
    kConnectionQuality = 12,
    kStreamStateUpdate = 13,
    kSubscribedQualityUpdate = 14,
    kSubscriptionPermissionUpdate = 15,
    kRefreshToken = 16,
    kTrackUnpublished = 17,
    MESSAGE_NOT_SET = 0,
  };

  static inline const SignalResponse* internal_default_instance() {
    return reinterpret_cast<const SignalResponse*>(
               &_SignalResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SignalResponse& a, SignalResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SignalResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignalResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignalResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignalResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignalResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SignalResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignalResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.SignalResponse";
  }
  protected:
  explicit SignalResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJoinFieldNumber = 1,
    kAnswerFieldNumber = 2,
    kOfferFieldNumber = 3,
    kTrickleFieldNumber = 4,
    kUpdateFieldNumber = 5,
    kTrackPublishedFieldNumber = 6,
    kLeaveFieldNumber = 8,
    kMuteFieldNumber = 9,
    kSpeakersChangedFieldNumber = 10,
    kRoomUpdateFieldNumber = 11,
    kConnectionQualityFieldNumber = 12,
    kStreamStateUpdateFieldNumber = 13,
    kSubscribedQualityUpdateFieldNumber = 14,
    kSubscriptionPermissionUpdateFieldNumber = 15,
    kRefreshTokenFieldNumber = 16,
    kTrackUnpublishedFieldNumber = 17,
  };
  // .livekit.JoinResponse join = 1;
  bool has_join() const;
  private:
  bool _internal_has_join() const;
  public:
  void clear_join();
  const ::livekit::JoinResponse& join() const;
  PROTOBUF_NODISCARD ::livekit::JoinResponse* release_join();
  ::livekit::JoinResponse* mutable_join();
  void set_allocated_join(::livekit::JoinResponse* join);
  private:
  const ::livekit::JoinResponse& _internal_join() const;
  ::livekit::JoinResponse* _internal_mutable_join();
  public:
  void unsafe_arena_set_allocated_join(
      ::livekit::JoinResponse* join);
  ::livekit::JoinResponse* unsafe_arena_release_join();

  // .livekit.SessionDescription answer = 2;
  bool has_answer() const;
  private:
  bool _internal_has_answer() const;
  public:
  void clear_answer();
  const ::livekit::SessionDescription& answer() const;
  PROTOBUF_NODISCARD ::livekit::SessionDescription* release_answer();
  ::livekit::SessionDescription* mutable_answer();
  void set_allocated_answer(::livekit::SessionDescription* answer);
  private:
  const ::livekit::SessionDescription& _internal_answer() const;
  ::livekit::SessionDescription* _internal_mutable_answer();
  public:
  void unsafe_arena_set_allocated_answer(
      ::livekit::SessionDescription* answer);
  ::livekit::SessionDescription* unsafe_arena_release_answer();

  // .livekit.SessionDescription offer = 3;
  bool has_offer() const;
  private:
  bool _internal_has_offer() const;
  public:
  void clear_offer();
  const ::livekit::SessionDescription& offer() const;
  PROTOBUF_NODISCARD ::livekit::SessionDescription* release_offer();
  ::livekit::SessionDescription* mutable_offer();
  void set_allocated_offer(::livekit::SessionDescription* offer);
  private:
  const ::livekit::SessionDescription& _internal_offer() const;
  ::livekit::SessionDescription* _internal_mutable_offer();
  public:
  void unsafe_arena_set_allocated_offer(
      ::livekit::SessionDescription* offer);
  ::livekit::SessionDescription* unsafe_arena_release_offer();

  // .livekit.TrickleRequest trickle = 4;
  bool has_trickle() const;
  private:
  bool _internal_has_trickle() const;
  public:
  void clear_trickle();
  const ::livekit::TrickleRequest& trickle() const;
  PROTOBUF_NODISCARD ::livekit::TrickleRequest* release_trickle();
  ::livekit::TrickleRequest* mutable_trickle();
  void set_allocated_trickle(::livekit::TrickleRequest* trickle);
  private:
  const ::livekit::TrickleRequest& _internal_trickle() const;
  ::livekit::TrickleRequest* _internal_mutable_trickle();
  public:
  void unsafe_arena_set_allocated_trickle(
      ::livekit::TrickleRequest* trickle);
  ::livekit::TrickleRequest* unsafe_arena_release_trickle();

  // .livekit.ParticipantUpdate update = 5;
  bool has_update() const;
  private:
  bool _internal_has_update() const;
  public:
  void clear_update();
  const ::livekit::ParticipantUpdate& update() const;
  PROTOBUF_NODISCARD ::livekit::ParticipantUpdate* release_update();
  ::livekit::ParticipantUpdate* mutable_update();
  void set_allocated_update(::livekit::ParticipantUpdate* update);
  private:
  const ::livekit::ParticipantUpdate& _internal_update() const;
  ::livekit::ParticipantUpdate* _internal_mutable_update();
  public:
  void unsafe_arena_set_allocated_update(
      ::livekit::ParticipantUpdate* update);
  ::livekit::ParticipantUpdate* unsafe_arena_release_update();

  // .livekit.TrackPublishedResponse track_published = 6;
  bool has_track_published() const;
  private:
  bool _internal_has_track_published() const;
  public:
  void clear_track_published();
  const ::livekit::TrackPublishedResponse& track_published() const;
  PROTOBUF_NODISCARD ::livekit::TrackPublishedResponse* release_track_published();
  ::livekit::TrackPublishedResponse* mutable_track_published();
  void set_allocated_track_published(::livekit::TrackPublishedResponse* track_published);
  private:
  const ::livekit::TrackPublishedResponse& _internal_track_published() const;
  ::livekit::TrackPublishedResponse* _internal_mutable_track_published();
  public:
  void unsafe_arena_set_allocated_track_published(
      ::livekit::TrackPublishedResponse* track_published);
  ::livekit::TrackPublishedResponse* unsafe_arena_release_track_published();

  // .livekit.LeaveRequest leave = 8;
  bool has_leave() const;
  private:
  bool _internal_has_leave() const;
  public:
  void clear_leave();
  const ::livekit::LeaveRequest& leave() const;
  PROTOBUF_NODISCARD ::livekit::LeaveRequest* release_leave();
  ::livekit::LeaveRequest* mutable_leave();
  void set_allocated_leave(::livekit::LeaveRequest* leave);
  private:
  const ::livekit::LeaveRequest& _internal_leave() const;
  ::livekit::LeaveRequest* _internal_mutable_leave();
  public:
  void unsafe_arena_set_allocated_leave(
      ::livekit::LeaveRequest* leave);
  ::livekit::LeaveRequest* unsafe_arena_release_leave();

  // .livekit.MuteTrackRequest mute = 9;
  bool has_mute() const;
  private:
  bool _internal_has_mute() const;
  public:
  void clear_mute();
  const ::livekit::MuteTrackRequest& mute() const;
  PROTOBUF_NODISCARD ::livekit::MuteTrackRequest* release_mute();
  ::livekit::MuteTrackRequest* mutable_mute();
  void set_allocated_mute(::livekit::MuteTrackRequest* mute);
  private:
  const ::livekit::MuteTrackRequest& _internal_mute() const;
  ::livekit::MuteTrackRequest* _internal_mutable_mute();
  public:
  void unsafe_arena_set_allocated_mute(
      ::livekit::MuteTrackRequest* mute);
  ::livekit::MuteTrackRequest* unsafe_arena_release_mute();

  // .livekit.SpeakersChanged speakers_changed = 10;
  bool has_speakers_changed() const;
  private:
  bool _internal_has_speakers_changed() const;
  public:
  void clear_speakers_changed();
  const ::livekit::SpeakersChanged& speakers_changed() const;
  PROTOBUF_NODISCARD ::livekit::SpeakersChanged* release_speakers_changed();
  ::livekit::SpeakersChanged* mutable_speakers_changed();
  void set_allocated_speakers_changed(::livekit::SpeakersChanged* speakers_changed);
  private:
  const ::livekit::SpeakersChanged& _internal_speakers_changed() const;
  ::livekit::SpeakersChanged* _internal_mutable_speakers_changed();
  public:
  void unsafe_arena_set_allocated_speakers_changed(
      ::livekit::SpeakersChanged* speakers_changed);
  ::livekit::SpeakersChanged* unsafe_arena_release_speakers_changed();

  // .livekit.RoomUpdate room_update = 11;
  bool has_room_update() const;
  private:
  bool _internal_has_room_update() const;
  public:
  void clear_room_update();
  const ::livekit::RoomUpdate& room_update() const;
  PROTOBUF_NODISCARD ::livekit::RoomUpdate* release_room_update();
  ::livekit::RoomUpdate* mutable_room_update();
  void set_allocated_room_update(::livekit::RoomUpdate* room_update);
  private:
  const ::livekit::RoomUpdate& _internal_room_update() const;
  ::livekit::RoomUpdate* _internal_mutable_room_update();
  public:
  void unsafe_arena_set_allocated_room_update(
      ::livekit::RoomUpdate* room_update);
  ::livekit::RoomUpdate* unsafe_arena_release_room_update();

  // .livekit.ConnectionQualityUpdate connection_quality = 12;
  bool has_connection_quality() const;
  private:
  bool _internal_has_connection_quality() const;
  public:
  void clear_connection_quality();
  const ::livekit::ConnectionQualityUpdate& connection_quality() const;
  PROTOBUF_NODISCARD ::livekit::ConnectionQualityUpdate* release_connection_quality();
  ::livekit::ConnectionQualityUpdate* mutable_connection_quality();
  void set_allocated_connection_quality(::livekit::ConnectionQualityUpdate* connection_quality);
  private:
  const ::livekit::ConnectionQualityUpdate& _internal_connection_quality() const;
  ::livekit::ConnectionQualityUpdate* _internal_mutable_connection_quality();
  public:
  void unsafe_arena_set_allocated_connection_quality(
      ::livekit::ConnectionQualityUpdate* connection_quality);
  ::livekit::ConnectionQualityUpdate* unsafe_arena_release_connection_quality();

  // .livekit.StreamStateUpdate stream_state_update = 13;
  bool has_stream_state_update() const;
  private:
  bool _internal_has_stream_state_update() const;
  public:
  void clear_stream_state_update();
  const ::livekit::StreamStateUpdate& stream_state_update() const;
  PROTOBUF_NODISCARD ::livekit::StreamStateUpdate* release_stream_state_update();
  ::livekit::StreamStateUpdate* mutable_stream_state_update();
  void set_allocated_stream_state_update(::livekit::StreamStateUpdate* stream_state_update);
  private:
  const ::livekit::StreamStateUpdate& _internal_stream_state_update() const;
  ::livekit::StreamStateUpdate* _internal_mutable_stream_state_update();
  public:
  void unsafe_arena_set_allocated_stream_state_update(
      ::livekit::StreamStateUpdate* stream_state_update);
  ::livekit::StreamStateUpdate* unsafe_arena_release_stream_state_update();

  // .livekit.SubscribedQualityUpdate subscribed_quality_update = 14;
  bool has_subscribed_quality_update() const;
  private:
  bool _internal_has_subscribed_quality_update() const;
  public:
  void clear_subscribed_quality_update();
  const ::livekit::SubscribedQualityUpdate& subscribed_quality_update() const;
  PROTOBUF_NODISCARD ::livekit::SubscribedQualityUpdate* release_subscribed_quality_update();
  ::livekit::SubscribedQualityUpdate* mutable_subscribed_quality_update();
  void set_allocated_subscribed_quality_update(::livekit::SubscribedQualityUpdate* subscribed_quality_update);
  private:
  const ::livekit::SubscribedQualityUpdate& _internal_subscribed_quality_update() const;
  ::livekit::SubscribedQualityUpdate* _internal_mutable_subscribed_quality_update();
  public:
  void unsafe_arena_set_allocated_subscribed_quality_update(
      ::livekit::SubscribedQualityUpdate* subscribed_quality_update);
  ::livekit::SubscribedQualityUpdate* unsafe_arena_release_subscribed_quality_update();

  // .livekit.SubscriptionPermissionUpdate subscription_permission_update = 15;
  bool has_subscription_permission_update() const;
  private:
  bool _internal_has_subscription_permission_update() const;
  public:
  void clear_subscription_permission_update();
  const ::livekit::SubscriptionPermissionUpdate& subscription_permission_update() const;
  PROTOBUF_NODISCARD ::livekit::SubscriptionPermissionUpdate* release_subscription_permission_update();
  ::livekit::SubscriptionPermissionUpdate* mutable_subscription_permission_update();
  void set_allocated_subscription_permission_update(::livekit::SubscriptionPermissionUpdate* subscription_permission_update);
  private:
  const ::livekit::SubscriptionPermissionUpdate& _internal_subscription_permission_update() const;
  ::livekit::SubscriptionPermissionUpdate* _internal_mutable_subscription_permission_update();
  public:
  void unsafe_arena_set_allocated_subscription_permission_update(
      ::livekit::SubscriptionPermissionUpdate* subscription_permission_update);
  ::livekit::SubscriptionPermissionUpdate* unsafe_arena_release_subscription_permission_update();

  // string refresh_token = 16;
  bool has_refresh_token() const;
  private:
  bool _internal_has_refresh_token() const;
  public:
  void clear_refresh_token();
  const std::string& refresh_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_refresh_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_refresh_token();
  PROTOBUF_NODISCARD std::string* release_refresh_token();
  void set_allocated_refresh_token(std::string* refresh_token);
  private:
  const std::string& _internal_refresh_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_refresh_token(const std::string& value);
  std::string* _internal_mutable_refresh_token();
  public:

  // .livekit.TrackUnpublishedResponse track_unpublished = 17;
  bool has_track_unpublished() const;
  private:
  bool _internal_has_track_unpublished() const;
  public:
  void clear_track_unpublished();
  const ::livekit::TrackUnpublishedResponse& track_unpublished() const;
  PROTOBUF_NODISCARD ::livekit::TrackUnpublishedResponse* release_track_unpublished();
  ::livekit::TrackUnpublishedResponse* mutable_track_unpublished();
  void set_allocated_track_unpublished(::livekit::TrackUnpublishedResponse* track_unpublished);
  private:
  const ::livekit::TrackUnpublishedResponse& _internal_track_unpublished() const;
  ::livekit::TrackUnpublishedResponse* _internal_mutable_track_unpublished();
  public:
  void unsafe_arena_set_allocated_track_unpublished(
      ::livekit::TrackUnpublishedResponse* track_unpublished);
  ::livekit::TrackUnpublishedResponse* unsafe_arena_release_track_unpublished();

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:livekit.SignalResponse)
 private:
  class _Internal;
  void set_has_join();
  void set_has_answer();
  void set_has_offer();
  void set_has_trickle();
  void set_has_update();
  void set_has_track_published();
  void set_has_leave();
  void set_has_mute();
  void set_has_speakers_changed();
  void set_has_room_update();
  void set_has_connection_quality();
  void set_has_stream_state_update();
  void set_has_subscribed_quality_update();
  void set_has_subscription_permission_update();
  void set_has_refresh_token();
  void set_has_track_unpublished();

  inline bool has_message() const;
  inline void clear_has_message();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union MessageUnion {
    constexpr MessageUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::livekit::JoinResponse* join_;
    ::livekit::SessionDescription* answer_;
    ::livekit::SessionDescription* offer_;
    ::livekit::TrickleRequest* trickle_;
    ::livekit::ParticipantUpdate* update_;
    ::livekit::TrackPublishedResponse* track_published_;
    ::livekit::LeaveRequest* leave_;
    ::livekit::MuteTrackRequest* mute_;
    ::livekit::SpeakersChanged* speakers_changed_;
    ::livekit::RoomUpdate* room_update_;
    ::livekit::ConnectionQualityUpdate* connection_quality_;
    ::livekit::StreamStateUpdate* stream_state_update_;
    ::livekit::SubscribedQualityUpdate* subscribed_quality_update_;
    ::livekit::SubscriptionPermissionUpdate* subscription_permission_update_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr refresh_token_;
    ::livekit::TrackUnpublishedResponse* track_unpublished_;
  } message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class AddTrackRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.AddTrackRequest) */ {
 public:
  inline AddTrackRequest() : AddTrackRequest(nullptr) {}
  ~AddTrackRequest() override;
  explicit constexpr AddTrackRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddTrackRequest(const AddTrackRequest& from);
  AddTrackRequest(AddTrackRequest&& from) noexcept
    : AddTrackRequest() {
    *this = ::std::move(from);
  }

  inline AddTrackRequest& operator=(const AddTrackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddTrackRequest& operator=(AddTrackRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddTrackRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddTrackRequest* internal_default_instance() {
    return reinterpret_cast<const AddTrackRequest*>(
               &_AddTrackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AddTrackRequest& a, AddTrackRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddTrackRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddTrackRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddTrackRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddTrackRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddTrackRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddTrackRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddTrackRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.AddTrackRequest";
  }
  protected:
  explicit AddTrackRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLayersFieldNumber = 9,
    kCidFieldNumber = 1,
    kNameFieldNumber = 2,
    kTypeFieldNumber = 3,
    kWidthFieldNumber = 4,
    kHeightFieldNumber = 5,
    kMutedFieldNumber = 6,
    kDisableDtxFieldNumber = 7,
    kSourceFieldNumber = 8,
  };
  // repeated .livekit.VideoLayer layers = 9;
  int layers_size() const;
  private:
  int _internal_layers_size() const;
  public:
  void clear_layers();
  ::livekit::VideoLayer* mutable_layers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::VideoLayer >*
      mutable_layers();
  private:
  const ::livekit::VideoLayer& _internal_layers(int index) const;
  ::livekit::VideoLayer* _internal_add_layers();
  public:
  const ::livekit::VideoLayer& layers(int index) const;
  ::livekit::VideoLayer* add_layers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::VideoLayer >&
      layers() const;

  // string cid = 1;
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .livekit.TrackType type = 3;
  void clear_type();
  ::livekit::TrackType type() const;
  void set_type(::livekit::TrackType value);
  private:
  ::livekit::TrackType _internal_type() const;
  void _internal_set_type(::livekit::TrackType value);
  public:

  // uint32 width = 4;
  void clear_width();
  uint32_t width() const;
  void set_width(uint32_t value);
  private:
  uint32_t _internal_width() const;
  void _internal_set_width(uint32_t value);
  public:

  // uint32 height = 5;
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // bool muted = 6;
  void clear_muted();
  bool muted() const;
  void set_muted(bool value);
  private:
  bool _internal_muted() const;
  void _internal_set_muted(bool value);
  public:

  // bool disable_dtx = 7;
  void clear_disable_dtx();
  bool disable_dtx() const;
  void set_disable_dtx(bool value);
  private:
  bool _internal_disable_dtx() const;
  void _internal_set_disable_dtx(bool value);
  public:

  // .livekit.TrackSource source = 8;
  void clear_source();
  ::livekit::TrackSource source() const;
  void set_source(::livekit::TrackSource value);
  private:
  ::livekit::TrackSource _internal_source() const;
  void _internal_set_source(::livekit::TrackSource value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.AddTrackRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::VideoLayer > layers_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int type_;
  uint32_t width_;
  uint32_t height_;
  bool muted_;
  bool disable_dtx_;
  int source_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class TrickleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.TrickleRequest) */ {
 public:
  inline TrickleRequest() : TrickleRequest(nullptr) {}
  ~TrickleRequest() override;
  explicit constexpr TrickleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrickleRequest(const TrickleRequest& from);
  TrickleRequest(TrickleRequest&& from) noexcept
    : TrickleRequest() {
    *this = ::std::move(from);
  }

  inline TrickleRequest& operator=(const TrickleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrickleRequest& operator=(TrickleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrickleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrickleRequest* internal_default_instance() {
    return reinterpret_cast<const TrickleRequest*>(
               &_TrickleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TrickleRequest& a, TrickleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TrickleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrickleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrickleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrickleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrickleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TrickleRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrickleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.TrickleRequest";
  }
  protected:
  explicit TrickleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCandidateInitFieldNumber = 1,
    kTargetFieldNumber = 2,
  };
  // string candidateInit = 1;
  void clear_candidateinit();
  const std::string& candidateinit() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_candidateinit(ArgT0&& arg0, ArgT... args);
  std::string* mutable_candidateinit();
  PROTOBUF_NODISCARD std::string* release_candidateinit();
  void set_allocated_candidateinit(std::string* candidateinit);
  private:
  const std::string& _internal_candidateinit() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_candidateinit(const std::string& value);
  std::string* _internal_mutable_candidateinit();
  public:

  // .livekit.SignalTarget target = 2;
  void clear_target();
  ::livekit::SignalTarget target() const;
  void set_target(::livekit::SignalTarget value);
  private:
  ::livekit::SignalTarget _internal_target() const;
  void _internal_set_target(::livekit::SignalTarget value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.TrickleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr candidateinit_;
  int target_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class MuteTrackRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.MuteTrackRequest) */ {
 public:
  inline MuteTrackRequest() : MuteTrackRequest(nullptr) {}
  ~MuteTrackRequest() override;
  explicit constexpr MuteTrackRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MuteTrackRequest(const MuteTrackRequest& from);
  MuteTrackRequest(MuteTrackRequest&& from) noexcept
    : MuteTrackRequest() {
    *this = ::std::move(from);
  }

  inline MuteTrackRequest& operator=(const MuteTrackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MuteTrackRequest& operator=(MuteTrackRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MuteTrackRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MuteTrackRequest* internal_default_instance() {
    return reinterpret_cast<const MuteTrackRequest*>(
               &_MuteTrackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MuteTrackRequest& a, MuteTrackRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MuteTrackRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MuteTrackRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MuteTrackRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MuteTrackRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MuteTrackRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MuteTrackRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MuteTrackRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.MuteTrackRequest";
  }
  protected:
  explicit MuteTrackRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSidFieldNumber = 1,
    kMutedFieldNumber = 2,
  };
  // string sid = 1;
  void clear_sid();
  const std::string& sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sid();
  PROTOBUF_NODISCARD std::string* release_sid();
  void set_allocated_sid(std::string* sid);
  private:
  const std::string& _internal_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sid(const std::string& value);
  std::string* _internal_mutable_sid();
  public:

  // bool muted = 2;
  void clear_muted();
  bool muted() const;
  void set_muted(bool value);
  private:
  bool _internal_muted() const;
  void _internal_set_muted(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.MuteTrackRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sid_;
  bool muted_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class JoinResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.JoinResponse) */ {
 public:
  inline JoinResponse() : JoinResponse(nullptr) {}
  ~JoinResponse() override;
  explicit constexpr JoinResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JoinResponse(const JoinResponse& from);
  JoinResponse(JoinResponse&& from) noexcept
    : JoinResponse() {
    *this = ::std::move(from);
  }

  inline JoinResponse& operator=(const JoinResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinResponse& operator=(JoinResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinResponse* internal_default_instance() {
    return reinterpret_cast<const JoinResponse*>(
               &_JoinResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(JoinResponse& a, JoinResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JoinResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JoinResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const JoinResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoinResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.JoinResponse";
  }
  protected:
  explicit JoinResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOtherParticipantsFieldNumber = 3,
    kIceServersFieldNumber = 5,
    kServerVersionFieldNumber = 4,
    kAlternativeUrlFieldNumber = 7,
    kServerRegionFieldNumber = 9,
    kRoomFieldNumber = 1,
    kParticipantFieldNumber = 2,
    kClientConfigurationFieldNumber = 8,
    kSubscriberPrimaryFieldNumber = 6,
  };
  // repeated .livekit.ParticipantInfo other_participants = 3;
  int other_participants_size() const;
  private:
  int _internal_other_participants_size() const;
  public:
  void clear_other_participants();
  ::livekit::ParticipantInfo* mutable_other_participants(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ParticipantInfo >*
      mutable_other_participants();
  private:
  const ::livekit::ParticipantInfo& _internal_other_participants(int index) const;
  ::livekit::ParticipantInfo* _internal_add_other_participants();
  public:
  const ::livekit::ParticipantInfo& other_participants(int index) const;
  ::livekit::ParticipantInfo* add_other_participants();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ParticipantInfo >&
      other_participants() const;

  // repeated .livekit.ICEServer ice_servers = 5;
  int ice_servers_size() const;
  private:
  int _internal_ice_servers_size() const;
  public:
  void clear_ice_servers();
  ::livekit::ICEServer* mutable_ice_servers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ICEServer >*
      mutable_ice_servers();
  private:
  const ::livekit::ICEServer& _internal_ice_servers(int index) const;
  ::livekit::ICEServer* _internal_add_ice_servers();
  public:
  const ::livekit::ICEServer& ice_servers(int index) const;
  ::livekit::ICEServer* add_ice_servers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ICEServer >&
      ice_servers() const;

  // string server_version = 4;
  void clear_server_version();
  const std::string& server_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server_version();
  PROTOBUF_NODISCARD std::string* release_server_version();
  void set_allocated_server_version(std::string* server_version);
  private:
  const std::string& _internal_server_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_version(const std::string& value);
  std::string* _internal_mutable_server_version();
  public:

  // string alternative_url = 7;
  void clear_alternative_url();
  const std::string& alternative_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_alternative_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_alternative_url();
  PROTOBUF_NODISCARD std::string* release_alternative_url();
  void set_allocated_alternative_url(std::string* alternative_url);
  private:
  const std::string& _internal_alternative_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alternative_url(const std::string& value);
  std::string* _internal_mutable_alternative_url();
  public:

  // string server_region = 9;
  void clear_server_region();
  const std::string& server_region() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server_region(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server_region();
  PROTOBUF_NODISCARD std::string* release_server_region();
  void set_allocated_server_region(std::string* server_region);
  private:
  const std::string& _internal_server_region() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_region(const std::string& value);
  std::string* _internal_mutable_server_region();
  public:

  // .livekit.Room room = 1;
  bool has_room() const;
  private:
  bool _internal_has_room() const;
  public:
  void clear_room();
  const ::livekit::Room& room() const;
  PROTOBUF_NODISCARD ::livekit::Room* release_room();
  ::livekit::Room* mutable_room();
  void set_allocated_room(::livekit::Room* room);
  private:
  const ::livekit::Room& _internal_room() const;
  ::livekit::Room* _internal_mutable_room();
  public:
  void unsafe_arena_set_allocated_room(
      ::livekit::Room* room);
  ::livekit::Room* unsafe_arena_release_room();

  // .livekit.ParticipantInfo participant = 2;
  bool has_participant() const;
  private:
  bool _internal_has_participant() const;
  public:
  void clear_participant();
  const ::livekit::ParticipantInfo& participant() const;
  PROTOBUF_NODISCARD ::livekit::ParticipantInfo* release_participant();
  ::livekit::ParticipantInfo* mutable_participant();
  void set_allocated_participant(::livekit::ParticipantInfo* participant);
  private:
  const ::livekit::ParticipantInfo& _internal_participant() const;
  ::livekit::ParticipantInfo* _internal_mutable_participant();
  public:
  void unsafe_arena_set_allocated_participant(
      ::livekit::ParticipantInfo* participant);
  ::livekit::ParticipantInfo* unsafe_arena_release_participant();

  // .livekit.ClientConfiguration client_configuration = 8;
  bool has_client_configuration() const;
  private:
  bool _internal_has_client_configuration() const;
  public:
  void clear_client_configuration();
  const ::livekit::ClientConfiguration& client_configuration() const;
  PROTOBUF_NODISCARD ::livekit::ClientConfiguration* release_client_configuration();
  ::livekit::ClientConfiguration* mutable_client_configuration();
  void set_allocated_client_configuration(::livekit::ClientConfiguration* client_configuration);
  private:
  const ::livekit::ClientConfiguration& _internal_client_configuration() const;
  ::livekit::ClientConfiguration* _internal_mutable_client_configuration();
  public:
  void unsafe_arena_set_allocated_client_configuration(
      ::livekit::ClientConfiguration* client_configuration);
  ::livekit::ClientConfiguration* unsafe_arena_release_client_configuration();

  // bool subscriber_primary = 6;
  void clear_subscriber_primary();
  bool subscriber_primary() const;
  void set_subscriber_primary(bool value);
  private:
  bool _internal_subscriber_primary() const;
  void _internal_set_subscriber_primary(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.JoinResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ParticipantInfo > other_participants_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ICEServer > ice_servers_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr alternative_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_region_;
  ::livekit::Room* room_;
  ::livekit::ParticipantInfo* participant_;
  ::livekit::ClientConfiguration* client_configuration_;
  bool subscriber_primary_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class TrackPublishedResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.TrackPublishedResponse) */ {
 public:
  inline TrackPublishedResponse() : TrackPublishedResponse(nullptr) {}
  ~TrackPublishedResponse() override;
  explicit constexpr TrackPublishedResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrackPublishedResponse(const TrackPublishedResponse& from);
  TrackPublishedResponse(TrackPublishedResponse&& from) noexcept
    : TrackPublishedResponse() {
    *this = ::std::move(from);
  }

  inline TrackPublishedResponse& operator=(const TrackPublishedResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackPublishedResponse& operator=(TrackPublishedResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackPublishedResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackPublishedResponse* internal_default_instance() {
    return reinterpret_cast<const TrackPublishedResponse*>(
               &_TrackPublishedResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TrackPublishedResponse& a, TrackPublishedResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackPublishedResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackPublishedResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackPublishedResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackPublishedResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrackPublishedResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TrackPublishedResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackPublishedResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.TrackPublishedResponse";
  }
  protected:
  explicit TrackPublishedResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCidFieldNumber = 1,
    kTrackFieldNumber = 2,
  };
  // string cid = 1;
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // .livekit.TrackInfo track = 2;
  bool has_track() const;
  private:
  bool _internal_has_track() const;
  public:
  void clear_track();
  const ::livekit::TrackInfo& track() const;
  PROTOBUF_NODISCARD ::livekit::TrackInfo* release_track();
  ::livekit::TrackInfo* mutable_track();
  void set_allocated_track(::livekit::TrackInfo* track);
  private:
  const ::livekit::TrackInfo& _internal_track() const;
  ::livekit::TrackInfo* _internal_mutable_track();
  public:
  void unsafe_arena_set_allocated_track(
      ::livekit::TrackInfo* track);
  ::livekit::TrackInfo* unsafe_arena_release_track();

  // @@protoc_insertion_point(class_scope:livekit.TrackPublishedResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
  ::livekit::TrackInfo* track_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class TrackUnpublishedResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.TrackUnpublishedResponse) */ {
 public:
  inline TrackUnpublishedResponse() : TrackUnpublishedResponse(nullptr) {}
  ~TrackUnpublishedResponse() override;
  explicit constexpr TrackUnpublishedResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrackUnpublishedResponse(const TrackUnpublishedResponse& from);
  TrackUnpublishedResponse(TrackUnpublishedResponse&& from) noexcept
    : TrackUnpublishedResponse() {
    *this = ::std::move(from);
  }

  inline TrackUnpublishedResponse& operator=(const TrackUnpublishedResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackUnpublishedResponse& operator=(TrackUnpublishedResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackUnpublishedResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackUnpublishedResponse* internal_default_instance() {
    return reinterpret_cast<const TrackUnpublishedResponse*>(
               &_TrackUnpublishedResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TrackUnpublishedResponse& a, TrackUnpublishedResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackUnpublishedResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackUnpublishedResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackUnpublishedResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackUnpublishedResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrackUnpublishedResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TrackUnpublishedResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackUnpublishedResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.TrackUnpublishedResponse";
  }
  protected:
  explicit TrackUnpublishedResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrackSidFieldNumber = 1,
  };
  // string track_sid = 1;
  void clear_track_sid();
  const std::string& track_sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_track_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_track_sid();
  PROTOBUF_NODISCARD std::string* release_track_sid();
  void set_allocated_track_sid(std::string* track_sid);
  private:
  const std::string& _internal_track_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_track_sid(const std::string& value);
  std::string* _internal_mutable_track_sid();
  public:

  // @@protoc_insertion_point(class_scope:livekit.TrackUnpublishedResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr track_sid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class SessionDescription final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.SessionDescription) */ {
 public:
  inline SessionDescription() : SessionDescription(nullptr) {}
  ~SessionDescription() override;
  explicit constexpr SessionDescription(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionDescription(const SessionDescription& from);
  SessionDescription(SessionDescription&& from) noexcept
    : SessionDescription() {
    *this = ::std::move(from);
  }

  inline SessionDescription& operator=(const SessionDescription& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionDescription& operator=(SessionDescription&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionDescription& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionDescription* internal_default_instance() {
    return reinterpret_cast<const SessionDescription*>(
               &_SessionDescription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SessionDescription& a, SessionDescription& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionDescription* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionDescription* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionDescription* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionDescription>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SessionDescription& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SessionDescription& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionDescription* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.SessionDescription";
  }
  protected:
  explicit SessionDescription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kSdpFieldNumber = 2,
  };
  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string sdp = 2;
  void clear_sdp();
  const std::string& sdp() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sdp(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sdp();
  PROTOBUF_NODISCARD std::string* release_sdp();
  void set_allocated_sdp(std::string* sdp);
  private:
  const std::string& _internal_sdp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdp(const std::string& value);
  std::string* _internal_mutable_sdp();
  public:

  // @@protoc_insertion_point(class_scope:livekit.SessionDescription)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sdp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class ParticipantUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.ParticipantUpdate) */ {
 public:
  inline ParticipantUpdate() : ParticipantUpdate(nullptr) {}
  ~ParticipantUpdate() override;
  explicit constexpr ParticipantUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ParticipantUpdate(const ParticipantUpdate& from);
  ParticipantUpdate(ParticipantUpdate&& from) noexcept
    : ParticipantUpdate() {
    *this = ::std::move(from);
  }

  inline ParticipantUpdate& operator=(const ParticipantUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParticipantUpdate& operator=(ParticipantUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParticipantUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const ParticipantUpdate* internal_default_instance() {
    return reinterpret_cast<const ParticipantUpdate*>(
               &_ParticipantUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ParticipantUpdate& a, ParticipantUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(ParticipantUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParticipantUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ParticipantUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ParticipantUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ParticipantUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ParticipantUpdate& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParticipantUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.ParticipantUpdate";
  }
  protected:
  explicit ParticipantUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantsFieldNumber = 1,
  };
  // repeated .livekit.ParticipantInfo participants = 1;
  int participants_size() const;
  private:
  int _internal_participants_size() const;
  public:
  void clear_participants();
  ::livekit::ParticipantInfo* mutable_participants(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ParticipantInfo >*
      mutable_participants();
  private:
  const ::livekit::ParticipantInfo& _internal_participants(int index) const;
  ::livekit::ParticipantInfo* _internal_add_participants();
  public:
  const ::livekit::ParticipantInfo& participants(int index) const;
  ::livekit::ParticipantInfo* add_participants();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ParticipantInfo >&
      participants() const;

  // @@protoc_insertion_point(class_scope:livekit.ParticipantUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ParticipantInfo > participants_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class UpdateSubscription final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.UpdateSubscription) */ {
 public:
  inline UpdateSubscription() : UpdateSubscription(nullptr) {}
  ~UpdateSubscription() override;
  explicit constexpr UpdateSubscription(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateSubscription(const UpdateSubscription& from);
  UpdateSubscription(UpdateSubscription&& from) noexcept
    : UpdateSubscription() {
    *this = ::std::move(from);
  }

  inline UpdateSubscription& operator=(const UpdateSubscription& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateSubscription& operator=(UpdateSubscription&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateSubscription& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateSubscription* internal_default_instance() {
    return reinterpret_cast<const UpdateSubscription*>(
               &_UpdateSubscription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(UpdateSubscription& a, UpdateSubscription& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateSubscription* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateSubscription* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateSubscription* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateSubscription>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateSubscription& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateSubscription& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateSubscription* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.UpdateSubscription";
  }
  protected:
  explicit UpdateSubscription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrackSidsFieldNumber = 1,
    kParticipantTracksFieldNumber = 3,
    kSubscribeFieldNumber = 2,
  };
  // repeated string track_sids = 1;
  int track_sids_size() const;
  private:
  int _internal_track_sids_size() const;
  public:
  void clear_track_sids();
  const std::string& track_sids(int index) const;
  std::string* mutable_track_sids(int index);
  void set_track_sids(int index, const std::string& value);
  void set_track_sids(int index, std::string&& value);
  void set_track_sids(int index, const char* value);
  void set_track_sids(int index, const char* value, size_t size);
  std::string* add_track_sids();
  void add_track_sids(const std::string& value);
  void add_track_sids(std::string&& value);
  void add_track_sids(const char* value);
  void add_track_sids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& track_sids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_track_sids();
  private:
  const std::string& _internal_track_sids(int index) const;
  std::string* _internal_add_track_sids();
  public:

  // repeated .livekit.ParticipantTracks participant_tracks = 3;
  int participant_tracks_size() const;
  private:
  int _internal_participant_tracks_size() const;
  public:
  void clear_participant_tracks();
  ::livekit::ParticipantTracks* mutable_participant_tracks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ParticipantTracks >*
      mutable_participant_tracks();
  private:
  const ::livekit::ParticipantTracks& _internal_participant_tracks(int index) const;
  ::livekit::ParticipantTracks* _internal_add_participant_tracks();
  public:
  const ::livekit::ParticipantTracks& participant_tracks(int index) const;
  ::livekit::ParticipantTracks* add_participant_tracks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ParticipantTracks >&
      participant_tracks() const;

  // bool subscribe = 2;
  void clear_subscribe();
  bool subscribe() const;
  void set_subscribe(bool value);
  private:
  bool _internal_subscribe() const;
  void _internal_set_subscribe(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.UpdateSubscription)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> track_sids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ParticipantTracks > participant_tracks_;
  bool subscribe_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class UpdateTrackSettings final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.UpdateTrackSettings) */ {
 public:
  inline UpdateTrackSettings() : UpdateTrackSettings(nullptr) {}
  ~UpdateTrackSettings() override;
  explicit constexpr UpdateTrackSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateTrackSettings(const UpdateTrackSettings& from);
  UpdateTrackSettings(UpdateTrackSettings&& from) noexcept
    : UpdateTrackSettings() {
    *this = ::std::move(from);
  }

  inline UpdateTrackSettings& operator=(const UpdateTrackSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateTrackSettings& operator=(UpdateTrackSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateTrackSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateTrackSettings* internal_default_instance() {
    return reinterpret_cast<const UpdateTrackSettings*>(
               &_UpdateTrackSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(UpdateTrackSettings& a, UpdateTrackSettings& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateTrackSettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateTrackSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateTrackSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateTrackSettings>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateTrackSettings& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateTrackSettings& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateTrackSettings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.UpdateTrackSettings";
  }
  protected:
  explicit UpdateTrackSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrackSidsFieldNumber = 1,
    kDisabledFieldNumber = 3,
    kQualityFieldNumber = 4,
    kWidthFieldNumber = 5,
    kHeightFieldNumber = 6,
  };
  // repeated string track_sids = 1;
  int track_sids_size() const;
  private:
  int _internal_track_sids_size() const;
  public:
  void clear_track_sids();
  const std::string& track_sids(int index) const;
  std::string* mutable_track_sids(int index);
  void set_track_sids(int index, const std::string& value);
  void set_track_sids(int index, std::string&& value);
  void set_track_sids(int index, const char* value);
  void set_track_sids(int index, const char* value, size_t size);
  std::string* add_track_sids();
  void add_track_sids(const std::string& value);
  void add_track_sids(std::string&& value);
  void add_track_sids(const char* value);
  void add_track_sids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& track_sids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_track_sids();
  private:
  const std::string& _internal_track_sids(int index) const;
  std::string* _internal_add_track_sids();
  public:

  // bool disabled = 3;
  void clear_disabled();
  bool disabled() const;
  void set_disabled(bool value);
  private:
  bool _internal_disabled() const;
  void _internal_set_disabled(bool value);
  public:

  // .livekit.VideoQuality quality = 4;
  void clear_quality();
  ::livekit::VideoQuality quality() const;
  void set_quality(::livekit::VideoQuality value);
  private:
  ::livekit::VideoQuality _internal_quality() const;
  void _internal_set_quality(::livekit::VideoQuality value);
  public:

  // uint32 width = 5;
  void clear_width();
  uint32_t width() const;
  void set_width(uint32_t value);
  private:
  uint32_t _internal_width() const;
  void _internal_set_width(uint32_t value);
  public:

  // uint32 height = 6;
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.UpdateTrackSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> track_sids_;
  bool disabled_;
  int quality_;
  uint32_t width_;
  uint32_t height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class LeaveRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.LeaveRequest) */ {
 public:
  inline LeaveRequest() : LeaveRequest(nullptr) {}
  ~LeaveRequest() override;
  explicit constexpr LeaveRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeaveRequest(const LeaveRequest& from);
  LeaveRequest(LeaveRequest&& from) noexcept
    : LeaveRequest() {
    *this = ::std::move(from);
  }

  inline LeaveRequest& operator=(const LeaveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaveRequest& operator=(LeaveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeaveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeaveRequest* internal_default_instance() {
    return reinterpret_cast<const LeaveRequest*>(
               &_LeaveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(LeaveRequest& a, LeaveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaveRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaveRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeaveRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LeaveRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LeaveRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LeaveRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeaveRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.LeaveRequest";
  }
  protected:
  explicit LeaveRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCanReconnectFieldNumber = 1,
  };
  // bool can_reconnect = 1;
  void clear_can_reconnect();
  bool can_reconnect() const;
  void set_can_reconnect(bool value);
  private:
  bool _internal_can_reconnect() const;
  void _internal_set_can_reconnect(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.LeaveRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool can_reconnect_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class UpdateVideoLayers final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.UpdateVideoLayers) */ {
 public:
  inline UpdateVideoLayers() : UpdateVideoLayers(nullptr) {}
  ~UpdateVideoLayers() override;
  explicit constexpr UpdateVideoLayers(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateVideoLayers(const UpdateVideoLayers& from);
  UpdateVideoLayers(UpdateVideoLayers&& from) noexcept
    : UpdateVideoLayers() {
    *this = ::std::move(from);
  }

  inline UpdateVideoLayers& operator=(const UpdateVideoLayers& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateVideoLayers& operator=(UpdateVideoLayers&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateVideoLayers& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateVideoLayers* internal_default_instance() {
    return reinterpret_cast<const UpdateVideoLayers*>(
               &_UpdateVideoLayers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(UpdateVideoLayers& a, UpdateVideoLayers& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateVideoLayers* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateVideoLayers* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateVideoLayers* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateVideoLayers>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateVideoLayers& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateVideoLayers& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateVideoLayers* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.UpdateVideoLayers";
  }
  protected:
  explicit UpdateVideoLayers(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLayersFieldNumber = 2,
    kTrackSidFieldNumber = 1,
  };
  // repeated .livekit.VideoLayer layers = 2;
  int layers_size() const;
  private:
  int _internal_layers_size() const;
  public:
  void clear_layers();
  ::livekit::VideoLayer* mutable_layers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::VideoLayer >*
      mutable_layers();
  private:
  const ::livekit::VideoLayer& _internal_layers(int index) const;
  ::livekit::VideoLayer* _internal_add_layers();
  public:
  const ::livekit::VideoLayer& layers(int index) const;
  ::livekit::VideoLayer* add_layers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::VideoLayer >&
      layers() const;

  // string track_sid = 1;
  void clear_track_sid();
  const std::string& track_sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_track_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_track_sid();
  PROTOBUF_NODISCARD std::string* release_track_sid();
  void set_allocated_track_sid(std::string* track_sid);
  private:
  const std::string& _internal_track_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_track_sid(const std::string& value);
  std::string* _internal_mutable_track_sid();
  public:

  // @@protoc_insertion_point(class_scope:livekit.UpdateVideoLayers)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::VideoLayer > layers_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr track_sid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class ICEServer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.ICEServer) */ {
 public:
  inline ICEServer() : ICEServer(nullptr) {}
  ~ICEServer() override;
  explicit constexpr ICEServer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ICEServer(const ICEServer& from);
  ICEServer(ICEServer&& from) noexcept
    : ICEServer() {
    *this = ::std::move(from);
  }

  inline ICEServer& operator=(const ICEServer& from) {
    CopyFrom(from);
    return *this;
  }
  inline ICEServer& operator=(ICEServer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ICEServer& default_instance() {
    return *internal_default_instance();
  }
  static inline const ICEServer* internal_default_instance() {
    return reinterpret_cast<const ICEServer*>(
               &_ICEServer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ICEServer& a, ICEServer& b) {
    a.Swap(&b);
  }
  inline void Swap(ICEServer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ICEServer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ICEServer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ICEServer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ICEServer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ICEServer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ICEServer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.ICEServer";
  }
  protected:
  explicit ICEServer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlsFieldNumber = 1,
    kUsernameFieldNumber = 2,
    kCredentialFieldNumber = 3,
  };
  // repeated string urls = 1;
  int urls_size() const;
  private:
  int _internal_urls_size() const;
  public:
  void clear_urls();
  const std::string& urls(int index) const;
  std::string* mutable_urls(int index);
  void set_urls(int index, const std::string& value);
  void set_urls(int index, std::string&& value);
  void set_urls(int index, const char* value);
  void set_urls(int index, const char* value, size_t size);
  std::string* add_urls();
  void add_urls(const std::string& value);
  void add_urls(std::string&& value);
  void add_urls(const char* value);
  void add_urls(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& urls() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_urls();
  private:
  const std::string& _internal_urls(int index) const;
  std::string* _internal_add_urls();
  public:

  // string username = 2;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string credential = 3;
  void clear_credential();
  const std::string& credential() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_credential(ArgT0&& arg0, ArgT... args);
  std::string* mutable_credential();
  PROTOBUF_NODISCARD std::string* release_credential();
  void set_allocated_credential(std::string* credential);
  private:
  const std::string& _internal_credential() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_credential(const std::string& value);
  std::string* _internal_mutable_credential();
  public:

  // @@protoc_insertion_point(class_scope:livekit.ICEServer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> urls_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr credential_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class SpeakersChanged final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.SpeakersChanged) */ {
 public:
  inline SpeakersChanged() : SpeakersChanged(nullptr) {}
  ~SpeakersChanged() override;
  explicit constexpr SpeakersChanged(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpeakersChanged(const SpeakersChanged& from);
  SpeakersChanged(SpeakersChanged&& from) noexcept
    : SpeakersChanged() {
    *this = ::std::move(from);
  }

  inline SpeakersChanged& operator=(const SpeakersChanged& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpeakersChanged& operator=(SpeakersChanged&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpeakersChanged& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpeakersChanged* internal_default_instance() {
    return reinterpret_cast<const SpeakersChanged*>(
               &_SpeakersChanged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SpeakersChanged& a, SpeakersChanged& b) {
    a.Swap(&b);
  }
  inline void Swap(SpeakersChanged* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpeakersChanged* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpeakersChanged* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpeakersChanged>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpeakersChanged& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SpeakersChanged& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpeakersChanged* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.SpeakersChanged";
  }
  protected:
  explicit SpeakersChanged(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpeakersFieldNumber = 1,
  };
  // repeated .livekit.SpeakerInfo speakers = 1;
  int speakers_size() const;
  private:
  int _internal_speakers_size() const;
  public:
  void clear_speakers();
  ::livekit::SpeakerInfo* mutable_speakers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SpeakerInfo >*
      mutable_speakers();
  private:
  const ::livekit::SpeakerInfo& _internal_speakers(int index) const;
  ::livekit::SpeakerInfo* _internal_add_speakers();
  public:
  const ::livekit::SpeakerInfo& speakers(int index) const;
  ::livekit::SpeakerInfo* add_speakers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SpeakerInfo >&
      speakers() const;

  // @@protoc_insertion_point(class_scope:livekit.SpeakersChanged)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SpeakerInfo > speakers_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class RoomUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.RoomUpdate) */ {
 public:
  inline RoomUpdate() : RoomUpdate(nullptr) {}
  ~RoomUpdate() override;
  explicit constexpr RoomUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomUpdate(const RoomUpdate& from);
  RoomUpdate(RoomUpdate&& from) noexcept
    : RoomUpdate() {
    *this = ::std::move(from);
  }

  inline RoomUpdate& operator=(const RoomUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomUpdate& operator=(RoomUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomUpdate* internal_default_instance() {
    return reinterpret_cast<const RoomUpdate*>(
               &_RoomUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(RoomUpdate& a, RoomUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoomUpdate& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.RoomUpdate";
  }
  protected:
  explicit RoomUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomFieldNumber = 1,
  };
  // .livekit.Room room = 1;
  bool has_room() const;
  private:
  bool _internal_has_room() const;
  public:
  void clear_room();
  const ::livekit::Room& room() const;
  PROTOBUF_NODISCARD ::livekit::Room* release_room();
  ::livekit::Room* mutable_room();
  void set_allocated_room(::livekit::Room* room);
  private:
  const ::livekit::Room& _internal_room() const;
  ::livekit::Room* _internal_mutable_room();
  public:
  void unsafe_arena_set_allocated_room(
      ::livekit::Room* room);
  ::livekit::Room* unsafe_arena_release_room();

  // @@protoc_insertion_point(class_scope:livekit.RoomUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::livekit::Room* room_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class ConnectionQualityInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.ConnectionQualityInfo) */ {
 public:
  inline ConnectionQualityInfo() : ConnectionQualityInfo(nullptr) {}
  ~ConnectionQualityInfo() override;
  explicit constexpr ConnectionQualityInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectionQualityInfo(const ConnectionQualityInfo& from);
  ConnectionQualityInfo(ConnectionQualityInfo&& from) noexcept
    : ConnectionQualityInfo() {
    *this = ::std::move(from);
  }

  inline ConnectionQualityInfo& operator=(const ConnectionQualityInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectionQualityInfo& operator=(ConnectionQualityInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectionQualityInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectionQualityInfo* internal_default_instance() {
    return reinterpret_cast<const ConnectionQualityInfo*>(
               &_ConnectionQualityInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ConnectionQualityInfo& a, ConnectionQualityInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectionQualityInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectionQualityInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectionQualityInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectionQualityInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConnectionQualityInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConnectionQualityInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectionQualityInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.ConnectionQualityInfo";
  }
  protected:
  explicit ConnectionQualityInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantSidFieldNumber = 1,
    kQualityFieldNumber = 2,
    kScoreFieldNumber = 3,
  };
  // string participant_sid = 1;
  void clear_participant_sid();
  const std::string& participant_sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_sid();
  PROTOBUF_NODISCARD std::string* release_participant_sid();
  void set_allocated_participant_sid(std::string* participant_sid);
  private:
  const std::string& _internal_participant_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_sid(const std::string& value);
  std::string* _internal_mutable_participant_sid();
  public:

  // .livekit.ConnectionQuality quality = 2;
  void clear_quality();
  ::livekit::ConnectionQuality quality() const;
  void set_quality(::livekit::ConnectionQuality value);
  private:
  ::livekit::ConnectionQuality _internal_quality() const;
  void _internal_set_quality(::livekit::ConnectionQuality value);
  public:

  // float score = 3;
  void clear_score();
  float score() const;
  void set_score(float value);
  private:
  float _internal_score() const;
  void _internal_set_score(float value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.ConnectionQualityInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_sid_;
  int quality_;
  float score_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class ConnectionQualityUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.ConnectionQualityUpdate) */ {
 public:
  inline ConnectionQualityUpdate() : ConnectionQualityUpdate(nullptr) {}
  ~ConnectionQualityUpdate() override;
  explicit constexpr ConnectionQualityUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectionQualityUpdate(const ConnectionQualityUpdate& from);
  ConnectionQualityUpdate(ConnectionQualityUpdate&& from) noexcept
    : ConnectionQualityUpdate() {
    *this = ::std::move(from);
  }

  inline ConnectionQualityUpdate& operator=(const ConnectionQualityUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectionQualityUpdate& operator=(ConnectionQualityUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectionQualityUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectionQualityUpdate* internal_default_instance() {
    return reinterpret_cast<const ConnectionQualityUpdate*>(
               &_ConnectionQualityUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ConnectionQualityUpdate& a, ConnectionQualityUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectionQualityUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectionQualityUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectionQualityUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectionQualityUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConnectionQualityUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConnectionQualityUpdate& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectionQualityUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.ConnectionQualityUpdate";
  }
  protected:
  explicit ConnectionQualityUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUpdatesFieldNumber = 1,
  };
  // repeated .livekit.ConnectionQualityInfo updates = 1;
  int updates_size() const;
  private:
  int _internal_updates_size() const;
  public:
  void clear_updates();
  ::livekit::ConnectionQualityInfo* mutable_updates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ConnectionQualityInfo >*
      mutable_updates();
  private:
  const ::livekit::ConnectionQualityInfo& _internal_updates(int index) const;
  ::livekit::ConnectionQualityInfo* _internal_add_updates();
  public:
  const ::livekit::ConnectionQualityInfo& updates(int index) const;
  ::livekit::ConnectionQualityInfo* add_updates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ConnectionQualityInfo >&
      updates() const;

  // @@protoc_insertion_point(class_scope:livekit.ConnectionQualityUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ConnectionQualityInfo > updates_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class StreamStateInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.StreamStateInfo) */ {
 public:
  inline StreamStateInfo() : StreamStateInfo(nullptr) {}
  ~StreamStateInfo() override;
  explicit constexpr StreamStateInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamStateInfo(const StreamStateInfo& from);
  StreamStateInfo(StreamStateInfo&& from) noexcept
    : StreamStateInfo() {
    *this = ::std::move(from);
  }

  inline StreamStateInfo& operator=(const StreamStateInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamStateInfo& operator=(StreamStateInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamStateInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamStateInfo* internal_default_instance() {
    return reinterpret_cast<const StreamStateInfo*>(
               &_StreamStateInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(StreamStateInfo& a, StreamStateInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamStateInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamStateInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamStateInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamStateInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamStateInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StreamStateInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamStateInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.StreamStateInfo";
  }
  protected:
  explicit StreamStateInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantSidFieldNumber = 1,
    kTrackSidFieldNumber = 2,
    kStateFieldNumber = 3,
  };
  // string participant_sid = 1;
  void clear_participant_sid();
  const std::string& participant_sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_sid();
  PROTOBUF_NODISCARD std::string* release_participant_sid();
  void set_allocated_participant_sid(std::string* participant_sid);
  private:
  const std::string& _internal_participant_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_sid(const std::string& value);
  std::string* _internal_mutable_participant_sid();
  public:

  // string track_sid = 2;
  void clear_track_sid();
  const std::string& track_sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_track_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_track_sid();
  PROTOBUF_NODISCARD std::string* release_track_sid();
  void set_allocated_track_sid(std::string* track_sid);
  private:
  const std::string& _internal_track_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_track_sid(const std::string& value);
  std::string* _internal_mutable_track_sid();
  public:

  // .livekit.StreamState state = 3;
  void clear_state();
  ::livekit::StreamState state() const;
  void set_state(::livekit::StreamState value);
  private:
  ::livekit::StreamState _internal_state() const;
  void _internal_set_state(::livekit::StreamState value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.StreamStateInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_sid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr track_sid_;
  int state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class StreamStateUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.StreamStateUpdate) */ {
 public:
  inline StreamStateUpdate() : StreamStateUpdate(nullptr) {}
  ~StreamStateUpdate() override;
  explicit constexpr StreamStateUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamStateUpdate(const StreamStateUpdate& from);
  StreamStateUpdate(StreamStateUpdate&& from) noexcept
    : StreamStateUpdate() {
    *this = ::std::move(from);
  }

  inline StreamStateUpdate& operator=(const StreamStateUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamStateUpdate& operator=(StreamStateUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamStateUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamStateUpdate* internal_default_instance() {
    return reinterpret_cast<const StreamStateUpdate*>(
               &_StreamStateUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(StreamStateUpdate& a, StreamStateUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamStateUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamStateUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamStateUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamStateUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamStateUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StreamStateUpdate& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamStateUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.StreamStateUpdate";
  }
  protected:
  explicit StreamStateUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamStatesFieldNumber = 1,
  };
  // repeated .livekit.StreamStateInfo stream_states = 1;
  int stream_states_size() const;
  private:
  int _internal_stream_states_size() const;
  public:
  void clear_stream_states();
  ::livekit::StreamStateInfo* mutable_stream_states(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::StreamStateInfo >*
      mutable_stream_states();
  private:
  const ::livekit::StreamStateInfo& _internal_stream_states(int index) const;
  ::livekit::StreamStateInfo* _internal_add_stream_states();
  public:
  const ::livekit::StreamStateInfo& stream_states(int index) const;
  ::livekit::StreamStateInfo* add_stream_states();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::StreamStateInfo >&
      stream_states() const;

  // @@protoc_insertion_point(class_scope:livekit.StreamStateUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::StreamStateInfo > stream_states_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class SubscribedQuality final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.SubscribedQuality) */ {
 public:
  inline SubscribedQuality() : SubscribedQuality(nullptr) {}
  ~SubscribedQuality() override;
  explicit constexpr SubscribedQuality(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribedQuality(const SubscribedQuality& from);
  SubscribedQuality(SubscribedQuality&& from) noexcept
    : SubscribedQuality() {
    *this = ::std::move(from);
  }

  inline SubscribedQuality& operator=(const SubscribedQuality& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribedQuality& operator=(SubscribedQuality&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribedQuality& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribedQuality* internal_default_instance() {
    return reinterpret_cast<const SubscribedQuality*>(
               &_SubscribedQuality_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SubscribedQuality& a, SubscribedQuality& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribedQuality* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribedQuality* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribedQuality* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribedQuality>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscribedQuality& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SubscribedQuality& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribedQuality* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.SubscribedQuality";
  }
  protected:
  explicit SubscribedQuality(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQualityFieldNumber = 1,
    kEnabledFieldNumber = 2,
  };
  // .livekit.VideoQuality quality = 1;
  void clear_quality();
  ::livekit::VideoQuality quality() const;
  void set_quality(::livekit::VideoQuality value);
  private:
  ::livekit::VideoQuality _internal_quality() const;
  void _internal_set_quality(::livekit::VideoQuality value);
  public:

  // bool enabled = 2;
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.SubscribedQuality)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int quality_;
  bool enabled_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class SubscribedQualityUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.SubscribedQualityUpdate) */ {
 public:
  inline SubscribedQualityUpdate() : SubscribedQualityUpdate(nullptr) {}
  ~SubscribedQualityUpdate() override;
  explicit constexpr SubscribedQualityUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribedQualityUpdate(const SubscribedQualityUpdate& from);
  SubscribedQualityUpdate(SubscribedQualityUpdate&& from) noexcept
    : SubscribedQualityUpdate() {
    *this = ::std::move(from);
  }

  inline SubscribedQualityUpdate& operator=(const SubscribedQualityUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribedQualityUpdate& operator=(SubscribedQualityUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribedQualityUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribedQualityUpdate* internal_default_instance() {
    return reinterpret_cast<const SubscribedQualityUpdate*>(
               &_SubscribedQualityUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SubscribedQualityUpdate& a, SubscribedQualityUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribedQualityUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribedQualityUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribedQualityUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribedQualityUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscribedQualityUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SubscribedQualityUpdate& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribedQualityUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.SubscribedQualityUpdate";
  }
  protected:
  explicit SubscribedQualityUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubscribedQualitiesFieldNumber = 2,
    kTrackSidFieldNumber = 1,
  };
  // repeated .livekit.SubscribedQuality subscribed_qualities = 2;
  int subscribed_qualities_size() const;
  private:
  int _internal_subscribed_qualities_size() const;
  public:
  void clear_subscribed_qualities();
  ::livekit::SubscribedQuality* mutable_subscribed_qualities(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SubscribedQuality >*
      mutable_subscribed_qualities();
  private:
  const ::livekit::SubscribedQuality& _internal_subscribed_qualities(int index) const;
  ::livekit::SubscribedQuality* _internal_add_subscribed_qualities();
  public:
  const ::livekit::SubscribedQuality& subscribed_qualities(int index) const;
  ::livekit::SubscribedQuality* add_subscribed_qualities();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SubscribedQuality >&
      subscribed_qualities() const;

  // string track_sid = 1;
  void clear_track_sid();
  const std::string& track_sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_track_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_track_sid();
  PROTOBUF_NODISCARD std::string* release_track_sid();
  void set_allocated_track_sid(std::string* track_sid);
  private:
  const std::string& _internal_track_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_track_sid(const std::string& value);
  std::string* _internal_mutable_track_sid();
  public:

  // @@protoc_insertion_point(class_scope:livekit.SubscribedQualityUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SubscribedQuality > subscribed_qualities_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr track_sid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class TrackPermission final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.TrackPermission) */ {
 public:
  inline TrackPermission() : TrackPermission(nullptr) {}
  ~TrackPermission() override;
  explicit constexpr TrackPermission(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrackPermission(const TrackPermission& from);
  TrackPermission(TrackPermission&& from) noexcept
    : TrackPermission() {
    *this = ::std::move(from);
  }

  inline TrackPermission& operator=(const TrackPermission& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackPermission& operator=(TrackPermission&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackPermission& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackPermission* internal_default_instance() {
    return reinterpret_cast<const TrackPermission*>(
               &_TrackPermission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(TrackPermission& a, TrackPermission& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackPermission* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackPermission* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackPermission* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackPermission>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrackPermission& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TrackPermission& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackPermission* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.TrackPermission";
  }
  protected:
  explicit TrackPermission(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrackSidsFieldNumber = 3,
    kParticipantSidFieldNumber = 1,
    kParticipantIdentityFieldNumber = 4,
    kAllTracksFieldNumber = 2,
  };
  // repeated string track_sids = 3;
  int track_sids_size() const;
  private:
  int _internal_track_sids_size() const;
  public:
  void clear_track_sids();
  const std::string& track_sids(int index) const;
  std::string* mutable_track_sids(int index);
  void set_track_sids(int index, const std::string& value);
  void set_track_sids(int index, std::string&& value);
  void set_track_sids(int index, const char* value);
  void set_track_sids(int index, const char* value, size_t size);
  std::string* add_track_sids();
  void add_track_sids(const std::string& value);
  void add_track_sids(std::string&& value);
  void add_track_sids(const char* value);
  void add_track_sids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& track_sids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_track_sids();
  private:
  const std::string& _internal_track_sids(int index) const;
  std::string* _internal_add_track_sids();
  public:

  // string participant_sid = 1;
  void clear_participant_sid();
  const std::string& participant_sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_sid();
  PROTOBUF_NODISCARD std::string* release_participant_sid();
  void set_allocated_participant_sid(std::string* participant_sid);
  private:
  const std::string& _internal_participant_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_sid(const std::string& value);
  std::string* _internal_mutable_participant_sid();
  public:

  // string participant_identity = 4;
  void clear_participant_identity();
  const std::string& participant_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_identity();
  PROTOBUF_NODISCARD std::string* release_participant_identity();
  void set_allocated_participant_identity(std::string* participant_identity);
  private:
  const std::string& _internal_participant_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* _internal_mutable_participant_identity();
  public:

  // bool all_tracks = 2;
  void clear_all_tracks();
  bool all_tracks() const;
  void set_all_tracks(bool value);
  private:
  bool _internal_all_tracks() const;
  void _internal_set_all_tracks(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.TrackPermission)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> track_sids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_sid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_identity_;
  bool all_tracks_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class SubscriptionPermission final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.SubscriptionPermission) */ {
 public:
  inline SubscriptionPermission() : SubscriptionPermission(nullptr) {}
  ~SubscriptionPermission() override;
  explicit constexpr SubscriptionPermission(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscriptionPermission(const SubscriptionPermission& from);
  SubscriptionPermission(SubscriptionPermission&& from) noexcept
    : SubscriptionPermission() {
    *this = ::std::move(from);
  }

  inline SubscriptionPermission& operator=(const SubscriptionPermission& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscriptionPermission& operator=(SubscriptionPermission&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscriptionPermission& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscriptionPermission* internal_default_instance() {
    return reinterpret_cast<const SubscriptionPermission*>(
               &_SubscriptionPermission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(SubscriptionPermission& a, SubscriptionPermission& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscriptionPermission* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscriptionPermission* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscriptionPermission* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscriptionPermission>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscriptionPermission& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SubscriptionPermission& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscriptionPermission* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.SubscriptionPermission";
  }
  protected:
  explicit SubscriptionPermission(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrackPermissionsFieldNumber = 2,
    kAllParticipantsFieldNumber = 1,
  };
  // repeated .livekit.TrackPermission track_permissions = 2;
  int track_permissions_size() const;
  private:
  int _internal_track_permissions_size() const;
  public:
  void clear_track_permissions();
  ::livekit::TrackPermission* mutable_track_permissions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::TrackPermission >*
      mutable_track_permissions();
  private:
  const ::livekit::TrackPermission& _internal_track_permissions(int index) const;
  ::livekit::TrackPermission* _internal_add_track_permissions();
  public:
  const ::livekit::TrackPermission& track_permissions(int index) const;
  ::livekit::TrackPermission* add_track_permissions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::TrackPermission >&
      track_permissions() const;

  // bool all_participants = 1;
  void clear_all_participants();
  bool all_participants() const;
  void set_all_participants(bool value);
  private:
  bool _internal_all_participants() const;
  void _internal_set_all_participants(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.SubscriptionPermission)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::TrackPermission > track_permissions_;
  bool all_participants_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class SubscriptionPermissionUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.SubscriptionPermissionUpdate) */ {
 public:
  inline SubscriptionPermissionUpdate() : SubscriptionPermissionUpdate(nullptr) {}
  ~SubscriptionPermissionUpdate() override;
  explicit constexpr SubscriptionPermissionUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscriptionPermissionUpdate(const SubscriptionPermissionUpdate& from);
  SubscriptionPermissionUpdate(SubscriptionPermissionUpdate&& from) noexcept
    : SubscriptionPermissionUpdate() {
    *this = ::std::move(from);
  }

  inline SubscriptionPermissionUpdate& operator=(const SubscriptionPermissionUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscriptionPermissionUpdate& operator=(SubscriptionPermissionUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscriptionPermissionUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscriptionPermissionUpdate* internal_default_instance() {
    return reinterpret_cast<const SubscriptionPermissionUpdate*>(
               &_SubscriptionPermissionUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(SubscriptionPermissionUpdate& a, SubscriptionPermissionUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscriptionPermissionUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscriptionPermissionUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscriptionPermissionUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscriptionPermissionUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscriptionPermissionUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SubscriptionPermissionUpdate& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscriptionPermissionUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.SubscriptionPermissionUpdate";
  }
  protected:
  explicit SubscriptionPermissionUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantSidFieldNumber = 1,
    kTrackSidFieldNumber = 2,
    kAllowedFieldNumber = 3,
  };
  // string participant_sid = 1;
  void clear_participant_sid();
  const std::string& participant_sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_sid();
  PROTOBUF_NODISCARD std::string* release_participant_sid();
  void set_allocated_participant_sid(std::string* participant_sid);
  private:
  const std::string& _internal_participant_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_sid(const std::string& value);
  std::string* _internal_mutable_participant_sid();
  public:

  // string track_sid = 2;
  void clear_track_sid();
  const std::string& track_sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_track_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_track_sid();
  PROTOBUF_NODISCARD std::string* release_track_sid();
  void set_allocated_track_sid(std::string* track_sid);
  private:
  const std::string& _internal_track_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_track_sid(const std::string& value);
  std::string* _internal_mutable_track_sid();
  public:

  // bool allowed = 3;
  void clear_allowed();
  bool allowed() const;
  void set_allowed(bool value);
  private:
  bool _internal_allowed() const;
  void _internal_set_allowed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.SubscriptionPermissionUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_sid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr track_sid_;
  bool allowed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class SyncState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.SyncState) */ {
 public:
  inline SyncState() : SyncState(nullptr) {}
  ~SyncState() override;
  explicit constexpr SyncState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SyncState(const SyncState& from);
  SyncState(SyncState&& from) noexcept
    : SyncState() {
    *this = ::std::move(from);
  }

  inline SyncState& operator=(const SyncState& from) {
    CopyFrom(from);
    return *this;
  }
  inline SyncState& operator=(SyncState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SyncState& default_instance() {
    return *internal_default_instance();
  }
  static inline const SyncState* internal_default_instance() {
    return reinterpret_cast<const SyncState*>(
               &_SyncState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(SyncState& a, SyncState& b) {
    a.Swap(&b);
  }
  inline void Swap(SyncState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SyncState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SyncState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SyncState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SyncState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SyncState& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SyncState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.SyncState";
  }
  protected:
  explicit SyncState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublishTracksFieldNumber = 3,
    kDataChannelsFieldNumber = 4,
    kAnswerFieldNumber = 1,
    kSubscriptionFieldNumber = 2,
  };
  // repeated .livekit.TrackPublishedResponse publish_tracks = 3;
  int publish_tracks_size() const;
  private:
  int _internal_publish_tracks_size() const;
  public:
  void clear_publish_tracks();
  ::livekit::TrackPublishedResponse* mutable_publish_tracks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::TrackPublishedResponse >*
      mutable_publish_tracks();
  private:
  const ::livekit::TrackPublishedResponse& _internal_publish_tracks(int index) const;
  ::livekit::TrackPublishedResponse* _internal_add_publish_tracks();
  public:
  const ::livekit::TrackPublishedResponse& publish_tracks(int index) const;
  ::livekit::TrackPublishedResponse* add_publish_tracks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::TrackPublishedResponse >&
      publish_tracks() const;

  // repeated .livekit.DataChannelInfo data_channels = 4;
  int data_channels_size() const;
  private:
  int _internal_data_channels_size() const;
  public:
  void clear_data_channels();
  ::livekit::DataChannelInfo* mutable_data_channels(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::DataChannelInfo >*
      mutable_data_channels();
  private:
  const ::livekit::DataChannelInfo& _internal_data_channels(int index) const;
  ::livekit::DataChannelInfo* _internal_add_data_channels();
  public:
  const ::livekit::DataChannelInfo& data_channels(int index) const;
  ::livekit::DataChannelInfo* add_data_channels();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::DataChannelInfo >&
      data_channels() const;

  // .livekit.SessionDescription answer = 1;
  bool has_answer() const;
  private:
  bool _internal_has_answer() const;
  public:
  void clear_answer();
  const ::livekit::SessionDescription& answer() const;
  PROTOBUF_NODISCARD ::livekit::SessionDescription* release_answer();
  ::livekit::SessionDescription* mutable_answer();
  void set_allocated_answer(::livekit::SessionDescription* answer);
  private:
  const ::livekit::SessionDescription& _internal_answer() const;
  ::livekit::SessionDescription* _internal_mutable_answer();
  public:
  void unsafe_arena_set_allocated_answer(
      ::livekit::SessionDescription* answer);
  ::livekit::SessionDescription* unsafe_arena_release_answer();

  // .livekit.UpdateSubscription subscription = 2;
  bool has_subscription() const;
  private:
  bool _internal_has_subscription() const;
  public:
  void clear_subscription();
  const ::livekit::UpdateSubscription& subscription() const;
  PROTOBUF_NODISCARD ::livekit::UpdateSubscription* release_subscription();
  ::livekit::UpdateSubscription* mutable_subscription();
  void set_allocated_subscription(::livekit::UpdateSubscription* subscription);
  private:
  const ::livekit::UpdateSubscription& _internal_subscription() const;
  ::livekit::UpdateSubscription* _internal_mutable_subscription();
  public:
  void unsafe_arena_set_allocated_subscription(
      ::livekit::UpdateSubscription* subscription);
  ::livekit::UpdateSubscription* unsafe_arena_release_subscription();

  // @@protoc_insertion_point(class_scope:livekit.SyncState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::TrackPublishedResponse > publish_tracks_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::DataChannelInfo > data_channels_;
  ::livekit::SessionDescription* answer_;
  ::livekit::UpdateSubscription* subscription_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class DataChannelInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.DataChannelInfo) */ {
 public:
  inline DataChannelInfo() : DataChannelInfo(nullptr) {}
  ~DataChannelInfo() override;
  explicit constexpr DataChannelInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataChannelInfo(const DataChannelInfo& from);
  DataChannelInfo(DataChannelInfo&& from) noexcept
    : DataChannelInfo() {
    *this = ::std::move(from);
  }

  inline DataChannelInfo& operator=(const DataChannelInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataChannelInfo& operator=(DataChannelInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataChannelInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataChannelInfo* internal_default_instance() {
    return reinterpret_cast<const DataChannelInfo*>(
               &_DataChannelInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(DataChannelInfo& a, DataChannelInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DataChannelInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataChannelInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataChannelInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataChannelInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataChannelInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DataChannelInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataChannelInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.DataChannelInfo";
  }
  protected:
  explicit DataChannelInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLabelFieldNumber = 1,
    kIdFieldNumber = 2,
    kTargetFieldNumber = 3,
  };
  // string label = 1;
  void clear_label();
  const std::string& label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // uint32 id = 2;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // .livekit.SignalTarget target = 3;
  void clear_target();
  ::livekit::SignalTarget target() const;
  void set_target(::livekit::SignalTarget value);
  private:
  ::livekit::SignalTarget _internal_target() const;
  void _internal_set_target(::livekit::SignalTarget value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.DataChannelInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
  uint32_t id_;
  int target_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class SimulateScenario final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.SimulateScenario) */ {
 public:
  inline SimulateScenario() : SimulateScenario(nullptr) {}
  ~SimulateScenario() override;
  explicit constexpr SimulateScenario(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SimulateScenario(const SimulateScenario& from);
  SimulateScenario(SimulateScenario&& from) noexcept
    : SimulateScenario() {
    *this = ::std::move(from);
  }

  inline SimulateScenario& operator=(const SimulateScenario& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimulateScenario& operator=(SimulateScenario&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SimulateScenario& default_instance() {
    return *internal_default_instance();
  }
  enum ScenarioCase {
    kSpeakerUpdate = 1,
    kNodeFailure = 2,
    kMigration = 3,
    kServerLeave = 4,
    SCENARIO_NOT_SET = 0,
  };

  static inline const SimulateScenario* internal_default_instance() {
    return reinterpret_cast<const SimulateScenario*>(
               &_SimulateScenario_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(SimulateScenario& a, SimulateScenario& b) {
    a.Swap(&b);
  }
  inline void Swap(SimulateScenario* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimulateScenario* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SimulateScenario* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SimulateScenario>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SimulateScenario& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SimulateScenario& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimulateScenario* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.SimulateScenario";
  }
  protected:
  explicit SimulateScenario(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpeakerUpdateFieldNumber = 1,
    kNodeFailureFieldNumber = 2,
    kMigrationFieldNumber = 3,
    kServerLeaveFieldNumber = 4,
  };
  // int32 speaker_update = 1;
  bool has_speaker_update() const;
  private:
  bool _internal_has_speaker_update() const;
  public:
  void clear_speaker_update();
  int32_t speaker_update() const;
  void set_speaker_update(int32_t value);
  private:
  int32_t _internal_speaker_update() const;
  void _internal_set_speaker_update(int32_t value);
  public:

  // bool node_failure = 2;
  bool has_node_failure() const;
  private:
  bool _internal_has_node_failure() const;
  public:
  void clear_node_failure();
  bool node_failure() const;
  void set_node_failure(bool value);
  private:
  bool _internal_node_failure() const;
  void _internal_set_node_failure(bool value);
  public:

  // bool migration = 3;
  bool has_migration() const;
  private:
  bool _internal_has_migration() const;
  public:
  void clear_migration();
  bool migration() const;
  void set_migration(bool value);
  private:
  bool _internal_migration() const;
  void _internal_set_migration(bool value);
  public:

  // bool server_leave = 4;
  bool has_server_leave() const;
  private:
  bool _internal_has_server_leave() const;
  public:
  void clear_server_leave();
  bool server_leave() const;
  void set_server_leave(bool value);
  private:
  bool _internal_server_leave() const;
  void _internal_set_server_leave(bool value);
  public:

  void clear_scenario();
  ScenarioCase scenario_case() const;
  // @@protoc_insertion_point(class_scope:livekit.SimulateScenario)
 private:
  class _Internal;
  void set_has_speaker_update();
  void set_has_node_failure();
  void set_has_migration();
  void set_has_server_leave();

  inline bool has_scenario() const;
  inline void clear_has_scenario();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ScenarioUnion {
    constexpr ScenarioUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    int32_t speaker_update_;
    bool node_failure_;
    bool migration_;
    bool server_leave_;
  } scenario_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SignalRequest

// .livekit.SessionDescription offer = 1;
inline bool SignalRequest::_internal_has_offer() const {
  return message_case() == kOffer;
}
inline bool SignalRequest::has_offer() const {
  return _internal_has_offer();
}
inline void SignalRequest::set_has_offer() {
  _oneof_case_[0] = kOffer;
}
inline void SignalRequest::clear_offer() {
  if (_internal_has_offer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.offer_;
    }
    clear_has_message();
  }
}
inline ::livekit::SessionDescription* SignalRequest::release_offer() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.offer)
  if (_internal_has_offer()) {
    clear_has_message();
      ::livekit::SessionDescription* temp = message_.offer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.offer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SessionDescription& SignalRequest::_internal_offer() const {
  return _internal_has_offer()
      ? *message_.offer_
      : reinterpret_cast< ::livekit::SessionDescription&>(::livekit::_SessionDescription_default_instance_);
}
inline const ::livekit::SessionDescription& SignalRequest::offer() const {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.offer)
  return _internal_offer();
}
inline ::livekit::SessionDescription* SignalRequest::unsafe_arena_release_offer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.offer)
  if (_internal_has_offer()) {
    clear_has_message();
    ::livekit::SessionDescription* temp = message_.offer_;
    message_.offer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_offer(::livekit::SessionDescription* offer) {
  clear_message();
  if (offer) {
    set_has_offer();
    message_.offer_ = offer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.offer)
}
inline ::livekit::SessionDescription* SignalRequest::_internal_mutable_offer() {
  if (!_internal_has_offer()) {
    clear_message();
    set_has_offer();
    message_.offer_ = CreateMaybeMessage< ::livekit::SessionDescription >(GetArenaForAllocation());
  }
  return message_.offer_;
}
inline ::livekit::SessionDescription* SignalRequest::mutable_offer() {
  ::livekit::SessionDescription* _msg = _internal_mutable_offer();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.offer)
  return _msg;
}

// .livekit.SessionDescription answer = 2;
inline bool SignalRequest::_internal_has_answer() const {
  return message_case() == kAnswer;
}
inline bool SignalRequest::has_answer() const {
  return _internal_has_answer();
}
inline void SignalRequest::set_has_answer() {
  _oneof_case_[0] = kAnswer;
}
inline void SignalRequest::clear_answer() {
  if (_internal_has_answer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.answer_;
    }
    clear_has_message();
  }
}
inline ::livekit::SessionDescription* SignalRequest::release_answer() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.answer)
  if (_internal_has_answer()) {
    clear_has_message();
      ::livekit::SessionDescription* temp = message_.answer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.answer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SessionDescription& SignalRequest::_internal_answer() const {
  return _internal_has_answer()
      ? *message_.answer_
      : reinterpret_cast< ::livekit::SessionDescription&>(::livekit::_SessionDescription_default_instance_);
}
inline const ::livekit::SessionDescription& SignalRequest::answer() const {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.answer)
  return _internal_answer();
}
inline ::livekit::SessionDescription* SignalRequest::unsafe_arena_release_answer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.answer)
  if (_internal_has_answer()) {
    clear_has_message();
    ::livekit::SessionDescription* temp = message_.answer_;
    message_.answer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_answer(::livekit::SessionDescription* answer) {
  clear_message();
  if (answer) {
    set_has_answer();
    message_.answer_ = answer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.answer)
}
inline ::livekit::SessionDescription* SignalRequest::_internal_mutable_answer() {
  if (!_internal_has_answer()) {
    clear_message();
    set_has_answer();
    message_.answer_ = CreateMaybeMessage< ::livekit::SessionDescription >(GetArenaForAllocation());
  }
  return message_.answer_;
}
inline ::livekit::SessionDescription* SignalRequest::mutable_answer() {
  ::livekit::SessionDescription* _msg = _internal_mutable_answer();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.answer)
  return _msg;
}

// .livekit.TrickleRequest trickle = 3;
inline bool SignalRequest::_internal_has_trickle() const {
  return message_case() == kTrickle;
}
inline bool SignalRequest::has_trickle() const {
  return _internal_has_trickle();
}
inline void SignalRequest::set_has_trickle() {
  _oneof_case_[0] = kTrickle;
}
inline void SignalRequest::clear_trickle() {
  if (_internal_has_trickle()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.trickle_;
    }
    clear_has_message();
  }
}
inline ::livekit::TrickleRequest* SignalRequest::release_trickle() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.trickle)
  if (_internal_has_trickle()) {
    clear_has_message();
      ::livekit::TrickleRequest* temp = message_.trickle_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.trickle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::TrickleRequest& SignalRequest::_internal_trickle() const {
  return _internal_has_trickle()
      ? *message_.trickle_
      : reinterpret_cast< ::livekit::TrickleRequest&>(::livekit::_TrickleRequest_default_instance_);
}
inline const ::livekit::TrickleRequest& SignalRequest::trickle() const {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.trickle)
  return _internal_trickle();
}
inline ::livekit::TrickleRequest* SignalRequest::unsafe_arena_release_trickle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.trickle)
  if (_internal_has_trickle()) {
    clear_has_message();
    ::livekit::TrickleRequest* temp = message_.trickle_;
    message_.trickle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_trickle(::livekit::TrickleRequest* trickle) {
  clear_message();
  if (trickle) {
    set_has_trickle();
    message_.trickle_ = trickle;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.trickle)
}
inline ::livekit::TrickleRequest* SignalRequest::_internal_mutable_trickle() {
  if (!_internal_has_trickle()) {
    clear_message();
    set_has_trickle();
    message_.trickle_ = CreateMaybeMessage< ::livekit::TrickleRequest >(GetArenaForAllocation());
  }
  return message_.trickle_;
}
inline ::livekit::TrickleRequest* SignalRequest::mutable_trickle() {
  ::livekit::TrickleRequest* _msg = _internal_mutable_trickle();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.trickle)
  return _msg;
}

// .livekit.AddTrackRequest add_track = 4;
inline bool SignalRequest::_internal_has_add_track() const {
  return message_case() == kAddTrack;
}
inline bool SignalRequest::has_add_track() const {
  return _internal_has_add_track();
}
inline void SignalRequest::set_has_add_track() {
  _oneof_case_[0] = kAddTrack;
}
inline void SignalRequest::clear_add_track() {
  if (_internal_has_add_track()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.add_track_;
    }
    clear_has_message();
  }
}
inline ::livekit::AddTrackRequest* SignalRequest::release_add_track() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.add_track)
  if (_internal_has_add_track()) {
    clear_has_message();
      ::livekit::AddTrackRequest* temp = message_.add_track_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.add_track_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::AddTrackRequest& SignalRequest::_internal_add_track() const {
  return _internal_has_add_track()
      ? *message_.add_track_
      : reinterpret_cast< ::livekit::AddTrackRequest&>(::livekit::_AddTrackRequest_default_instance_);
}
inline const ::livekit::AddTrackRequest& SignalRequest::add_track() const {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.add_track)
  return _internal_add_track();
}
inline ::livekit::AddTrackRequest* SignalRequest::unsafe_arena_release_add_track() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.add_track)
  if (_internal_has_add_track()) {
    clear_has_message();
    ::livekit::AddTrackRequest* temp = message_.add_track_;
    message_.add_track_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_add_track(::livekit::AddTrackRequest* add_track) {
  clear_message();
  if (add_track) {
    set_has_add_track();
    message_.add_track_ = add_track;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.add_track)
}
inline ::livekit::AddTrackRequest* SignalRequest::_internal_mutable_add_track() {
  if (!_internal_has_add_track()) {
    clear_message();
    set_has_add_track();
    message_.add_track_ = CreateMaybeMessage< ::livekit::AddTrackRequest >(GetArenaForAllocation());
  }
  return message_.add_track_;
}
inline ::livekit::AddTrackRequest* SignalRequest::mutable_add_track() {
  ::livekit::AddTrackRequest* _msg = _internal_mutable_add_track();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.add_track)
  return _msg;
}

// .livekit.MuteTrackRequest mute = 5;
inline bool SignalRequest::_internal_has_mute() const {
  return message_case() == kMute;
}
inline bool SignalRequest::has_mute() const {
  return _internal_has_mute();
}
inline void SignalRequest::set_has_mute() {
  _oneof_case_[0] = kMute;
}
inline void SignalRequest::clear_mute() {
  if (_internal_has_mute()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.mute_;
    }
    clear_has_message();
  }
}
inline ::livekit::MuteTrackRequest* SignalRequest::release_mute() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.mute)
  if (_internal_has_mute()) {
    clear_has_message();
      ::livekit::MuteTrackRequest* temp = message_.mute_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.mute_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::MuteTrackRequest& SignalRequest::_internal_mute() const {
  return _internal_has_mute()
      ? *message_.mute_
      : reinterpret_cast< ::livekit::MuteTrackRequest&>(::livekit::_MuteTrackRequest_default_instance_);
}
inline const ::livekit::MuteTrackRequest& SignalRequest::mute() const {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.mute)
  return _internal_mute();
}
inline ::livekit::MuteTrackRequest* SignalRequest::unsafe_arena_release_mute() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.mute)
  if (_internal_has_mute()) {
    clear_has_message();
    ::livekit::MuteTrackRequest* temp = message_.mute_;
    message_.mute_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_mute(::livekit::MuteTrackRequest* mute) {
  clear_message();
  if (mute) {
    set_has_mute();
    message_.mute_ = mute;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.mute)
}
inline ::livekit::MuteTrackRequest* SignalRequest::_internal_mutable_mute() {
  if (!_internal_has_mute()) {
    clear_message();
    set_has_mute();
    message_.mute_ = CreateMaybeMessage< ::livekit::MuteTrackRequest >(GetArenaForAllocation());
  }
  return message_.mute_;
}
inline ::livekit::MuteTrackRequest* SignalRequest::mutable_mute() {
  ::livekit::MuteTrackRequest* _msg = _internal_mutable_mute();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.mute)
  return _msg;
}

// .livekit.UpdateSubscription subscription = 6;
inline bool SignalRequest::_internal_has_subscription() const {
  return message_case() == kSubscription;
}
inline bool SignalRequest::has_subscription() const {
  return _internal_has_subscription();
}
inline void SignalRequest::set_has_subscription() {
  _oneof_case_[0] = kSubscription;
}
inline void SignalRequest::clear_subscription() {
  if (_internal_has_subscription()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.subscription_;
    }
    clear_has_message();
  }
}
inline ::livekit::UpdateSubscription* SignalRequest::release_subscription() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.subscription)
  if (_internal_has_subscription()) {
    clear_has_message();
      ::livekit::UpdateSubscription* temp = message_.subscription_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.subscription_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::UpdateSubscription& SignalRequest::_internal_subscription() const {
  return _internal_has_subscription()
      ? *message_.subscription_
      : reinterpret_cast< ::livekit::UpdateSubscription&>(::livekit::_UpdateSubscription_default_instance_);
}
inline const ::livekit::UpdateSubscription& SignalRequest::subscription() const {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.subscription)
  return _internal_subscription();
}
inline ::livekit::UpdateSubscription* SignalRequest::unsafe_arena_release_subscription() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.subscription)
  if (_internal_has_subscription()) {
    clear_has_message();
    ::livekit::UpdateSubscription* temp = message_.subscription_;
    message_.subscription_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_subscription(::livekit::UpdateSubscription* subscription) {
  clear_message();
  if (subscription) {
    set_has_subscription();
    message_.subscription_ = subscription;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.subscription)
}
inline ::livekit::UpdateSubscription* SignalRequest::_internal_mutable_subscription() {
  if (!_internal_has_subscription()) {
    clear_message();
    set_has_subscription();
    message_.subscription_ = CreateMaybeMessage< ::livekit::UpdateSubscription >(GetArenaForAllocation());
  }
  return message_.subscription_;
}
inline ::livekit::UpdateSubscription* SignalRequest::mutable_subscription() {
  ::livekit::UpdateSubscription* _msg = _internal_mutable_subscription();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.subscription)
  return _msg;
}

// .livekit.UpdateTrackSettings track_setting = 7;
inline bool SignalRequest::_internal_has_track_setting() const {
  return message_case() == kTrackSetting;
}
inline bool SignalRequest::has_track_setting() const {
  return _internal_has_track_setting();
}
inline void SignalRequest::set_has_track_setting() {
  _oneof_case_[0] = kTrackSetting;
}
inline void SignalRequest::clear_track_setting() {
  if (_internal_has_track_setting()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.track_setting_;
    }
    clear_has_message();
  }
}
inline ::livekit::UpdateTrackSettings* SignalRequest::release_track_setting() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.track_setting)
  if (_internal_has_track_setting()) {
    clear_has_message();
      ::livekit::UpdateTrackSettings* temp = message_.track_setting_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.track_setting_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::UpdateTrackSettings& SignalRequest::_internal_track_setting() const {
  return _internal_has_track_setting()
      ? *message_.track_setting_
      : reinterpret_cast< ::livekit::UpdateTrackSettings&>(::livekit::_UpdateTrackSettings_default_instance_);
}
inline const ::livekit::UpdateTrackSettings& SignalRequest::track_setting() const {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.track_setting)
  return _internal_track_setting();
}
inline ::livekit::UpdateTrackSettings* SignalRequest::unsafe_arena_release_track_setting() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.track_setting)
  if (_internal_has_track_setting()) {
    clear_has_message();
    ::livekit::UpdateTrackSettings* temp = message_.track_setting_;
    message_.track_setting_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_track_setting(::livekit::UpdateTrackSettings* track_setting) {
  clear_message();
  if (track_setting) {
    set_has_track_setting();
    message_.track_setting_ = track_setting;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.track_setting)
}
inline ::livekit::UpdateTrackSettings* SignalRequest::_internal_mutable_track_setting() {
  if (!_internal_has_track_setting()) {
    clear_message();
    set_has_track_setting();
    message_.track_setting_ = CreateMaybeMessage< ::livekit::UpdateTrackSettings >(GetArenaForAllocation());
  }
  return message_.track_setting_;
}
inline ::livekit::UpdateTrackSettings* SignalRequest::mutable_track_setting() {
  ::livekit::UpdateTrackSettings* _msg = _internal_mutable_track_setting();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.track_setting)
  return _msg;
}

// .livekit.LeaveRequest leave = 8;
inline bool SignalRequest::_internal_has_leave() const {
  return message_case() == kLeave;
}
inline bool SignalRequest::has_leave() const {
  return _internal_has_leave();
}
inline void SignalRequest::set_has_leave() {
  _oneof_case_[0] = kLeave;
}
inline void SignalRequest::clear_leave() {
  if (_internal_has_leave()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.leave_;
    }
    clear_has_message();
  }
}
inline ::livekit::LeaveRequest* SignalRequest::release_leave() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.leave)
  if (_internal_has_leave()) {
    clear_has_message();
      ::livekit::LeaveRequest* temp = message_.leave_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.leave_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::LeaveRequest& SignalRequest::_internal_leave() const {
  return _internal_has_leave()
      ? *message_.leave_
      : reinterpret_cast< ::livekit::LeaveRequest&>(::livekit::_LeaveRequest_default_instance_);
}
inline const ::livekit::LeaveRequest& SignalRequest::leave() const {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.leave)
  return _internal_leave();
}
inline ::livekit::LeaveRequest* SignalRequest::unsafe_arena_release_leave() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.leave)
  if (_internal_has_leave()) {
    clear_has_message();
    ::livekit::LeaveRequest* temp = message_.leave_;
    message_.leave_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_leave(::livekit::LeaveRequest* leave) {
  clear_message();
  if (leave) {
    set_has_leave();
    message_.leave_ = leave;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.leave)
}
inline ::livekit::LeaveRequest* SignalRequest::_internal_mutable_leave() {
  if (!_internal_has_leave()) {
    clear_message();
    set_has_leave();
    message_.leave_ = CreateMaybeMessage< ::livekit::LeaveRequest >(GetArenaForAllocation());
  }
  return message_.leave_;
}
inline ::livekit::LeaveRequest* SignalRequest::mutable_leave() {
  ::livekit::LeaveRequest* _msg = _internal_mutable_leave();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.leave)
  return _msg;
}

// .livekit.UpdateVideoLayers update_layers = 10;
inline bool SignalRequest::_internal_has_update_layers() const {
  return message_case() == kUpdateLayers;
}
inline bool SignalRequest::has_update_layers() const {
  return _internal_has_update_layers();
}
inline void SignalRequest::set_has_update_layers() {
  _oneof_case_[0] = kUpdateLayers;
}
inline void SignalRequest::clear_update_layers() {
  if (_internal_has_update_layers()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.update_layers_;
    }
    clear_has_message();
  }
}
inline ::livekit::UpdateVideoLayers* SignalRequest::release_update_layers() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.update_layers)
  if (_internal_has_update_layers()) {
    clear_has_message();
      ::livekit::UpdateVideoLayers* temp = message_.update_layers_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.update_layers_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::UpdateVideoLayers& SignalRequest::_internal_update_layers() const {
  return _internal_has_update_layers()
      ? *message_.update_layers_
      : reinterpret_cast< ::livekit::UpdateVideoLayers&>(::livekit::_UpdateVideoLayers_default_instance_);
}
inline const ::livekit::UpdateVideoLayers& SignalRequest::update_layers() const {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.update_layers)
  return _internal_update_layers();
}
inline ::livekit::UpdateVideoLayers* SignalRequest::unsafe_arena_release_update_layers() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.update_layers)
  if (_internal_has_update_layers()) {
    clear_has_message();
    ::livekit::UpdateVideoLayers* temp = message_.update_layers_;
    message_.update_layers_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_update_layers(::livekit::UpdateVideoLayers* update_layers) {
  clear_message();
  if (update_layers) {
    set_has_update_layers();
    message_.update_layers_ = update_layers;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.update_layers)
}
inline ::livekit::UpdateVideoLayers* SignalRequest::_internal_mutable_update_layers() {
  if (!_internal_has_update_layers()) {
    clear_message();
    set_has_update_layers();
    message_.update_layers_ = CreateMaybeMessage< ::livekit::UpdateVideoLayers >(GetArenaForAllocation());
  }
  return message_.update_layers_;
}
inline ::livekit::UpdateVideoLayers* SignalRequest::mutable_update_layers() {
  ::livekit::UpdateVideoLayers* _msg = _internal_mutable_update_layers();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.update_layers)
  return _msg;
}

// .livekit.SubscriptionPermission subscription_permission = 11;
inline bool SignalRequest::_internal_has_subscription_permission() const {
  return message_case() == kSubscriptionPermission;
}
inline bool SignalRequest::has_subscription_permission() const {
  return _internal_has_subscription_permission();
}
inline void SignalRequest::set_has_subscription_permission() {
  _oneof_case_[0] = kSubscriptionPermission;
}
inline void SignalRequest::clear_subscription_permission() {
  if (_internal_has_subscription_permission()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.subscription_permission_;
    }
    clear_has_message();
  }
}
inline ::livekit::SubscriptionPermission* SignalRequest::release_subscription_permission() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.subscription_permission)
  if (_internal_has_subscription_permission()) {
    clear_has_message();
      ::livekit::SubscriptionPermission* temp = message_.subscription_permission_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.subscription_permission_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SubscriptionPermission& SignalRequest::_internal_subscription_permission() const {
  return _internal_has_subscription_permission()
      ? *message_.subscription_permission_
      : reinterpret_cast< ::livekit::SubscriptionPermission&>(::livekit::_SubscriptionPermission_default_instance_);
}
inline const ::livekit::SubscriptionPermission& SignalRequest::subscription_permission() const {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.subscription_permission)
  return _internal_subscription_permission();
}
inline ::livekit::SubscriptionPermission* SignalRequest::unsafe_arena_release_subscription_permission() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.subscription_permission)
  if (_internal_has_subscription_permission()) {
    clear_has_message();
    ::livekit::SubscriptionPermission* temp = message_.subscription_permission_;
    message_.subscription_permission_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_subscription_permission(::livekit::SubscriptionPermission* subscription_permission) {
  clear_message();
  if (subscription_permission) {
    set_has_subscription_permission();
    message_.subscription_permission_ = subscription_permission;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.subscription_permission)
}
inline ::livekit::SubscriptionPermission* SignalRequest::_internal_mutable_subscription_permission() {
  if (!_internal_has_subscription_permission()) {
    clear_message();
    set_has_subscription_permission();
    message_.subscription_permission_ = CreateMaybeMessage< ::livekit::SubscriptionPermission >(GetArenaForAllocation());
  }
  return message_.subscription_permission_;
}
inline ::livekit::SubscriptionPermission* SignalRequest::mutable_subscription_permission() {
  ::livekit::SubscriptionPermission* _msg = _internal_mutable_subscription_permission();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.subscription_permission)
  return _msg;
}

// .livekit.SyncState sync_state = 12;
inline bool SignalRequest::_internal_has_sync_state() const {
  return message_case() == kSyncState;
}
inline bool SignalRequest::has_sync_state() const {
  return _internal_has_sync_state();
}
inline void SignalRequest::set_has_sync_state() {
  _oneof_case_[0] = kSyncState;
}
inline void SignalRequest::clear_sync_state() {
  if (_internal_has_sync_state()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.sync_state_;
    }
    clear_has_message();
  }
}
inline ::livekit::SyncState* SignalRequest::release_sync_state() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.sync_state)
  if (_internal_has_sync_state()) {
    clear_has_message();
      ::livekit::SyncState* temp = message_.sync_state_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.sync_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SyncState& SignalRequest::_internal_sync_state() const {
  return _internal_has_sync_state()
      ? *message_.sync_state_
      : reinterpret_cast< ::livekit::SyncState&>(::livekit::_SyncState_default_instance_);
}
inline const ::livekit::SyncState& SignalRequest::sync_state() const {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.sync_state)
  return _internal_sync_state();
}
inline ::livekit::SyncState* SignalRequest::unsafe_arena_release_sync_state() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.sync_state)
  if (_internal_has_sync_state()) {
    clear_has_message();
    ::livekit::SyncState* temp = message_.sync_state_;
    message_.sync_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_sync_state(::livekit::SyncState* sync_state) {
  clear_message();
  if (sync_state) {
    set_has_sync_state();
    message_.sync_state_ = sync_state;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.sync_state)
}
inline ::livekit::SyncState* SignalRequest::_internal_mutable_sync_state() {
  if (!_internal_has_sync_state()) {
    clear_message();
    set_has_sync_state();
    message_.sync_state_ = CreateMaybeMessage< ::livekit::SyncState >(GetArenaForAllocation());
  }
  return message_.sync_state_;
}
inline ::livekit::SyncState* SignalRequest::mutable_sync_state() {
  ::livekit::SyncState* _msg = _internal_mutable_sync_state();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.sync_state)
  return _msg;
}

// .livekit.SimulateScenario simulate = 13;
inline bool SignalRequest::_internal_has_simulate() const {
  return message_case() == kSimulate;
}
inline bool SignalRequest::has_simulate() const {
  return _internal_has_simulate();
}
inline void SignalRequest::set_has_simulate() {
  _oneof_case_[0] = kSimulate;
}
inline void SignalRequest::clear_simulate() {
  if (_internal_has_simulate()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.simulate_;
    }
    clear_has_message();
  }
}
inline ::livekit::SimulateScenario* SignalRequest::release_simulate() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.simulate)
  if (_internal_has_simulate()) {
    clear_has_message();
      ::livekit::SimulateScenario* temp = message_.simulate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.simulate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SimulateScenario& SignalRequest::_internal_simulate() const {
  return _internal_has_simulate()
      ? *message_.simulate_
      : reinterpret_cast< ::livekit::SimulateScenario&>(::livekit::_SimulateScenario_default_instance_);
}
inline const ::livekit::SimulateScenario& SignalRequest::simulate() const {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.simulate)
  return _internal_simulate();
}
inline ::livekit::SimulateScenario* SignalRequest::unsafe_arena_release_simulate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.simulate)
  if (_internal_has_simulate()) {
    clear_has_message();
    ::livekit::SimulateScenario* temp = message_.simulate_;
    message_.simulate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_simulate(::livekit::SimulateScenario* simulate) {
  clear_message();
  if (simulate) {
    set_has_simulate();
    message_.simulate_ = simulate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.simulate)
}
inline ::livekit::SimulateScenario* SignalRequest::_internal_mutable_simulate() {
  if (!_internal_has_simulate()) {
    clear_message();
    set_has_simulate();
    message_.simulate_ = CreateMaybeMessage< ::livekit::SimulateScenario >(GetArenaForAllocation());
  }
  return message_.simulate_;
}
inline ::livekit::SimulateScenario* SignalRequest::mutable_simulate() {
  ::livekit::SimulateScenario* _msg = _internal_mutable_simulate();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.simulate)
  return _msg;
}

inline bool SignalRequest::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void SignalRequest::clear_has_message() {
  _oneof_case_[0] = MESSAGE_NOT_SET;
}
inline SignalRequest::MessageCase SignalRequest::message_case() const {
  return SignalRequest::MessageCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SignalResponse

// .livekit.JoinResponse join = 1;
inline bool SignalResponse::_internal_has_join() const {
  return message_case() == kJoin;
}
inline bool SignalResponse::has_join() const {
  return _internal_has_join();
}
inline void SignalResponse::set_has_join() {
  _oneof_case_[0] = kJoin;
}
inline void SignalResponse::clear_join() {
  if (_internal_has_join()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.join_;
    }
    clear_has_message();
  }
}
inline ::livekit::JoinResponse* SignalResponse::release_join() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.join)
  if (_internal_has_join()) {
    clear_has_message();
      ::livekit::JoinResponse* temp = message_.join_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::JoinResponse& SignalResponse::_internal_join() const {
  return _internal_has_join()
      ? *message_.join_
      : reinterpret_cast< ::livekit::JoinResponse&>(::livekit::_JoinResponse_default_instance_);
}
inline const ::livekit::JoinResponse& SignalResponse::join() const {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.join)
  return _internal_join();
}
inline ::livekit::JoinResponse* SignalResponse::unsafe_arena_release_join() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.join)
  if (_internal_has_join()) {
    clear_has_message();
    ::livekit::JoinResponse* temp = message_.join_;
    message_.join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_join(::livekit::JoinResponse* join) {
  clear_message();
  if (join) {
    set_has_join();
    message_.join_ = join;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.join)
}
inline ::livekit::JoinResponse* SignalResponse::_internal_mutable_join() {
  if (!_internal_has_join()) {
    clear_message();
    set_has_join();
    message_.join_ = CreateMaybeMessage< ::livekit::JoinResponse >(GetArenaForAllocation());
  }
  return message_.join_;
}
inline ::livekit::JoinResponse* SignalResponse::mutable_join() {
  ::livekit::JoinResponse* _msg = _internal_mutable_join();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.join)
  return _msg;
}

// .livekit.SessionDescription answer = 2;
inline bool SignalResponse::_internal_has_answer() const {
  return message_case() == kAnswer;
}
inline bool SignalResponse::has_answer() const {
  return _internal_has_answer();
}
inline void SignalResponse::set_has_answer() {
  _oneof_case_[0] = kAnswer;
}
inline void SignalResponse::clear_answer() {
  if (_internal_has_answer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.answer_;
    }
    clear_has_message();
  }
}
inline ::livekit::SessionDescription* SignalResponse::release_answer() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.answer)
  if (_internal_has_answer()) {
    clear_has_message();
      ::livekit::SessionDescription* temp = message_.answer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.answer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SessionDescription& SignalResponse::_internal_answer() const {
  return _internal_has_answer()
      ? *message_.answer_
      : reinterpret_cast< ::livekit::SessionDescription&>(::livekit::_SessionDescription_default_instance_);
}
inline const ::livekit::SessionDescription& SignalResponse::answer() const {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.answer)
  return _internal_answer();
}
inline ::livekit::SessionDescription* SignalResponse::unsafe_arena_release_answer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.answer)
  if (_internal_has_answer()) {
    clear_has_message();
    ::livekit::SessionDescription* temp = message_.answer_;
    message_.answer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_answer(::livekit::SessionDescription* answer) {
  clear_message();
  if (answer) {
    set_has_answer();
    message_.answer_ = answer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.answer)
}
inline ::livekit::SessionDescription* SignalResponse::_internal_mutable_answer() {
  if (!_internal_has_answer()) {
    clear_message();
    set_has_answer();
    message_.answer_ = CreateMaybeMessage< ::livekit::SessionDescription >(GetArenaForAllocation());
  }
  return message_.answer_;
}
inline ::livekit::SessionDescription* SignalResponse::mutable_answer() {
  ::livekit::SessionDescription* _msg = _internal_mutable_answer();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.answer)
  return _msg;
}

// .livekit.SessionDescription offer = 3;
inline bool SignalResponse::_internal_has_offer() const {
  return message_case() == kOffer;
}
inline bool SignalResponse::has_offer() const {
  return _internal_has_offer();
}
inline void SignalResponse::set_has_offer() {
  _oneof_case_[0] = kOffer;
}
inline void SignalResponse::clear_offer() {
  if (_internal_has_offer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.offer_;
    }
    clear_has_message();
  }
}
inline ::livekit::SessionDescription* SignalResponse::release_offer() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.offer)
  if (_internal_has_offer()) {
    clear_has_message();
      ::livekit::SessionDescription* temp = message_.offer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.offer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SessionDescription& SignalResponse::_internal_offer() const {
  return _internal_has_offer()
      ? *message_.offer_
      : reinterpret_cast< ::livekit::SessionDescription&>(::livekit::_SessionDescription_default_instance_);
}
inline const ::livekit::SessionDescription& SignalResponse::offer() const {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.offer)
  return _internal_offer();
}
inline ::livekit::SessionDescription* SignalResponse::unsafe_arena_release_offer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.offer)
  if (_internal_has_offer()) {
    clear_has_message();
    ::livekit::SessionDescription* temp = message_.offer_;
    message_.offer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_offer(::livekit::SessionDescription* offer) {
  clear_message();
  if (offer) {
    set_has_offer();
    message_.offer_ = offer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.offer)
}
inline ::livekit::SessionDescription* SignalResponse::_internal_mutable_offer() {
  if (!_internal_has_offer()) {
    clear_message();
    set_has_offer();
    message_.offer_ = CreateMaybeMessage< ::livekit::SessionDescription >(GetArenaForAllocation());
  }
  return message_.offer_;
}
inline ::livekit::SessionDescription* SignalResponse::mutable_offer() {
  ::livekit::SessionDescription* _msg = _internal_mutable_offer();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.offer)
  return _msg;
}

// .livekit.TrickleRequest trickle = 4;
inline bool SignalResponse::_internal_has_trickle() const {
  return message_case() == kTrickle;
}
inline bool SignalResponse::has_trickle() const {
  return _internal_has_trickle();
}
inline void SignalResponse::set_has_trickle() {
  _oneof_case_[0] = kTrickle;
}
inline void SignalResponse::clear_trickle() {
  if (_internal_has_trickle()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.trickle_;
    }
    clear_has_message();
  }
}
inline ::livekit::TrickleRequest* SignalResponse::release_trickle() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.trickle)
  if (_internal_has_trickle()) {
    clear_has_message();
      ::livekit::TrickleRequest* temp = message_.trickle_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.trickle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::TrickleRequest& SignalResponse::_internal_trickle() const {
  return _internal_has_trickle()
      ? *message_.trickle_
      : reinterpret_cast< ::livekit::TrickleRequest&>(::livekit::_TrickleRequest_default_instance_);
}
inline const ::livekit::TrickleRequest& SignalResponse::trickle() const {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.trickle)
  return _internal_trickle();
}
inline ::livekit::TrickleRequest* SignalResponse::unsafe_arena_release_trickle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.trickle)
  if (_internal_has_trickle()) {
    clear_has_message();
    ::livekit::TrickleRequest* temp = message_.trickle_;
    message_.trickle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_trickle(::livekit::TrickleRequest* trickle) {
  clear_message();
  if (trickle) {
    set_has_trickle();
    message_.trickle_ = trickle;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.trickle)
}
inline ::livekit::TrickleRequest* SignalResponse::_internal_mutable_trickle() {
  if (!_internal_has_trickle()) {
    clear_message();
    set_has_trickle();
    message_.trickle_ = CreateMaybeMessage< ::livekit::TrickleRequest >(GetArenaForAllocation());
  }
  return message_.trickle_;
}
inline ::livekit::TrickleRequest* SignalResponse::mutable_trickle() {
  ::livekit::TrickleRequest* _msg = _internal_mutable_trickle();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.trickle)
  return _msg;
}

// .livekit.ParticipantUpdate update = 5;
inline bool SignalResponse::_internal_has_update() const {
  return message_case() == kUpdate;
}
inline bool SignalResponse::has_update() const {
  return _internal_has_update();
}
inline void SignalResponse::set_has_update() {
  _oneof_case_[0] = kUpdate;
}
inline void SignalResponse::clear_update() {
  if (_internal_has_update()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.update_;
    }
    clear_has_message();
  }
}
inline ::livekit::ParticipantUpdate* SignalResponse::release_update() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.update)
  if (_internal_has_update()) {
    clear_has_message();
      ::livekit::ParticipantUpdate* temp = message_.update_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::ParticipantUpdate& SignalResponse::_internal_update() const {
  return _internal_has_update()
      ? *message_.update_
      : reinterpret_cast< ::livekit::ParticipantUpdate&>(::livekit::_ParticipantUpdate_default_instance_);
}
inline const ::livekit::ParticipantUpdate& SignalResponse::update() const {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.update)
  return _internal_update();
}
inline ::livekit::ParticipantUpdate* SignalResponse::unsafe_arena_release_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.update)
  if (_internal_has_update()) {
    clear_has_message();
    ::livekit::ParticipantUpdate* temp = message_.update_;
    message_.update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_update(::livekit::ParticipantUpdate* update) {
  clear_message();
  if (update) {
    set_has_update();
    message_.update_ = update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.update)
}
inline ::livekit::ParticipantUpdate* SignalResponse::_internal_mutable_update() {
  if (!_internal_has_update()) {
    clear_message();
    set_has_update();
    message_.update_ = CreateMaybeMessage< ::livekit::ParticipantUpdate >(GetArenaForAllocation());
  }
  return message_.update_;
}
inline ::livekit::ParticipantUpdate* SignalResponse::mutable_update() {
  ::livekit::ParticipantUpdate* _msg = _internal_mutable_update();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.update)
  return _msg;
}

// .livekit.TrackPublishedResponse track_published = 6;
inline bool SignalResponse::_internal_has_track_published() const {
  return message_case() == kTrackPublished;
}
inline bool SignalResponse::has_track_published() const {
  return _internal_has_track_published();
}
inline void SignalResponse::set_has_track_published() {
  _oneof_case_[0] = kTrackPublished;
}
inline void SignalResponse::clear_track_published() {
  if (_internal_has_track_published()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.track_published_;
    }
    clear_has_message();
  }
}
inline ::livekit::TrackPublishedResponse* SignalResponse::release_track_published() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.track_published)
  if (_internal_has_track_published()) {
    clear_has_message();
      ::livekit::TrackPublishedResponse* temp = message_.track_published_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.track_published_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::TrackPublishedResponse& SignalResponse::_internal_track_published() const {
  return _internal_has_track_published()
      ? *message_.track_published_
      : reinterpret_cast< ::livekit::TrackPublishedResponse&>(::livekit::_TrackPublishedResponse_default_instance_);
}
inline const ::livekit::TrackPublishedResponse& SignalResponse::track_published() const {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.track_published)
  return _internal_track_published();
}
inline ::livekit::TrackPublishedResponse* SignalResponse::unsafe_arena_release_track_published() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.track_published)
  if (_internal_has_track_published()) {
    clear_has_message();
    ::livekit::TrackPublishedResponse* temp = message_.track_published_;
    message_.track_published_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_track_published(::livekit::TrackPublishedResponse* track_published) {
  clear_message();
  if (track_published) {
    set_has_track_published();
    message_.track_published_ = track_published;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.track_published)
}
inline ::livekit::TrackPublishedResponse* SignalResponse::_internal_mutable_track_published() {
  if (!_internal_has_track_published()) {
    clear_message();
    set_has_track_published();
    message_.track_published_ = CreateMaybeMessage< ::livekit::TrackPublishedResponse >(GetArenaForAllocation());
  }
  return message_.track_published_;
}
inline ::livekit::TrackPublishedResponse* SignalResponse::mutable_track_published() {
  ::livekit::TrackPublishedResponse* _msg = _internal_mutable_track_published();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.track_published)
  return _msg;
}

// .livekit.LeaveRequest leave = 8;
inline bool SignalResponse::_internal_has_leave() const {
  return message_case() == kLeave;
}
inline bool SignalResponse::has_leave() const {
  return _internal_has_leave();
}
inline void SignalResponse::set_has_leave() {
  _oneof_case_[0] = kLeave;
}
inline void SignalResponse::clear_leave() {
  if (_internal_has_leave()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.leave_;
    }
    clear_has_message();
  }
}
inline ::livekit::LeaveRequest* SignalResponse::release_leave() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.leave)
  if (_internal_has_leave()) {
    clear_has_message();
      ::livekit::LeaveRequest* temp = message_.leave_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.leave_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::LeaveRequest& SignalResponse::_internal_leave() const {
  return _internal_has_leave()
      ? *message_.leave_
      : reinterpret_cast< ::livekit::LeaveRequest&>(::livekit::_LeaveRequest_default_instance_);
}
inline const ::livekit::LeaveRequest& SignalResponse::leave() const {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.leave)
  return _internal_leave();
}
inline ::livekit::LeaveRequest* SignalResponse::unsafe_arena_release_leave() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.leave)
  if (_internal_has_leave()) {
    clear_has_message();
    ::livekit::LeaveRequest* temp = message_.leave_;
    message_.leave_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_leave(::livekit::LeaveRequest* leave) {
  clear_message();
  if (leave) {
    set_has_leave();
    message_.leave_ = leave;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.leave)
}
inline ::livekit::LeaveRequest* SignalResponse::_internal_mutable_leave() {
  if (!_internal_has_leave()) {
    clear_message();
    set_has_leave();
    message_.leave_ = CreateMaybeMessage< ::livekit::LeaveRequest >(GetArenaForAllocation());
  }
  return message_.leave_;
}
inline ::livekit::LeaveRequest* SignalResponse::mutable_leave() {
  ::livekit::LeaveRequest* _msg = _internal_mutable_leave();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.leave)
  return _msg;
}

// .livekit.MuteTrackRequest mute = 9;
inline bool SignalResponse::_internal_has_mute() const {
  return message_case() == kMute;
}
inline bool SignalResponse::has_mute() const {
  return _internal_has_mute();
}
inline void SignalResponse::set_has_mute() {
  _oneof_case_[0] = kMute;
}
inline void SignalResponse::clear_mute() {
  if (_internal_has_mute()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.mute_;
    }
    clear_has_message();
  }
}
inline ::livekit::MuteTrackRequest* SignalResponse::release_mute() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.mute)
  if (_internal_has_mute()) {
    clear_has_message();
      ::livekit::MuteTrackRequest* temp = message_.mute_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.mute_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::MuteTrackRequest& SignalResponse::_internal_mute() const {
  return _internal_has_mute()
      ? *message_.mute_
      : reinterpret_cast< ::livekit::MuteTrackRequest&>(::livekit::_MuteTrackRequest_default_instance_);
}
inline const ::livekit::MuteTrackRequest& SignalResponse::mute() const {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.mute)
  return _internal_mute();
}
inline ::livekit::MuteTrackRequest* SignalResponse::unsafe_arena_release_mute() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.mute)
  if (_internal_has_mute()) {
    clear_has_message();
    ::livekit::MuteTrackRequest* temp = message_.mute_;
    message_.mute_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_mute(::livekit::MuteTrackRequest* mute) {
  clear_message();
  if (mute) {
    set_has_mute();
    message_.mute_ = mute;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.mute)
}
inline ::livekit::MuteTrackRequest* SignalResponse::_internal_mutable_mute() {
  if (!_internal_has_mute()) {
    clear_message();
    set_has_mute();
    message_.mute_ = CreateMaybeMessage< ::livekit::MuteTrackRequest >(GetArenaForAllocation());
  }
  return message_.mute_;
}
inline ::livekit::MuteTrackRequest* SignalResponse::mutable_mute() {
  ::livekit::MuteTrackRequest* _msg = _internal_mutable_mute();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.mute)
  return _msg;
}

// .livekit.SpeakersChanged speakers_changed = 10;
inline bool SignalResponse::_internal_has_speakers_changed() const {
  return message_case() == kSpeakersChanged;
}
inline bool SignalResponse::has_speakers_changed() const {
  return _internal_has_speakers_changed();
}
inline void SignalResponse::set_has_speakers_changed() {
  _oneof_case_[0] = kSpeakersChanged;
}
inline void SignalResponse::clear_speakers_changed() {
  if (_internal_has_speakers_changed()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.speakers_changed_;
    }
    clear_has_message();
  }
}
inline ::livekit::SpeakersChanged* SignalResponse::release_speakers_changed() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.speakers_changed)
  if (_internal_has_speakers_changed()) {
    clear_has_message();
      ::livekit::SpeakersChanged* temp = message_.speakers_changed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.speakers_changed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SpeakersChanged& SignalResponse::_internal_speakers_changed() const {
  return _internal_has_speakers_changed()
      ? *message_.speakers_changed_
      : reinterpret_cast< ::livekit::SpeakersChanged&>(::livekit::_SpeakersChanged_default_instance_);
}
inline const ::livekit::SpeakersChanged& SignalResponse::speakers_changed() const {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.speakers_changed)
  return _internal_speakers_changed();
}
inline ::livekit::SpeakersChanged* SignalResponse::unsafe_arena_release_speakers_changed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.speakers_changed)
  if (_internal_has_speakers_changed()) {
    clear_has_message();
    ::livekit::SpeakersChanged* temp = message_.speakers_changed_;
    message_.speakers_changed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_speakers_changed(::livekit::SpeakersChanged* speakers_changed) {
  clear_message();
  if (speakers_changed) {
    set_has_speakers_changed();
    message_.speakers_changed_ = speakers_changed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.speakers_changed)
}
inline ::livekit::SpeakersChanged* SignalResponse::_internal_mutable_speakers_changed() {
  if (!_internal_has_speakers_changed()) {
    clear_message();
    set_has_speakers_changed();
    message_.speakers_changed_ = CreateMaybeMessage< ::livekit::SpeakersChanged >(GetArenaForAllocation());
  }
  return message_.speakers_changed_;
}
inline ::livekit::SpeakersChanged* SignalResponse::mutable_speakers_changed() {
  ::livekit::SpeakersChanged* _msg = _internal_mutable_speakers_changed();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.speakers_changed)
  return _msg;
}

// .livekit.RoomUpdate room_update = 11;
inline bool SignalResponse::_internal_has_room_update() const {
  return message_case() == kRoomUpdate;
}
inline bool SignalResponse::has_room_update() const {
  return _internal_has_room_update();
}
inline void SignalResponse::set_has_room_update() {
  _oneof_case_[0] = kRoomUpdate;
}
inline void SignalResponse::clear_room_update() {
  if (_internal_has_room_update()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.room_update_;
    }
    clear_has_message();
  }
}
inline ::livekit::RoomUpdate* SignalResponse::release_room_update() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.room_update)
  if (_internal_has_room_update()) {
    clear_has_message();
      ::livekit::RoomUpdate* temp = message_.room_update_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.room_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::RoomUpdate& SignalResponse::_internal_room_update() const {
  return _internal_has_room_update()
      ? *message_.room_update_
      : reinterpret_cast< ::livekit::RoomUpdate&>(::livekit::_RoomUpdate_default_instance_);
}
inline const ::livekit::RoomUpdate& SignalResponse::room_update() const {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.room_update)
  return _internal_room_update();
}
inline ::livekit::RoomUpdate* SignalResponse::unsafe_arena_release_room_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.room_update)
  if (_internal_has_room_update()) {
    clear_has_message();
    ::livekit::RoomUpdate* temp = message_.room_update_;
    message_.room_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_room_update(::livekit::RoomUpdate* room_update) {
  clear_message();
  if (room_update) {
    set_has_room_update();
    message_.room_update_ = room_update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.room_update)
}
inline ::livekit::RoomUpdate* SignalResponse::_internal_mutable_room_update() {
  if (!_internal_has_room_update()) {
    clear_message();
    set_has_room_update();
    message_.room_update_ = CreateMaybeMessage< ::livekit::RoomUpdate >(GetArenaForAllocation());
  }
  return message_.room_update_;
}
inline ::livekit::RoomUpdate* SignalResponse::mutable_room_update() {
  ::livekit::RoomUpdate* _msg = _internal_mutable_room_update();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.room_update)
  return _msg;
}

// .livekit.ConnectionQualityUpdate connection_quality = 12;
inline bool SignalResponse::_internal_has_connection_quality() const {
  return message_case() == kConnectionQuality;
}
inline bool SignalResponse::has_connection_quality() const {
  return _internal_has_connection_quality();
}
inline void SignalResponse::set_has_connection_quality() {
  _oneof_case_[0] = kConnectionQuality;
}
inline void SignalResponse::clear_connection_quality() {
  if (_internal_has_connection_quality()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.connection_quality_;
    }
    clear_has_message();
  }
}
inline ::livekit::ConnectionQualityUpdate* SignalResponse::release_connection_quality() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.connection_quality)
  if (_internal_has_connection_quality()) {
    clear_has_message();
      ::livekit::ConnectionQualityUpdate* temp = message_.connection_quality_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.connection_quality_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::ConnectionQualityUpdate& SignalResponse::_internal_connection_quality() const {
  return _internal_has_connection_quality()
      ? *message_.connection_quality_
      : reinterpret_cast< ::livekit::ConnectionQualityUpdate&>(::livekit::_ConnectionQualityUpdate_default_instance_);
}
inline const ::livekit::ConnectionQualityUpdate& SignalResponse::connection_quality() const {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.connection_quality)
  return _internal_connection_quality();
}
inline ::livekit::ConnectionQualityUpdate* SignalResponse::unsafe_arena_release_connection_quality() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.connection_quality)
  if (_internal_has_connection_quality()) {
    clear_has_message();
    ::livekit::ConnectionQualityUpdate* temp = message_.connection_quality_;
    message_.connection_quality_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_connection_quality(::livekit::ConnectionQualityUpdate* connection_quality) {
  clear_message();
  if (connection_quality) {
    set_has_connection_quality();
    message_.connection_quality_ = connection_quality;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.connection_quality)
}
inline ::livekit::ConnectionQualityUpdate* SignalResponse::_internal_mutable_connection_quality() {
  if (!_internal_has_connection_quality()) {
    clear_message();
    set_has_connection_quality();
    message_.connection_quality_ = CreateMaybeMessage< ::livekit::ConnectionQualityUpdate >(GetArenaForAllocation());
  }
  return message_.connection_quality_;
}
inline ::livekit::ConnectionQualityUpdate* SignalResponse::mutable_connection_quality() {
  ::livekit::ConnectionQualityUpdate* _msg = _internal_mutable_connection_quality();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.connection_quality)
  return _msg;
}

// .livekit.StreamStateUpdate stream_state_update = 13;
inline bool SignalResponse::_internal_has_stream_state_update() const {
  return message_case() == kStreamStateUpdate;
}
inline bool SignalResponse::has_stream_state_update() const {
  return _internal_has_stream_state_update();
}
inline void SignalResponse::set_has_stream_state_update() {
  _oneof_case_[0] = kStreamStateUpdate;
}
inline void SignalResponse::clear_stream_state_update() {
  if (_internal_has_stream_state_update()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.stream_state_update_;
    }
    clear_has_message();
  }
}
inline ::livekit::StreamStateUpdate* SignalResponse::release_stream_state_update() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.stream_state_update)
  if (_internal_has_stream_state_update()) {
    clear_has_message();
      ::livekit::StreamStateUpdate* temp = message_.stream_state_update_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.stream_state_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::StreamStateUpdate& SignalResponse::_internal_stream_state_update() const {
  return _internal_has_stream_state_update()
      ? *message_.stream_state_update_
      : reinterpret_cast< ::livekit::StreamStateUpdate&>(::livekit::_StreamStateUpdate_default_instance_);
}
inline const ::livekit::StreamStateUpdate& SignalResponse::stream_state_update() const {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.stream_state_update)
  return _internal_stream_state_update();
}
inline ::livekit::StreamStateUpdate* SignalResponse::unsafe_arena_release_stream_state_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.stream_state_update)
  if (_internal_has_stream_state_update()) {
    clear_has_message();
    ::livekit::StreamStateUpdate* temp = message_.stream_state_update_;
    message_.stream_state_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_stream_state_update(::livekit::StreamStateUpdate* stream_state_update) {
  clear_message();
  if (stream_state_update) {
    set_has_stream_state_update();
    message_.stream_state_update_ = stream_state_update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.stream_state_update)
}
inline ::livekit::StreamStateUpdate* SignalResponse::_internal_mutable_stream_state_update() {
  if (!_internal_has_stream_state_update()) {
    clear_message();
    set_has_stream_state_update();
    message_.stream_state_update_ = CreateMaybeMessage< ::livekit::StreamStateUpdate >(GetArenaForAllocation());
  }
  return message_.stream_state_update_;
}
inline ::livekit::StreamStateUpdate* SignalResponse::mutable_stream_state_update() {
  ::livekit::StreamStateUpdate* _msg = _internal_mutable_stream_state_update();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.stream_state_update)
  return _msg;
}

// .livekit.SubscribedQualityUpdate subscribed_quality_update = 14;
inline bool SignalResponse::_internal_has_subscribed_quality_update() const {
  return message_case() == kSubscribedQualityUpdate;
}
inline bool SignalResponse::has_subscribed_quality_update() const {
  return _internal_has_subscribed_quality_update();
}
inline void SignalResponse::set_has_subscribed_quality_update() {
  _oneof_case_[0] = kSubscribedQualityUpdate;
}
inline void SignalResponse::clear_subscribed_quality_update() {
  if (_internal_has_subscribed_quality_update()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.subscribed_quality_update_;
    }
    clear_has_message();
  }
}
inline ::livekit::SubscribedQualityUpdate* SignalResponse::release_subscribed_quality_update() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.subscribed_quality_update)
  if (_internal_has_subscribed_quality_update()) {
    clear_has_message();
      ::livekit::SubscribedQualityUpdate* temp = message_.subscribed_quality_update_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.subscribed_quality_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SubscribedQualityUpdate& SignalResponse::_internal_subscribed_quality_update() const {
  return _internal_has_subscribed_quality_update()
      ? *message_.subscribed_quality_update_
      : reinterpret_cast< ::livekit::SubscribedQualityUpdate&>(::livekit::_SubscribedQualityUpdate_default_instance_);
}
inline const ::livekit::SubscribedQualityUpdate& SignalResponse::subscribed_quality_update() const {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.subscribed_quality_update)
  return _internal_subscribed_quality_update();
}
inline ::livekit::SubscribedQualityUpdate* SignalResponse::unsafe_arena_release_subscribed_quality_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.subscribed_quality_update)
  if (_internal_has_subscribed_quality_update()) {
    clear_has_message();
    ::livekit::SubscribedQualityUpdate* temp = message_.subscribed_quality_update_;
    message_.subscribed_quality_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_subscribed_quality_update(::livekit::SubscribedQualityUpdate* subscribed_quality_update) {
  clear_message();
  if (subscribed_quality_update) {
    set_has_subscribed_quality_update();
    message_.subscribed_quality_update_ = subscribed_quality_update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.subscribed_quality_update)
}
inline ::livekit::SubscribedQualityUpdate* SignalResponse::_internal_mutable_subscribed_quality_update() {
  if (!_internal_has_subscribed_quality_update()) {
    clear_message();
    set_has_subscribed_quality_update();
    message_.subscribed_quality_update_ = CreateMaybeMessage< ::livekit::SubscribedQualityUpdate >(GetArenaForAllocation());
  }
  return message_.subscribed_quality_update_;
}
inline ::livekit::SubscribedQualityUpdate* SignalResponse::mutable_subscribed_quality_update() {
  ::livekit::SubscribedQualityUpdate* _msg = _internal_mutable_subscribed_quality_update();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.subscribed_quality_update)
  return _msg;
}

// .livekit.SubscriptionPermissionUpdate subscription_permission_update = 15;
inline bool SignalResponse::_internal_has_subscription_permission_update() const {
  return message_case() == kSubscriptionPermissionUpdate;
}
inline bool SignalResponse::has_subscription_permission_update() const {
  return _internal_has_subscription_permission_update();
}
inline void SignalResponse::set_has_subscription_permission_update() {
  _oneof_case_[0] = kSubscriptionPermissionUpdate;
}
inline void SignalResponse::clear_subscription_permission_update() {
  if (_internal_has_subscription_permission_update()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.subscription_permission_update_;
    }
    clear_has_message();
  }
}
inline ::livekit::SubscriptionPermissionUpdate* SignalResponse::release_subscription_permission_update() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.subscription_permission_update)
  if (_internal_has_subscription_permission_update()) {
    clear_has_message();
      ::livekit::SubscriptionPermissionUpdate* temp = message_.subscription_permission_update_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.subscription_permission_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SubscriptionPermissionUpdate& SignalResponse::_internal_subscription_permission_update() const {
  return _internal_has_subscription_permission_update()
      ? *message_.subscription_permission_update_
      : reinterpret_cast< ::livekit::SubscriptionPermissionUpdate&>(::livekit::_SubscriptionPermissionUpdate_default_instance_);
}
inline const ::livekit::SubscriptionPermissionUpdate& SignalResponse::subscription_permission_update() const {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.subscription_permission_update)
  return _internal_subscription_permission_update();
}
inline ::livekit::SubscriptionPermissionUpdate* SignalResponse::unsafe_arena_release_subscription_permission_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.subscription_permission_update)
  if (_internal_has_subscription_permission_update()) {
    clear_has_message();
    ::livekit::SubscriptionPermissionUpdate* temp = message_.subscription_permission_update_;
    message_.subscription_permission_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_subscription_permission_update(::livekit::SubscriptionPermissionUpdate* subscription_permission_update) {
  clear_message();
  if (subscription_permission_update) {
    set_has_subscription_permission_update();
    message_.subscription_permission_update_ = subscription_permission_update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.subscription_permission_update)
}
inline ::livekit::SubscriptionPermissionUpdate* SignalResponse::_internal_mutable_subscription_permission_update() {
  if (!_internal_has_subscription_permission_update()) {
    clear_message();
    set_has_subscription_permission_update();
    message_.subscription_permission_update_ = CreateMaybeMessage< ::livekit::SubscriptionPermissionUpdate >(GetArenaForAllocation());
  }
  return message_.subscription_permission_update_;
}
inline ::livekit::SubscriptionPermissionUpdate* SignalResponse::mutable_subscription_permission_update() {
  ::livekit::SubscriptionPermissionUpdate* _msg = _internal_mutable_subscription_permission_update();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.subscription_permission_update)
  return _msg;
}

// string refresh_token = 16;
inline bool SignalResponse::_internal_has_refresh_token() const {
  return message_case() == kRefreshToken;
}
inline bool SignalResponse::has_refresh_token() const {
  return _internal_has_refresh_token();
}
inline void SignalResponse::set_has_refresh_token() {
  _oneof_case_[0] = kRefreshToken;
}
inline void SignalResponse::clear_refresh_token() {
  if (_internal_has_refresh_token()) {
    message_.refresh_token_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_message();
  }
}
inline const std::string& SignalResponse::refresh_token() const {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.refresh_token)
  return _internal_refresh_token();
}
template <typename ArgT0, typename... ArgT>
inline void SignalResponse::set_refresh_token(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_refresh_token()) {
    clear_message();
    set_has_refresh_token();
    message_.refresh_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  message_.refresh_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.SignalResponse.refresh_token)
}
inline std::string* SignalResponse::mutable_refresh_token() {
  std::string* _s = _internal_mutable_refresh_token();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.refresh_token)
  return _s;
}
inline const std::string& SignalResponse::_internal_refresh_token() const {
  if (_internal_has_refresh_token()) {
    return message_.refresh_token_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void SignalResponse::_internal_set_refresh_token(const std::string& value) {
  if (!_internal_has_refresh_token()) {
    clear_message();
    set_has_refresh_token();
    message_.refresh_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  message_.refresh_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SignalResponse::_internal_mutable_refresh_token() {
  if (!_internal_has_refresh_token()) {
    clear_message();
    set_has_refresh_token();
    message_.refresh_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return message_.refresh_token_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SignalResponse::release_refresh_token() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.refresh_token)
  if (_internal_has_refresh_token()) {
    clear_has_message();
    return message_.refresh_token_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void SignalResponse::set_allocated_refresh_token(std::string* refresh_token) {
  if (has_message()) {
    clear_message();
  }
  if (refresh_token != nullptr) {
    set_has_refresh_token();
    message_.refresh_token_.UnsafeSetDefault(refresh_token);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(refresh_token);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.SignalResponse.refresh_token)
}

// .livekit.TrackUnpublishedResponse track_unpublished = 17;
inline bool SignalResponse::_internal_has_track_unpublished() const {
  return message_case() == kTrackUnpublished;
}
inline bool SignalResponse::has_track_unpublished() const {
  return _internal_has_track_unpublished();
}
inline void SignalResponse::set_has_track_unpublished() {
  _oneof_case_[0] = kTrackUnpublished;
}
inline void SignalResponse::clear_track_unpublished() {
  if (_internal_has_track_unpublished()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.track_unpublished_;
    }
    clear_has_message();
  }
}
inline ::livekit::TrackUnpublishedResponse* SignalResponse::release_track_unpublished() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.track_unpublished)
  if (_internal_has_track_unpublished()) {
    clear_has_message();
      ::livekit::TrackUnpublishedResponse* temp = message_.track_unpublished_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.track_unpublished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::TrackUnpublishedResponse& SignalResponse::_internal_track_unpublished() const {
  return _internal_has_track_unpublished()
      ? *message_.track_unpublished_
      : reinterpret_cast< ::livekit::TrackUnpublishedResponse&>(::livekit::_TrackUnpublishedResponse_default_instance_);
}
inline const ::livekit::TrackUnpublishedResponse& SignalResponse::track_unpublished() const {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.track_unpublished)
  return _internal_track_unpublished();
}
inline ::livekit::TrackUnpublishedResponse* SignalResponse::unsafe_arena_release_track_unpublished() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.track_unpublished)
  if (_internal_has_track_unpublished()) {
    clear_has_message();
    ::livekit::TrackUnpublishedResponse* temp = message_.track_unpublished_;
    message_.track_unpublished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_track_unpublished(::livekit::TrackUnpublishedResponse* track_unpublished) {
  clear_message();
  if (track_unpublished) {
    set_has_track_unpublished();
    message_.track_unpublished_ = track_unpublished;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.track_unpublished)
}
inline ::livekit::TrackUnpublishedResponse* SignalResponse::_internal_mutable_track_unpublished() {
  if (!_internal_has_track_unpublished()) {
    clear_message();
    set_has_track_unpublished();
    message_.track_unpublished_ = CreateMaybeMessage< ::livekit::TrackUnpublishedResponse >(GetArenaForAllocation());
  }
  return message_.track_unpublished_;
}
inline ::livekit::TrackUnpublishedResponse* SignalResponse::mutable_track_unpublished() {
  ::livekit::TrackUnpublishedResponse* _msg = _internal_mutable_track_unpublished();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.track_unpublished)
  return _msg;
}

inline bool SignalResponse::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void SignalResponse::clear_has_message() {
  _oneof_case_[0] = MESSAGE_NOT_SET;
}
inline SignalResponse::MessageCase SignalResponse::message_case() const {
  return SignalResponse::MessageCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AddTrackRequest

// string cid = 1;
inline void AddTrackRequest::clear_cid() {
  cid_.ClearToEmpty();
}
inline const std::string& AddTrackRequest::cid() const {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddTrackRequest::set_cid(ArgT0&& arg0, ArgT... args) {
 
 cid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.AddTrackRequest.cid)
}
inline std::string* AddTrackRequest::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:livekit.AddTrackRequest.cid)
  return _s;
}
inline const std::string& AddTrackRequest::_internal_cid() const {
  return cid_.Get();
}
inline void AddTrackRequest::_internal_set_cid(const std::string& value) {
  
  cid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AddTrackRequest::_internal_mutable_cid() {
  
  return cid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AddTrackRequest::release_cid() {
  // @@protoc_insertion_point(field_release:livekit.AddTrackRequest.cid)
  return cid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AddTrackRequest::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    
  } else {
    
  }
  cid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    cid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.AddTrackRequest.cid)
}

// string name = 2;
inline void AddTrackRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& AddTrackRequest::name() const {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddTrackRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.AddTrackRequest.name)
}
inline std::string* AddTrackRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:livekit.AddTrackRequest.name)
  return _s;
}
inline const std::string& AddTrackRequest::_internal_name() const {
  return name_.Get();
}
inline void AddTrackRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AddTrackRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AddTrackRequest::release_name() {
  // @@protoc_insertion_point(field_release:livekit.AddTrackRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AddTrackRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.AddTrackRequest.name)
}

// .livekit.TrackType type = 3;
inline void AddTrackRequest::clear_type() {
  type_ = 0;
}
inline ::livekit::TrackType AddTrackRequest::_internal_type() const {
  return static_cast< ::livekit::TrackType >(type_);
}
inline ::livekit::TrackType AddTrackRequest::type() const {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.type)
  return _internal_type();
}
inline void AddTrackRequest::_internal_set_type(::livekit::TrackType value) {
  
  type_ = value;
}
inline void AddTrackRequest::set_type(::livekit::TrackType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:livekit.AddTrackRequest.type)
}

// uint32 width = 4;
inline void AddTrackRequest::clear_width() {
  width_ = 0u;
}
inline uint32_t AddTrackRequest::_internal_width() const {
  return width_;
}
inline uint32_t AddTrackRequest::width() const {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.width)
  return _internal_width();
}
inline void AddTrackRequest::_internal_set_width(uint32_t value) {
  
  width_ = value;
}
inline void AddTrackRequest::set_width(uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:livekit.AddTrackRequest.width)
}

// uint32 height = 5;
inline void AddTrackRequest::clear_height() {
  height_ = 0u;
}
inline uint32_t AddTrackRequest::_internal_height() const {
  return height_;
}
inline uint32_t AddTrackRequest::height() const {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.height)
  return _internal_height();
}
inline void AddTrackRequest::_internal_set_height(uint32_t value) {
  
  height_ = value;
}
inline void AddTrackRequest::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:livekit.AddTrackRequest.height)
}

// bool muted = 6;
inline void AddTrackRequest::clear_muted() {
  muted_ = false;
}
inline bool AddTrackRequest::_internal_muted() const {
  return muted_;
}
inline bool AddTrackRequest::muted() const {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.muted)
  return _internal_muted();
}
inline void AddTrackRequest::_internal_set_muted(bool value) {
  
  muted_ = value;
}
inline void AddTrackRequest::set_muted(bool value) {
  _internal_set_muted(value);
  // @@protoc_insertion_point(field_set:livekit.AddTrackRequest.muted)
}

// bool disable_dtx = 7;
inline void AddTrackRequest::clear_disable_dtx() {
  disable_dtx_ = false;
}
inline bool AddTrackRequest::_internal_disable_dtx() const {
  return disable_dtx_;
}
inline bool AddTrackRequest::disable_dtx() const {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.disable_dtx)
  return _internal_disable_dtx();
}
inline void AddTrackRequest::_internal_set_disable_dtx(bool value) {
  
  disable_dtx_ = value;
}
inline void AddTrackRequest::set_disable_dtx(bool value) {
  _internal_set_disable_dtx(value);
  // @@protoc_insertion_point(field_set:livekit.AddTrackRequest.disable_dtx)
}

// .livekit.TrackSource source = 8;
inline void AddTrackRequest::clear_source() {
  source_ = 0;
}
inline ::livekit::TrackSource AddTrackRequest::_internal_source() const {
  return static_cast< ::livekit::TrackSource >(source_);
}
inline ::livekit::TrackSource AddTrackRequest::source() const {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.source)
  return _internal_source();
}
inline void AddTrackRequest::_internal_set_source(::livekit::TrackSource value) {
  
  source_ = value;
}
inline void AddTrackRequest::set_source(::livekit::TrackSource value) {
  _internal_set_source(value);
  // @@protoc_insertion_point(field_set:livekit.AddTrackRequest.source)
}

// repeated .livekit.VideoLayer layers = 9;
inline int AddTrackRequest::_internal_layers_size() const {
  return layers_.size();
}
inline int AddTrackRequest::layers_size() const {
  return _internal_layers_size();
}
inline ::livekit::VideoLayer* AddTrackRequest::mutable_layers(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.AddTrackRequest.layers)
  return layers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::VideoLayer >*
AddTrackRequest::mutable_layers() {
  // @@protoc_insertion_point(field_mutable_list:livekit.AddTrackRequest.layers)
  return &layers_;
}
inline const ::livekit::VideoLayer& AddTrackRequest::_internal_layers(int index) const {
  return layers_.Get(index);
}
inline const ::livekit::VideoLayer& AddTrackRequest::layers(int index) const {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.layers)
  return _internal_layers(index);
}
inline ::livekit::VideoLayer* AddTrackRequest::_internal_add_layers() {
  return layers_.Add();
}
inline ::livekit::VideoLayer* AddTrackRequest::add_layers() {
  ::livekit::VideoLayer* _add = _internal_add_layers();
  // @@protoc_insertion_point(field_add:livekit.AddTrackRequest.layers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::VideoLayer >&
AddTrackRequest::layers() const {
  // @@protoc_insertion_point(field_list:livekit.AddTrackRequest.layers)
  return layers_;
}

// -------------------------------------------------------------------

// TrickleRequest

// string candidateInit = 1;
inline void TrickleRequest::clear_candidateinit() {
  candidateinit_.ClearToEmpty();
}
inline const std::string& TrickleRequest::candidateinit() const {
  // @@protoc_insertion_point(field_get:livekit.TrickleRequest.candidateInit)
  return _internal_candidateinit();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrickleRequest::set_candidateinit(ArgT0&& arg0, ArgT... args) {
 
 candidateinit_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.TrickleRequest.candidateInit)
}
inline std::string* TrickleRequest::mutable_candidateinit() {
  std::string* _s = _internal_mutable_candidateinit();
  // @@protoc_insertion_point(field_mutable:livekit.TrickleRequest.candidateInit)
  return _s;
}
inline const std::string& TrickleRequest::_internal_candidateinit() const {
  return candidateinit_.Get();
}
inline void TrickleRequest::_internal_set_candidateinit(const std::string& value) {
  
  candidateinit_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TrickleRequest::_internal_mutable_candidateinit() {
  
  return candidateinit_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TrickleRequest::release_candidateinit() {
  // @@protoc_insertion_point(field_release:livekit.TrickleRequest.candidateInit)
  return candidateinit_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TrickleRequest::set_allocated_candidateinit(std::string* candidateinit) {
  if (candidateinit != nullptr) {
    
  } else {
    
  }
  candidateinit_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), candidateinit,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (candidateinit_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    candidateinit_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.TrickleRequest.candidateInit)
}

// .livekit.SignalTarget target = 2;
inline void TrickleRequest::clear_target() {
  target_ = 0;
}
inline ::livekit::SignalTarget TrickleRequest::_internal_target() const {
  return static_cast< ::livekit::SignalTarget >(target_);
}
inline ::livekit::SignalTarget TrickleRequest::target() const {
  // @@protoc_insertion_point(field_get:livekit.TrickleRequest.target)
  return _internal_target();
}
inline void TrickleRequest::_internal_set_target(::livekit::SignalTarget value) {
  
  target_ = value;
}
inline void TrickleRequest::set_target(::livekit::SignalTarget value) {
  _internal_set_target(value);
  // @@protoc_insertion_point(field_set:livekit.TrickleRequest.target)
}

// -------------------------------------------------------------------

// MuteTrackRequest

// string sid = 1;
inline void MuteTrackRequest::clear_sid() {
  sid_.ClearToEmpty();
}
inline const std::string& MuteTrackRequest::sid() const {
  // @@protoc_insertion_point(field_get:livekit.MuteTrackRequest.sid)
  return _internal_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MuteTrackRequest::set_sid(ArgT0&& arg0, ArgT... args) {
 
 sid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.MuteTrackRequest.sid)
}
inline std::string* MuteTrackRequest::mutable_sid() {
  std::string* _s = _internal_mutable_sid();
  // @@protoc_insertion_point(field_mutable:livekit.MuteTrackRequest.sid)
  return _s;
}
inline const std::string& MuteTrackRequest::_internal_sid() const {
  return sid_.Get();
}
inline void MuteTrackRequest::_internal_set_sid(const std::string& value) {
  
  sid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MuteTrackRequest::_internal_mutable_sid() {
  
  return sid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MuteTrackRequest::release_sid() {
  // @@protoc_insertion_point(field_release:livekit.MuteTrackRequest.sid)
  return sid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MuteTrackRequest::set_allocated_sid(std::string* sid) {
  if (sid != nullptr) {
    
  } else {
    
  }
  sid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.MuteTrackRequest.sid)
}

// bool muted = 2;
inline void MuteTrackRequest::clear_muted() {
  muted_ = false;
}
inline bool MuteTrackRequest::_internal_muted() const {
  return muted_;
}
inline bool MuteTrackRequest::muted() const {
  // @@protoc_insertion_point(field_get:livekit.MuteTrackRequest.muted)
  return _internal_muted();
}
inline void MuteTrackRequest::_internal_set_muted(bool value) {
  
  muted_ = value;
}
inline void MuteTrackRequest::set_muted(bool value) {
  _internal_set_muted(value);
  // @@protoc_insertion_point(field_set:livekit.MuteTrackRequest.muted)
}

// -------------------------------------------------------------------

// JoinResponse

// .livekit.Room room = 1;
inline bool JoinResponse::_internal_has_room() const {
  return this != internal_default_instance() && room_ != nullptr;
}
inline bool JoinResponse::has_room() const {
  return _internal_has_room();
}
inline const ::livekit::Room& JoinResponse::_internal_room() const {
  const ::livekit::Room* p = room_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::Room&>(
      ::livekit::_Room_default_instance_);
}
inline const ::livekit::Room& JoinResponse::room() const {
  // @@protoc_insertion_point(field_get:livekit.JoinResponse.room)
  return _internal_room();
}
inline void JoinResponse::unsafe_arena_set_allocated_room(
    ::livekit::Room* room) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(room_);
  }
  room_ = room;
  if (room) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.JoinResponse.room)
}
inline ::livekit::Room* JoinResponse::release_room() {
  
  ::livekit::Room* temp = room_;
  room_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::Room* JoinResponse::unsafe_arena_release_room() {
  // @@protoc_insertion_point(field_release:livekit.JoinResponse.room)
  
  ::livekit::Room* temp = room_;
  room_ = nullptr;
  return temp;
}
inline ::livekit::Room* JoinResponse::_internal_mutable_room() {
  
  if (room_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::Room>(GetArenaForAllocation());
    room_ = p;
  }
  return room_;
}
inline ::livekit::Room* JoinResponse::mutable_room() {
  ::livekit::Room* _msg = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:livekit.JoinResponse.room)
  return _msg;
}
inline void JoinResponse::set_allocated_room(::livekit::Room* room) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(room_);
  }
  if (room) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(room));
    if (message_arena != submessage_arena) {
      room = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, room, submessage_arena);
    }
    
  } else {
    
  }
  room_ = room;
  // @@protoc_insertion_point(field_set_allocated:livekit.JoinResponse.room)
}

// .livekit.ParticipantInfo participant = 2;
inline bool JoinResponse::_internal_has_participant() const {
  return this != internal_default_instance() && participant_ != nullptr;
}
inline bool JoinResponse::has_participant() const {
  return _internal_has_participant();
}
inline const ::livekit::ParticipantInfo& JoinResponse::_internal_participant() const {
  const ::livekit::ParticipantInfo* p = participant_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::ParticipantInfo&>(
      ::livekit::_ParticipantInfo_default_instance_);
}
inline const ::livekit::ParticipantInfo& JoinResponse::participant() const {
  // @@protoc_insertion_point(field_get:livekit.JoinResponse.participant)
  return _internal_participant();
}
inline void JoinResponse::unsafe_arena_set_allocated_participant(
    ::livekit::ParticipantInfo* participant) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(participant_);
  }
  participant_ = participant;
  if (participant) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.JoinResponse.participant)
}
inline ::livekit::ParticipantInfo* JoinResponse::release_participant() {
  
  ::livekit::ParticipantInfo* temp = participant_;
  participant_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::ParticipantInfo* JoinResponse::unsafe_arena_release_participant() {
  // @@protoc_insertion_point(field_release:livekit.JoinResponse.participant)
  
  ::livekit::ParticipantInfo* temp = participant_;
  participant_ = nullptr;
  return temp;
}
inline ::livekit::ParticipantInfo* JoinResponse::_internal_mutable_participant() {
  
  if (participant_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::ParticipantInfo>(GetArenaForAllocation());
    participant_ = p;
  }
  return participant_;
}
inline ::livekit::ParticipantInfo* JoinResponse::mutable_participant() {
  ::livekit::ParticipantInfo* _msg = _internal_mutable_participant();
  // @@protoc_insertion_point(field_mutable:livekit.JoinResponse.participant)
  return _msg;
}
inline void JoinResponse::set_allocated_participant(::livekit::ParticipantInfo* participant) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(participant_);
  }
  if (participant) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(participant));
    if (message_arena != submessage_arena) {
      participant = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, participant, submessage_arena);
    }
    
  } else {
    
  }
  participant_ = participant;
  // @@protoc_insertion_point(field_set_allocated:livekit.JoinResponse.participant)
}

// repeated .livekit.ParticipantInfo other_participants = 3;
inline int JoinResponse::_internal_other_participants_size() const {
  return other_participants_.size();
}
inline int JoinResponse::other_participants_size() const {
  return _internal_other_participants_size();
}
inline ::livekit::ParticipantInfo* JoinResponse::mutable_other_participants(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.JoinResponse.other_participants)
  return other_participants_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ParticipantInfo >*
JoinResponse::mutable_other_participants() {
  // @@protoc_insertion_point(field_mutable_list:livekit.JoinResponse.other_participants)
  return &other_participants_;
}
inline const ::livekit::ParticipantInfo& JoinResponse::_internal_other_participants(int index) const {
  return other_participants_.Get(index);
}
inline const ::livekit::ParticipantInfo& JoinResponse::other_participants(int index) const {
  // @@protoc_insertion_point(field_get:livekit.JoinResponse.other_participants)
  return _internal_other_participants(index);
}
inline ::livekit::ParticipantInfo* JoinResponse::_internal_add_other_participants() {
  return other_participants_.Add();
}
inline ::livekit::ParticipantInfo* JoinResponse::add_other_participants() {
  ::livekit::ParticipantInfo* _add = _internal_add_other_participants();
  // @@protoc_insertion_point(field_add:livekit.JoinResponse.other_participants)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ParticipantInfo >&
JoinResponse::other_participants() const {
  // @@protoc_insertion_point(field_list:livekit.JoinResponse.other_participants)
  return other_participants_;
}

// string server_version = 4;
inline void JoinResponse::clear_server_version() {
  server_version_.ClearToEmpty();
}
inline const std::string& JoinResponse::server_version() const {
  // @@protoc_insertion_point(field_get:livekit.JoinResponse.server_version)
  return _internal_server_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoinResponse::set_server_version(ArgT0&& arg0, ArgT... args) {
 
 server_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.JoinResponse.server_version)
}
inline std::string* JoinResponse::mutable_server_version() {
  std::string* _s = _internal_mutable_server_version();
  // @@protoc_insertion_point(field_mutable:livekit.JoinResponse.server_version)
  return _s;
}
inline const std::string& JoinResponse::_internal_server_version() const {
  return server_version_.Get();
}
inline void JoinResponse::_internal_set_server_version(const std::string& value) {
  
  server_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* JoinResponse::_internal_mutable_server_version() {
  
  return server_version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* JoinResponse::release_server_version() {
  // @@protoc_insertion_point(field_release:livekit.JoinResponse.server_version)
  return server_version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void JoinResponse::set_allocated_server_version(std::string* server_version) {
  if (server_version != nullptr) {
    
  } else {
    
  }
  server_version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), server_version,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (server_version_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    server_version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.JoinResponse.server_version)
}

// repeated .livekit.ICEServer ice_servers = 5;
inline int JoinResponse::_internal_ice_servers_size() const {
  return ice_servers_.size();
}
inline int JoinResponse::ice_servers_size() const {
  return _internal_ice_servers_size();
}
inline void JoinResponse::clear_ice_servers() {
  ice_servers_.Clear();
}
inline ::livekit::ICEServer* JoinResponse::mutable_ice_servers(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.JoinResponse.ice_servers)
  return ice_servers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ICEServer >*
JoinResponse::mutable_ice_servers() {
  // @@protoc_insertion_point(field_mutable_list:livekit.JoinResponse.ice_servers)
  return &ice_servers_;
}
inline const ::livekit::ICEServer& JoinResponse::_internal_ice_servers(int index) const {
  return ice_servers_.Get(index);
}
inline const ::livekit::ICEServer& JoinResponse::ice_servers(int index) const {
  // @@protoc_insertion_point(field_get:livekit.JoinResponse.ice_servers)
  return _internal_ice_servers(index);
}
inline ::livekit::ICEServer* JoinResponse::_internal_add_ice_servers() {
  return ice_servers_.Add();
}
inline ::livekit::ICEServer* JoinResponse::add_ice_servers() {
  ::livekit::ICEServer* _add = _internal_add_ice_servers();
  // @@protoc_insertion_point(field_add:livekit.JoinResponse.ice_servers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ICEServer >&
JoinResponse::ice_servers() const {
  // @@protoc_insertion_point(field_list:livekit.JoinResponse.ice_servers)
  return ice_servers_;
}

// bool subscriber_primary = 6;
inline void JoinResponse::clear_subscriber_primary() {
  subscriber_primary_ = false;
}
inline bool JoinResponse::_internal_subscriber_primary() const {
  return subscriber_primary_;
}
inline bool JoinResponse::subscriber_primary() const {
  // @@protoc_insertion_point(field_get:livekit.JoinResponse.subscriber_primary)
  return _internal_subscriber_primary();
}
inline void JoinResponse::_internal_set_subscriber_primary(bool value) {
  
  subscriber_primary_ = value;
}
inline void JoinResponse::set_subscriber_primary(bool value) {
  _internal_set_subscriber_primary(value);
  // @@protoc_insertion_point(field_set:livekit.JoinResponse.subscriber_primary)
}

// string alternative_url = 7;
inline void JoinResponse::clear_alternative_url() {
  alternative_url_.ClearToEmpty();
}
inline const std::string& JoinResponse::alternative_url() const {
  // @@protoc_insertion_point(field_get:livekit.JoinResponse.alternative_url)
  return _internal_alternative_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoinResponse::set_alternative_url(ArgT0&& arg0, ArgT... args) {
 
 alternative_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.JoinResponse.alternative_url)
}
inline std::string* JoinResponse::mutable_alternative_url() {
  std::string* _s = _internal_mutable_alternative_url();
  // @@protoc_insertion_point(field_mutable:livekit.JoinResponse.alternative_url)
  return _s;
}
inline const std::string& JoinResponse::_internal_alternative_url() const {
  return alternative_url_.Get();
}
inline void JoinResponse::_internal_set_alternative_url(const std::string& value) {
  
  alternative_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* JoinResponse::_internal_mutable_alternative_url() {
  
  return alternative_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* JoinResponse::release_alternative_url() {
  // @@protoc_insertion_point(field_release:livekit.JoinResponse.alternative_url)
  return alternative_url_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void JoinResponse::set_allocated_alternative_url(std::string* alternative_url) {
  if (alternative_url != nullptr) {
    
  } else {
    
  }
  alternative_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), alternative_url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (alternative_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    alternative_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.JoinResponse.alternative_url)
}

// .livekit.ClientConfiguration client_configuration = 8;
inline bool JoinResponse::_internal_has_client_configuration() const {
  return this != internal_default_instance() && client_configuration_ != nullptr;
}
inline bool JoinResponse::has_client_configuration() const {
  return _internal_has_client_configuration();
}
inline const ::livekit::ClientConfiguration& JoinResponse::_internal_client_configuration() const {
  const ::livekit::ClientConfiguration* p = client_configuration_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::ClientConfiguration&>(
      ::livekit::_ClientConfiguration_default_instance_);
}
inline const ::livekit::ClientConfiguration& JoinResponse::client_configuration() const {
  // @@protoc_insertion_point(field_get:livekit.JoinResponse.client_configuration)
  return _internal_client_configuration();
}
inline void JoinResponse::unsafe_arena_set_allocated_client_configuration(
    ::livekit::ClientConfiguration* client_configuration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_configuration_);
  }
  client_configuration_ = client_configuration;
  if (client_configuration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.JoinResponse.client_configuration)
}
inline ::livekit::ClientConfiguration* JoinResponse::release_client_configuration() {
  
  ::livekit::ClientConfiguration* temp = client_configuration_;
  client_configuration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::ClientConfiguration* JoinResponse::unsafe_arena_release_client_configuration() {
  // @@protoc_insertion_point(field_release:livekit.JoinResponse.client_configuration)
  
  ::livekit::ClientConfiguration* temp = client_configuration_;
  client_configuration_ = nullptr;
  return temp;
}
inline ::livekit::ClientConfiguration* JoinResponse::_internal_mutable_client_configuration() {
  
  if (client_configuration_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::ClientConfiguration>(GetArenaForAllocation());
    client_configuration_ = p;
  }
  return client_configuration_;
}
inline ::livekit::ClientConfiguration* JoinResponse::mutable_client_configuration() {
  ::livekit::ClientConfiguration* _msg = _internal_mutable_client_configuration();
  // @@protoc_insertion_point(field_mutable:livekit.JoinResponse.client_configuration)
  return _msg;
}
inline void JoinResponse::set_allocated_client_configuration(::livekit::ClientConfiguration* client_configuration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_configuration_);
  }
  if (client_configuration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_configuration));
    if (message_arena != submessage_arena) {
      client_configuration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_configuration, submessage_arena);
    }
    
  } else {
    
  }
  client_configuration_ = client_configuration;
  // @@protoc_insertion_point(field_set_allocated:livekit.JoinResponse.client_configuration)
}

// string server_region = 9;
inline void JoinResponse::clear_server_region() {
  server_region_.ClearToEmpty();
}
inline const std::string& JoinResponse::server_region() const {
  // @@protoc_insertion_point(field_get:livekit.JoinResponse.server_region)
  return _internal_server_region();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoinResponse::set_server_region(ArgT0&& arg0, ArgT... args) {
 
 server_region_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.JoinResponse.server_region)
}
inline std::string* JoinResponse::mutable_server_region() {
  std::string* _s = _internal_mutable_server_region();
  // @@protoc_insertion_point(field_mutable:livekit.JoinResponse.server_region)
  return _s;
}
inline const std::string& JoinResponse::_internal_server_region() const {
  return server_region_.Get();
}
inline void JoinResponse::_internal_set_server_region(const std::string& value) {
  
  server_region_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* JoinResponse::_internal_mutable_server_region() {
  
  return server_region_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* JoinResponse::release_server_region() {
  // @@protoc_insertion_point(field_release:livekit.JoinResponse.server_region)
  return server_region_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void JoinResponse::set_allocated_server_region(std::string* server_region) {
  if (server_region != nullptr) {
    
  } else {
    
  }
  server_region_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), server_region,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (server_region_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    server_region_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.JoinResponse.server_region)
}

// -------------------------------------------------------------------

// TrackPublishedResponse

// string cid = 1;
inline void TrackPublishedResponse::clear_cid() {
  cid_.ClearToEmpty();
}
inline const std::string& TrackPublishedResponse::cid() const {
  // @@protoc_insertion_point(field_get:livekit.TrackPublishedResponse.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackPublishedResponse::set_cid(ArgT0&& arg0, ArgT... args) {
 
 cid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.TrackPublishedResponse.cid)
}
inline std::string* TrackPublishedResponse::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:livekit.TrackPublishedResponse.cid)
  return _s;
}
inline const std::string& TrackPublishedResponse::_internal_cid() const {
  return cid_.Get();
}
inline void TrackPublishedResponse::_internal_set_cid(const std::string& value) {
  
  cid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TrackPublishedResponse::_internal_mutable_cid() {
  
  return cid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TrackPublishedResponse::release_cid() {
  // @@protoc_insertion_point(field_release:livekit.TrackPublishedResponse.cid)
  return cid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TrackPublishedResponse::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    
  } else {
    
  }
  cid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    cid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.TrackPublishedResponse.cid)
}

// .livekit.TrackInfo track = 2;
inline bool TrackPublishedResponse::_internal_has_track() const {
  return this != internal_default_instance() && track_ != nullptr;
}
inline bool TrackPublishedResponse::has_track() const {
  return _internal_has_track();
}
inline const ::livekit::TrackInfo& TrackPublishedResponse::_internal_track() const {
  const ::livekit::TrackInfo* p = track_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::TrackInfo&>(
      ::livekit::_TrackInfo_default_instance_);
}
inline const ::livekit::TrackInfo& TrackPublishedResponse::track() const {
  // @@protoc_insertion_point(field_get:livekit.TrackPublishedResponse.track)
  return _internal_track();
}
inline void TrackPublishedResponse::unsafe_arena_set_allocated_track(
    ::livekit::TrackInfo* track) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(track_);
  }
  track_ = track;
  if (track) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.TrackPublishedResponse.track)
}
inline ::livekit::TrackInfo* TrackPublishedResponse::release_track() {
  
  ::livekit::TrackInfo* temp = track_;
  track_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::TrackInfo* TrackPublishedResponse::unsafe_arena_release_track() {
  // @@protoc_insertion_point(field_release:livekit.TrackPublishedResponse.track)
  
  ::livekit::TrackInfo* temp = track_;
  track_ = nullptr;
  return temp;
}
inline ::livekit::TrackInfo* TrackPublishedResponse::_internal_mutable_track() {
  
  if (track_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::TrackInfo>(GetArenaForAllocation());
    track_ = p;
  }
  return track_;
}
inline ::livekit::TrackInfo* TrackPublishedResponse::mutable_track() {
  ::livekit::TrackInfo* _msg = _internal_mutable_track();
  // @@protoc_insertion_point(field_mutable:livekit.TrackPublishedResponse.track)
  return _msg;
}
inline void TrackPublishedResponse::set_allocated_track(::livekit::TrackInfo* track) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(track_);
  }
  if (track) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(track));
    if (message_arena != submessage_arena) {
      track = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, track, submessage_arena);
    }
    
  } else {
    
  }
  track_ = track;
  // @@protoc_insertion_point(field_set_allocated:livekit.TrackPublishedResponse.track)
}

// -------------------------------------------------------------------

// TrackUnpublishedResponse

// string track_sid = 1;
inline void TrackUnpublishedResponse::clear_track_sid() {
  track_sid_.ClearToEmpty();
}
inline const std::string& TrackUnpublishedResponse::track_sid() const {
  // @@protoc_insertion_point(field_get:livekit.TrackUnpublishedResponse.track_sid)
  return _internal_track_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackUnpublishedResponse::set_track_sid(ArgT0&& arg0, ArgT... args) {
 
 track_sid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.TrackUnpublishedResponse.track_sid)
}
inline std::string* TrackUnpublishedResponse::mutable_track_sid() {
  std::string* _s = _internal_mutable_track_sid();
  // @@protoc_insertion_point(field_mutable:livekit.TrackUnpublishedResponse.track_sid)
  return _s;
}
inline const std::string& TrackUnpublishedResponse::_internal_track_sid() const {
  return track_sid_.Get();
}
inline void TrackUnpublishedResponse::_internal_set_track_sid(const std::string& value) {
  
  track_sid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TrackUnpublishedResponse::_internal_mutable_track_sid() {
  
  return track_sid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TrackUnpublishedResponse::release_track_sid() {
  // @@protoc_insertion_point(field_release:livekit.TrackUnpublishedResponse.track_sid)
  return track_sid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TrackUnpublishedResponse::set_allocated_track_sid(std::string* track_sid) {
  if (track_sid != nullptr) {
    
  } else {
    
  }
  track_sid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), track_sid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (track_sid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    track_sid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.TrackUnpublishedResponse.track_sid)
}

// -------------------------------------------------------------------

// SessionDescription

// string type = 1;
inline void SessionDescription::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& SessionDescription::type() const {
  // @@protoc_insertion_point(field_get:livekit.SessionDescription.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SessionDescription::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.SessionDescription.type)
}
inline std::string* SessionDescription::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:livekit.SessionDescription.type)
  return _s;
}
inline const std::string& SessionDescription::_internal_type() const {
  return type_.Get();
}
inline void SessionDescription::_internal_set_type(const std::string& value) {
  
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SessionDescription::_internal_mutable_type() {
  
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SessionDescription::release_type() {
  // @@protoc_insertion_point(field_release:livekit.SessionDescription.type)
  return type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SessionDescription::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.SessionDescription.type)
}

// string sdp = 2;
inline void SessionDescription::clear_sdp() {
  sdp_.ClearToEmpty();
}
inline const std::string& SessionDescription::sdp() const {
  // @@protoc_insertion_point(field_get:livekit.SessionDescription.sdp)
  return _internal_sdp();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SessionDescription::set_sdp(ArgT0&& arg0, ArgT... args) {
 
 sdp_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.SessionDescription.sdp)
}
inline std::string* SessionDescription::mutable_sdp() {
  std::string* _s = _internal_mutable_sdp();
  // @@protoc_insertion_point(field_mutable:livekit.SessionDescription.sdp)
  return _s;
}
inline const std::string& SessionDescription::_internal_sdp() const {
  return sdp_.Get();
}
inline void SessionDescription::_internal_set_sdp(const std::string& value) {
  
  sdp_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SessionDescription::_internal_mutable_sdp() {
  
  return sdp_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SessionDescription::release_sdp() {
  // @@protoc_insertion_point(field_release:livekit.SessionDescription.sdp)
  return sdp_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SessionDescription::set_allocated_sdp(std::string* sdp) {
  if (sdp != nullptr) {
    
  } else {
    
  }
  sdp_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sdp,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sdp_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sdp_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.SessionDescription.sdp)
}

// -------------------------------------------------------------------

// ParticipantUpdate

// repeated .livekit.ParticipantInfo participants = 1;
inline int ParticipantUpdate::_internal_participants_size() const {
  return participants_.size();
}
inline int ParticipantUpdate::participants_size() const {
  return _internal_participants_size();
}
inline ::livekit::ParticipantInfo* ParticipantUpdate::mutable_participants(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.ParticipantUpdate.participants)
  return participants_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ParticipantInfo >*
ParticipantUpdate::mutable_participants() {
  // @@protoc_insertion_point(field_mutable_list:livekit.ParticipantUpdate.participants)
  return &participants_;
}
inline const ::livekit::ParticipantInfo& ParticipantUpdate::_internal_participants(int index) const {
  return participants_.Get(index);
}
inline const ::livekit::ParticipantInfo& ParticipantUpdate::participants(int index) const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantUpdate.participants)
  return _internal_participants(index);
}
inline ::livekit::ParticipantInfo* ParticipantUpdate::_internal_add_participants() {
  return participants_.Add();
}
inline ::livekit::ParticipantInfo* ParticipantUpdate::add_participants() {
  ::livekit::ParticipantInfo* _add = _internal_add_participants();
  // @@protoc_insertion_point(field_add:livekit.ParticipantUpdate.participants)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ParticipantInfo >&
ParticipantUpdate::participants() const {
  // @@protoc_insertion_point(field_list:livekit.ParticipantUpdate.participants)
  return participants_;
}

// -------------------------------------------------------------------

// UpdateSubscription

// repeated string track_sids = 1;
inline int UpdateSubscription::_internal_track_sids_size() const {
  return track_sids_.size();
}
inline int UpdateSubscription::track_sids_size() const {
  return _internal_track_sids_size();
}
inline void UpdateSubscription::clear_track_sids() {
  track_sids_.Clear();
}
inline std::string* UpdateSubscription::add_track_sids() {
  std::string* _s = _internal_add_track_sids();
  // @@protoc_insertion_point(field_add_mutable:livekit.UpdateSubscription.track_sids)
  return _s;
}
inline const std::string& UpdateSubscription::_internal_track_sids(int index) const {
  return track_sids_.Get(index);
}
inline const std::string& UpdateSubscription::track_sids(int index) const {
  // @@protoc_insertion_point(field_get:livekit.UpdateSubscription.track_sids)
  return _internal_track_sids(index);
}
inline std::string* UpdateSubscription::mutable_track_sids(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.UpdateSubscription.track_sids)
  return track_sids_.Mutable(index);
}
inline void UpdateSubscription::set_track_sids(int index, const std::string& value) {
  track_sids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:livekit.UpdateSubscription.track_sids)
}
inline void UpdateSubscription::set_track_sids(int index, std::string&& value) {
  track_sids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:livekit.UpdateSubscription.track_sids)
}
inline void UpdateSubscription::set_track_sids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  track_sids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:livekit.UpdateSubscription.track_sids)
}
inline void UpdateSubscription::set_track_sids(int index, const char* value, size_t size) {
  track_sids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:livekit.UpdateSubscription.track_sids)
}
inline std::string* UpdateSubscription::_internal_add_track_sids() {
  return track_sids_.Add();
}
inline void UpdateSubscription::add_track_sids(const std::string& value) {
  track_sids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:livekit.UpdateSubscription.track_sids)
}
inline void UpdateSubscription::add_track_sids(std::string&& value) {
  track_sids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:livekit.UpdateSubscription.track_sids)
}
inline void UpdateSubscription::add_track_sids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  track_sids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:livekit.UpdateSubscription.track_sids)
}
inline void UpdateSubscription::add_track_sids(const char* value, size_t size) {
  track_sids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:livekit.UpdateSubscription.track_sids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UpdateSubscription::track_sids() const {
  // @@protoc_insertion_point(field_list:livekit.UpdateSubscription.track_sids)
  return track_sids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UpdateSubscription::mutable_track_sids() {
  // @@protoc_insertion_point(field_mutable_list:livekit.UpdateSubscription.track_sids)
  return &track_sids_;
}

// bool subscribe = 2;
inline void UpdateSubscription::clear_subscribe() {
  subscribe_ = false;
}
inline bool UpdateSubscription::_internal_subscribe() const {
  return subscribe_;
}
inline bool UpdateSubscription::subscribe() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateSubscription.subscribe)
  return _internal_subscribe();
}
inline void UpdateSubscription::_internal_set_subscribe(bool value) {
  
  subscribe_ = value;
}
inline void UpdateSubscription::set_subscribe(bool value) {
  _internal_set_subscribe(value);
  // @@protoc_insertion_point(field_set:livekit.UpdateSubscription.subscribe)
}

// repeated .livekit.ParticipantTracks participant_tracks = 3;
inline int UpdateSubscription::_internal_participant_tracks_size() const {
  return participant_tracks_.size();
}
inline int UpdateSubscription::participant_tracks_size() const {
  return _internal_participant_tracks_size();
}
inline ::livekit::ParticipantTracks* UpdateSubscription::mutable_participant_tracks(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.UpdateSubscription.participant_tracks)
  return participant_tracks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ParticipantTracks >*
UpdateSubscription::mutable_participant_tracks() {
  // @@protoc_insertion_point(field_mutable_list:livekit.UpdateSubscription.participant_tracks)
  return &participant_tracks_;
}
inline const ::livekit::ParticipantTracks& UpdateSubscription::_internal_participant_tracks(int index) const {
  return participant_tracks_.Get(index);
}
inline const ::livekit::ParticipantTracks& UpdateSubscription::participant_tracks(int index) const {
  // @@protoc_insertion_point(field_get:livekit.UpdateSubscription.participant_tracks)
  return _internal_participant_tracks(index);
}
inline ::livekit::ParticipantTracks* UpdateSubscription::_internal_add_participant_tracks() {
  return participant_tracks_.Add();
}
inline ::livekit::ParticipantTracks* UpdateSubscription::add_participant_tracks() {
  ::livekit::ParticipantTracks* _add = _internal_add_participant_tracks();
  // @@protoc_insertion_point(field_add:livekit.UpdateSubscription.participant_tracks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ParticipantTracks >&
UpdateSubscription::participant_tracks() const {
  // @@protoc_insertion_point(field_list:livekit.UpdateSubscription.participant_tracks)
  return participant_tracks_;
}

// -------------------------------------------------------------------

// UpdateTrackSettings

// repeated string track_sids = 1;
inline int UpdateTrackSettings::_internal_track_sids_size() const {
  return track_sids_.size();
}
inline int UpdateTrackSettings::track_sids_size() const {
  return _internal_track_sids_size();
}
inline void UpdateTrackSettings::clear_track_sids() {
  track_sids_.Clear();
}
inline std::string* UpdateTrackSettings::add_track_sids() {
  std::string* _s = _internal_add_track_sids();
  // @@protoc_insertion_point(field_add_mutable:livekit.UpdateTrackSettings.track_sids)
  return _s;
}
inline const std::string& UpdateTrackSettings::_internal_track_sids(int index) const {
  return track_sids_.Get(index);
}
inline const std::string& UpdateTrackSettings::track_sids(int index) const {
  // @@protoc_insertion_point(field_get:livekit.UpdateTrackSettings.track_sids)
  return _internal_track_sids(index);
}
inline std::string* UpdateTrackSettings::mutable_track_sids(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.UpdateTrackSettings.track_sids)
  return track_sids_.Mutable(index);
}
inline void UpdateTrackSettings::set_track_sids(int index, const std::string& value) {
  track_sids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:livekit.UpdateTrackSettings.track_sids)
}
inline void UpdateTrackSettings::set_track_sids(int index, std::string&& value) {
  track_sids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:livekit.UpdateTrackSettings.track_sids)
}
inline void UpdateTrackSettings::set_track_sids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  track_sids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:livekit.UpdateTrackSettings.track_sids)
}
inline void UpdateTrackSettings::set_track_sids(int index, const char* value, size_t size) {
  track_sids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:livekit.UpdateTrackSettings.track_sids)
}
inline std::string* UpdateTrackSettings::_internal_add_track_sids() {
  return track_sids_.Add();
}
inline void UpdateTrackSettings::add_track_sids(const std::string& value) {
  track_sids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:livekit.UpdateTrackSettings.track_sids)
}
inline void UpdateTrackSettings::add_track_sids(std::string&& value) {
  track_sids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:livekit.UpdateTrackSettings.track_sids)
}
inline void UpdateTrackSettings::add_track_sids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  track_sids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:livekit.UpdateTrackSettings.track_sids)
}
inline void UpdateTrackSettings::add_track_sids(const char* value, size_t size) {
  track_sids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:livekit.UpdateTrackSettings.track_sids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UpdateTrackSettings::track_sids() const {
  // @@protoc_insertion_point(field_list:livekit.UpdateTrackSettings.track_sids)
  return track_sids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UpdateTrackSettings::mutable_track_sids() {
  // @@protoc_insertion_point(field_mutable_list:livekit.UpdateTrackSettings.track_sids)
  return &track_sids_;
}

// bool disabled = 3;
inline void UpdateTrackSettings::clear_disabled() {
  disabled_ = false;
}
inline bool UpdateTrackSettings::_internal_disabled() const {
  return disabled_;
}
inline bool UpdateTrackSettings::disabled() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateTrackSettings.disabled)
  return _internal_disabled();
}
inline void UpdateTrackSettings::_internal_set_disabled(bool value) {
  
  disabled_ = value;
}
inline void UpdateTrackSettings::set_disabled(bool value) {
  _internal_set_disabled(value);
  // @@protoc_insertion_point(field_set:livekit.UpdateTrackSettings.disabled)
}

// .livekit.VideoQuality quality = 4;
inline void UpdateTrackSettings::clear_quality() {
  quality_ = 0;
}
inline ::livekit::VideoQuality UpdateTrackSettings::_internal_quality() const {
  return static_cast< ::livekit::VideoQuality >(quality_);
}
inline ::livekit::VideoQuality UpdateTrackSettings::quality() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateTrackSettings.quality)
  return _internal_quality();
}
inline void UpdateTrackSettings::_internal_set_quality(::livekit::VideoQuality value) {
  
  quality_ = value;
}
inline void UpdateTrackSettings::set_quality(::livekit::VideoQuality value) {
  _internal_set_quality(value);
  // @@protoc_insertion_point(field_set:livekit.UpdateTrackSettings.quality)
}

// uint32 width = 5;
inline void UpdateTrackSettings::clear_width() {
  width_ = 0u;
}
inline uint32_t UpdateTrackSettings::_internal_width() const {
  return width_;
}
inline uint32_t UpdateTrackSettings::width() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateTrackSettings.width)
  return _internal_width();
}
inline void UpdateTrackSettings::_internal_set_width(uint32_t value) {
  
  width_ = value;
}
inline void UpdateTrackSettings::set_width(uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:livekit.UpdateTrackSettings.width)
}

// uint32 height = 6;
inline void UpdateTrackSettings::clear_height() {
  height_ = 0u;
}
inline uint32_t UpdateTrackSettings::_internal_height() const {
  return height_;
}
inline uint32_t UpdateTrackSettings::height() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateTrackSettings.height)
  return _internal_height();
}
inline void UpdateTrackSettings::_internal_set_height(uint32_t value) {
  
  height_ = value;
}
inline void UpdateTrackSettings::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:livekit.UpdateTrackSettings.height)
}

// -------------------------------------------------------------------

// LeaveRequest

// bool can_reconnect = 1;
inline void LeaveRequest::clear_can_reconnect() {
  can_reconnect_ = false;
}
inline bool LeaveRequest::_internal_can_reconnect() const {
  return can_reconnect_;
}
inline bool LeaveRequest::can_reconnect() const {
  // @@protoc_insertion_point(field_get:livekit.LeaveRequest.can_reconnect)
  return _internal_can_reconnect();
}
inline void LeaveRequest::_internal_set_can_reconnect(bool value) {
  
  can_reconnect_ = value;
}
inline void LeaveRequest::set_can_reconnect(bool value) {
  _internal_set_can_reconnect(value);
  // @@protoc_insertion_point(field_set:livekit.LeaveRequest.can_reconnect)
}

// -------------------------------------------------------------------

// UpdateVideoLayers

// string track_sid = 1;
inline void UpdateVideoLayers::clear_track_sid() {
  track_sid_.ClearToEmpty();
}
inline const std::string& UpdateVideoLayers::track_sid() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateVideoLayers.track_sid)
  return _internal_track_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateVideoLayers::set_track_sid(ArgT0&& arg0, ArgT... args) {
 
 track_sid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.UpdateVideoLayers.track_sid)
}
inline std::string* UpdateVideoLayers::mutable_track_sid() {
  std::string* _s = _internal_mutable_track_sid();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateVideoLayers.track_sid)
  return _s;
}
inline const std::string& UpdateVideoLayers::_internal_track_sid() const {
  return track_sid_.Get();
}
inline void UpdateVideoLayers::_internal_set_track_sid(const std::string& value) {
  
  track_sid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateVideoLayers::_internal_mutable_track_sid() {
  
  return track_sid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateVideoLayers::release_track_sid() {
  // @@protoc_insertion_point(field_release:livekit.UpdateVideoLayers.track_sid)
  return track_sid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateVideoLayers::set_allocated_track_sid(std::string* track_sid) {
  if (track_sid != nullptr) {
    
  } else {
    
  }
  track_sid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), track_sid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (track_sid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    track_sid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateVideoLayers.track_sid)
}

// repeated .livekit.VideoLayer layers = 2;
inline int UpdateVideoLayers::_internal_layers_size() const {
  return layers_.size();
}
inline int UpdateVideoLayers::layers_size() const {
  return _internal_layers_size();
}
inline ::livekit::VideoLayer* UpdateVideoLayers::mutable_layers(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.UpdateVideoLayers.layers)
  return layers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::VideoLayer >*
UpdateVideoLayers::mutable_layers() {
  // @@protoc_insertion_point(field_mutable_list:livekit.UpdateVideoLayers.layers)
  return &layers_;
}
inline const ::livekit::VideoLayer& UpdateVideoLayers::_internal_layers(int index) const {
  return layers_.Get(index);
}
inline const ::livekit::VideoLayer& UpdateVideoLayers::layers(int index) const {
  // @@protoc_insertion_point(field_get:livekit.UpdateVideoLayers.layers)
  return _internal_layers(index);
}
inline ::livekit::VideoLayer* UpdateVideoLayers::_internal_add_layers() {
  return layers_.Add();
}
inline ::livekit::VideoLayer* UpdateVideoLayers::add_layers() {
  ::livekit::VideoLayer* _add = _internal_add_layers();
  // @@protoc_insertion_point(field_add:livekit.UpdateVideoLayers.layers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::VideoLayer >&
UpdateVideoLayers::layers() const {
  // @@protoc_insertion_point(field_list:livekit.UpdateVideoLayers.layers)
  return layers_;
}

// -------------------------------------------------------------------

// ICEServer

// repeated string urls = 1;
inline int ICEServer::_internal_urls_size() const {
  return urls_.size();
}
inline int ICEServer::urls_size() const {
  return _internal_urls_size();
}
inline void ICEServer::clear_urls() {
  urls_.Clear();
}
inline std::string* ICEServer::add_urls() {
  std::string* _s = _internal_add_urls();
  // @@protoc_insertion_point(field_add_mutable:livekit.ICEServer.urls)
  return _s;
}
inline const std::string& ICEServer::_internal_urls(int index) const {
  return urls_.Get(index);
}
inline const std::string& ICEServer::urls(int index) const {
  // @@protoc_insertion_point(field_get:livekit.ICEServer.urls)
  return _internal_urls(index);
}
inline std::string* ICEServer::mutable_urls(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.ICEServer.urls)
  return urls_.Mutable(index);
}
inline void ICEServer::set_urls(int index, const std::string& value) {
  urls_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:livekit.ICEServer.urls)
}
inline void ICEServer::set_urls(int index, std::string&& value) {
  urls_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:livekit.ICEServer.urls)
}
inline void ICEServer::set_urls(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  urls_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:livekit.ICEServer.urls)
}
inline void ICEServer::set_urls(int index, const char* value, size_t size) {
  urls_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:livekit.ICEServer.urls)
}
inline std::string* ICEServer::_internal_add_urls() {
  return urls_.Add();
}
inline void ICEServer::add_urls(const std::string& value) {
  urls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:livekit.ICEServer.urls)
}
inline void ICEServer::add_urls(std::string&& value) {
  urls_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:livekit.ICEServer.urls)
}
inline void ICEServer::add_urls(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  urls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:livekit.ICEServer.urls)
}
inline void ICEServer::add_urls(const char* value, size_t size) {
  urls_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:livekit.ICEServer.urls)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ICEServer::urls() const {
  // @@protoc_insertion_point(field_list:livekit.ICEServer.urls)
  return urls_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ICEServer::mutable_urls() {
  // @@protoc_insertion_point(field_mutable_list:livekit.ICEServer.urls)
  return &urls_;
}

// string username = 2;
inline void ICEServer::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& ICEServer::username() const {
  // @@protoc_insertion_point(field_get:livekit.ICEServer.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ICEServer::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ICEServer.username)
}
inline std::string* ICEServer::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:livekit.ICEServer.username)
  return _s;
}
inline const std::string& ICEServer::_internal_username() const {
  return username_.Get();
}
inline void ICEServer::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ICEServer::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ICEServer::release_username() {
  // @@protoc_insertion_point(field_release:livekit.ICEServer.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ICEServer::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ICEServer.username)
}

// string credential = 3;
inline void ICEServer::clear_credential() {
  credential_.ClearToEmpty();
}
inline const std::string& ICEServer::credential() const {
  // @@protoc_insertion_point(field_get:livekit.ICEServer.credential)
  return _internal_credential();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ICEServer::set_credential(ArgT0&& arg0, ArgT... args) {
 
 credential_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ICEServer.credential)
}
inline std::string* ICEServer::mutable_credential() {
  std::string* _s = _internal_mutable_credential();
  // @@protoc_insertion_point(field_mutable:livekit.ICEServer.credential)
  return _s;
}
inline const std::string& ICEServer::_internal_credential() const {
  return credential_.Get();
}
inline void ICEServer::_internal_set_credential(const std::string& value) {
  
  credential_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ICEServer::_internal_mutable_credential() {
  
  return credential_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ICEServer::release_credential() {
  // @@protoc_insertion_point(field_release:livekit.ICEServer.credential)
  return credential_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ICEServer::set_allocated_credential(std::string* credential) {
  if (credential != nullptr) {
    
  } else {
    
  }
  credential_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), credential,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (credential_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    credential_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ICEServer.credential)
}

// -------------------------------------------------------------------

// SpeakersChanged

// repeated .livekit.SpeakerInfo speakers = 1;
inline int SpeakersChanged::_internal_speakers_size() const {
  return speakers_.size();
}
inline int SpeakersChanged::speakers_size() const {
  return _internal_speakers_size();
}
inline ::livekit::SpeakerInfo* SpeakersChanged::mutable_speakers(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.SpeakersChanged.speakers)
  return speakers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SpeakerInfo >*
SpeakersChanged::mutable_speakers() {
  // @@protoc_insertion_point(field_mutable_list:livekit.SpeakersChanged.speakers)
  return &speakers_;
}
inline const ::livekit::SpeakerInfo& SpeakersChanged::_internal_speakers(int index) const {
  return speakers_.Get(index);
}
inline const ::livekit::SpeakerInfo& SpeakersChanged::speakers(int index) const {
  // @@protoc_insertion_point(field_get:livekit.SpeakersChanged.speakers)
  return _internal_speakers(index);
}
inline ::livekit::SpeakerInfo* SpeakersChanged::_internal_add_speakers() {
  return speakers_.Add();
}
inline ::livekit::SpeakerInfo* SpeakersChanged::add_speakers() {
  ::livekit::SpeakerInfo* _add = _internal_add_speakers();
  // @@protoc_insertion_point(field_add:livekit.SpeakersChanged.speakers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SpeakerInfo >&
SpeakersChanged::speakers() const {
  // @@protoc_insertion_point(field_list:livekit.SpeakersChanged.speakers)
  return speakers_;
}

// -------------------------------------------------------------------

// RoomUpdate

// .livekit.Room room = 1;
inline bool RoomUpdate::_internal_has_room() const {
  return this != internal_default_instance() && room_ != nullptr;
}
inline bool RoomUpdate::has_room() const {
  return _internal_has_room();
}
inline const ::livekit::Room& RoomUpdate::_internal_room() const {
  const ::livekit::Room* p = room_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::Room&>(
      ::livekit::_Room_default_instance_);
}
inline const ::livekit::Room& RoomUpdate::room() const {
  // @@protoc_insertion_point(field_get:livekit.RoomUpdate.room)
  return _internal_room();
}
inline void RoomUpdate::unsafe_arena_set_allocated_room(
    ::livekit::Room* room) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(room_);
  }
  room_ = room;
  if (room) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.RoomUpdate.room)
}
inline ::livekit::Room* RoomUpdate::release_room() {
  
  ::livekit::Room* temp = room_;
  room_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::Room* RoomUpdate::unsafe_arena_release_room() {
  // @@protoc_insertion_point(field_release:livekit.RoomUpdate.room)
  
  ::livekit::Room* temp = room_;
  room_ = nullptr;
  return temp;
}
inline ::livekit::Room* RoomUpdate::_internal_mutable_room() {
  
  if (room_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::Room>(GetArenaForAllocation());
    room_ = p;
  }
  return room_;
}
inline ::livekit::Room* RoomUpdate::mutable_room() {
  ::livekit::Room* _msg = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:livekit.RoomUpdate.room)
  return _msg;
}
inline void RoomUpdate::set_allocated_room(::livekit::Room* room) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(room_);
  }
  if (room) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(room));
    if (message_arena != submessage_arena) {
      room = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, room, submessage_arena);
    }
    
  } else {
    
  }
  room_ = room;
  // @@protoc_insertion_point(field_set_allocated:livekit.RoomUpdate.room)
}

// -------------------------------------------------------------------

// ConnectionQualityInfo

// string participant_sid = 1;
inline void ConnectionQualityInfo::clear_participant_sid() {
  participant_sid_.ClearToEmpty();
}
inline const std::string& ConnectionQualityInfo::participant_sid() const {
  // @@protoc_insertion_point(field_get:livekit.ConnectionQualityInfo.participant_sid)
  return _internal_participant_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConnectionQualityInfo::set_participant_sid(ArgT0&& arg0, ArgT... args) {
 
 participant_sid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ConnectionQualityInfo.participant_sid)
}
inline std::string* ConnectionQualityInfo::mutable_participant_sid() {
  std::string* _s = _internal_mutable_participant_sid();
  // @@protoc_insertion_point(field_mutable:livekit.ConnectionQualityInfo.participant_sid)
  return _s;
}
inline const std::string& ConnectionQualityInfo::_internal_participant_sid() const {
  return participant_sid_.Get();
}
inline void ConnectionQualityInfo::_internal_set_participant_sid(const std::string& value) {
  
  participant_sid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConnectionQualityInfo::_internal_mutable_participant_sid() {
  
  return participant_sid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConnectionQualityInfo::release_participant_sid() {
  // @@protoc_insertion_point(field_release:livekit.ConnectionQualityInfo.participant_sid)
  return participant_sid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ConnectionQualityInfo::set_allocated_participant_sid(std::string* participant_sid) {
  if (participant_sid != nullptr) {
    
  } else {
    
  }
  participant_sid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), participant_sid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (participant_sid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    participant_sid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ConnectionQualityInfo.participant_sid)
}

// .livekit.ConnectionQuality quality = 2;
inline void ConnectionQualityInfo::clear_quality() {
  quality_ = 0;
}
inline ::livekit::ConnectionQuality ConnectionQualityInfo::_internal_quality() const {
  return static_cast< ::livekit::ConnectionQuality >(quality_);
}
inline ::livekit::ConnectionQuality ConnectionQualityInfo::quality() const {
  // @@protoc_insertion_point(field_get:livekit.ConnectionQualityInfo.quality)
  return _internal_quality();
}
inline void ConnectionQualityInfo::_internal_set_quality(::livekit::ConnectionQuality value) {
  
  quality_ = value;
}
inline void ConnectionQualityInfo::set_quality(::livekit::ConnectionQuality value) {
  _internal_set_quality(value);
  // @@protoc_insertion_point(field_set:livekit.ConnectionQualityInfo.quality)
}

// float score = 3;
inline void ConnectionQualityInfo::clear_score() {
  score_ = 0;
}
inline float ConnectionQualityInfo::_internal_score() const {
  return score_;
}
inline float ConnectionQualityInfo::score() const {
  // @@protoc_insertion_point(field_get:livekit.ConnectionQualityInfo.score)
  return _internal_score();
}
inline void ConnectionQualityInfo::_internal_set_score(float value) {
  
  score_ = value;
}
inline void ConnectionQualityInfo::set_score(float value) {
  _internal_set_score(value);
  // @@protoc_insertion_point(field_set:livekit.ConnectionQualityInfo.score)
}

// -------------------------------------------------------------------

// ConnectionQualityUpdate

// repeated .livekit.ConnectionQualityInfo updates = 1;
inline int ConnectionQualityUpdate::_internal_updates_size() const {
  return updates_.size();
}
inline int ConnectionQualityUpdate::updates_size() const {
  return _internal_updates_size();
}
inline void ConnectionQualityUpdate::clear_updates() {
  updates_.Clear();
}
inline ::livekit::ConnectionQualityInfo* ConnectionQualityUpdate::mutable_updates(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.ConnectionQualityUpdate.updates)
  return updates_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ConnectionQualityInfo >*
ConnectionQualityUpdate::mutable_updates() {
  // @@protoc_insertion_point(field_mutable_list:livekit.ConnectionQualityUpdate.updates)
  return &updates_;
}
inline const ::livekit::ConnectionQualityInfo& ConnectionQualityUpdate::_internal_updates(int index) const {
  return updates_.Get(index);
}
inline const ::livekit::ConnectionQualityInfo& ConnectionQualityUpdate::updates(int index) const {
  // @@protoc_insertion_point(field_get:livekit.ConnectionQualityUpdate.updates)
  return _internal_updates(index);
}
inline ::livekit::ConnectionQualityInfo* ConnectionQualityUpdate::_internal_add_updates() {
  return updates_.Add();
}
inline ::livekit::ConnectionQualityInfo* ConnectionQualityUpdate::add_updates() {
  ::livekit::ConnectionQualityInfo* _add = _internal_add_updates();
  // @@protoc_insertion_point(field_add:livekit.ConnectionQualityUpdate.updates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ConnectionQualityInfo >&
ConnectionQualityUpdate::updates() const {
  // @@protoc_insertion_point(field_list:livekit.ConnectionQualityUpdate.updates)
  return updates_;
}

// -------------------------------------------------------------------

// StreamStateInfo

// string participant_sid = 1;
inline void StreamStateInfo::clear_participant_sid() {
  participant_sid_.ClearToEmpty();
}
inline const std::string& StreamStateInfo::participant_sid() const {
  // @@protoc_insertion_point(field_get:livekit.StreamStateInfo.participant_sid)
  return _internal_participant_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamStateInfo::set_participant_sid(ArgT0&& arg0, ArgT... args) {
 
 participant_sid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.StreamStateInfo.participant_sid)
}
inline std::string* StreamStateInfo::mutable_participant_sid() {
  std::string* _s = _internal_mutable_participant_sid();
  // @@protoc_insertion_point(field_mutable:livekit.StreamStateInfo.participant_sid)
  return _s;
}
inline const std::string& StreamStateInfo::_internal_participant_sid() const {
  return participant_sid_.Get();
}
inline void StreamStateInfo::_internal_set_participant_sid(const std::string& value) {
  
  participant_sid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StreamStateInfo::_internal_mutable_participant_sid() {
  
  return participant_sid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StreamStateInfo::release_participant_sid() {
  // @@protoc_insertion_point(field_release:livekit.StreamStateInfo.participant_sid)
  return participant_sid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StreamStateInfo::set_allocated_participant_sid(std::string* participant_sid) {
  if (participant_sid != nullptr) {
    
  } else {
    
  }
  participant_sid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), participant_sid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (participant_sid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    participant_sid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.StreamStateInfo.participant_sid)
}

// string track_sid = 2;
inline void StreamStateInfo::clear_track_sid() {
  track_sid_.ClearToEmpty();
}
inline const std::string& StreamStateInfo::track_sid() const {
  // @@protoc_insertion_point(field_get:livekit.StreamStateInfo.track_sid)
  return _internal_track_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamStateInfo::set_track_sid(ArgT0&& arg0, ArgT... args) {
 
 track_sid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.StreamStateInfo.track_sid)
}
inline std::string* StreamStateInfo::mutable_track_sid() {
  std::string* _s = _internal_mutable_track_sid();
  // @@protoc_insertion_point(field_mutable:livekit.StreamStateInfo.track_sid)
  return _s;
}
inline const std::string& StreamStateInfo::_internal_track_sid() const {
  return track_sid_.Get();
}
inline void StreamStateInfo::_internal_set_track_sid(const std::string& value) {
  
  track_sid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StreamStateInfo::_internal_mutable_track_sid() {
  
  return track_sid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StreamStateInfo::release_track_sid() {
  // @@protoc_insertion_point(field_release:livekit.StreamStateInfo.track_sid)
  return track_sid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StreamStateInfo::set_allocated_track_sid(std::string* track_sid) {
  if (track_sid != nullptr) {
    
  } else {
    
  }
  track_sid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), track_sid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (track_sid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    track_sid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.StreamStateInfo.track_sid)
}

// .livekit.StreamState state = 3;
inline void StreamStateInfo::clear_state() {
  state_ = 0;
}
inline ::livekit::StreamState StreamStateInfo::_internal_state() const {
  return static_cast< ::livekit::StreamState >(state_);
}
inline ::livekit::StreamState StreamStateInfo::state() const {
  // @@protoc_insertion_point(field_get:livekit.StreamStateInfo.state)
  return _internal_state();
}
inline void StreamStateInfo::_internal_set_state(::livekit::StreamState value) {
  
  state_ = value;
}
inline void StreamStateInfo::set_state(::livekit::StreamState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:livekit.StreamStateInfo.state)
}

// -------------------------------------------------------------------

// StreamStateUpdate

// repeated .livekit.StreamStateInfo stream_states = 1;
inline int StreamStateUpdate::_internal_stream_states_size() const {
  return stream_states_.size();
}
inline int StreamStateUpdate::stream_states_size() const {
  return _internal_stream_states_size();
}
inline void StreamStateUpdate::clear_stream_states() {
  stream_states_.Clear();
}
inline ::livekit::StreamStateInfo* StreamStateUpdate::mutable_stream_states(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.StreamStateUpdate.stream_states)
  return stream_states_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::StreamStateInfo >*
StreamStateUpdate::mutable_stream_states() {
  // @@protoc_insertion_point(field_mutable_list:livekit.StreamStateUpdate.stream_states)
  return &stream_states_;
}
inline const ::livekit::StreamStateInfo& StreamStateUpdate::_internal_stream_states(int index) const {
  return stream_states_.Get(index);
}
inline const ::livekit::StreamStateInfo& StreamStateUpdate::stream_states(int index) const {
  // @@protoc_insertion_point(field_get:livekit.StreamStateUpdate.stream_states)
  return _internal_stream_states(index);
}
inline ::livekit::StreamStateInfo* StreamStateUpdate::_internal_add_stream_states() {
  return stream_states_.Add();
}
inline ::livekit::StreamStateInfo* StreamStateUpdate::add_stream_states() {
  ::livekit::StreamStateInfo* _add = _internal_add_stream_states();
  // @@protoc_insertion_point(field_add:livekit.StreamStateUpdate.stream_states)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::StreamStateInfo >&
StreamStateUpdate::stream_states() const {
  // @@protoc_insertion_point(field_list:livekit.StreamStateUpdate.stream_states)
  return stream_states_;
}

// -------------------------------------------------------------------

// SubscribedQuality

// .livekit.VideoQuality quality = 1;
inline void SubscribedQuality::clear_quality() {
  quality_ = 0;
}
inline ::livekit::VideoQuality SubscribedQuality::_internal_quality() const {
  return static_cast< ::livekit::VideoQuality >(quality_);
}
inline ::livekit::VideoQuality SubscribedQuality::quality() const {
  // @@protoc_insertion_point(field_get:livekit.SubscribedQuality.quality)
  return _internal_quality();
}
inline void SubscribedQuality::_internal_set_quality(::livekit::VideoQuality value) {
  
  quality_ = value;
}
inline void SubscribedQuality::set_quality(::livekit::VideoQuality value) {
  _internal_set_quality(value);
  // @@protoc_insertion_point(field_set:livekit.SubscribedQuality.quality)
}

// bool enabled = 2;
inline void SubscribedQuality::clear_enabled() {
  enabled_ = false;
}
inline bool SubscribedQuality::_internal_enabled() const {
  return enabled_;
}
inline bool SubscribedQuality::enabled() const {
  // @@protoc_insertion_point(field_get:livekit.SubscribedQuality.enabled)
  return _internal_enabled();
}
inline void SubscribedQuality::_internal_set_enabled(bool value) {
  
  enabled_ = value;
}
inline void SubscribedQuality::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:livekit.SubscribedQuality.enabled)
}

// -------------------------------------------------------------------

// SubscribedQualityUpdate

// string track_sid = 1;
inline void SubscribedQualityUpdate::clear_track_sid() {
  track_sid_.ClearToEmpty();
}
inline const std::string& SubscribedQualityUpdate::track_sid() const {
  // @@protoc_insertion_point(field_get:livekit.SubscribedQualityUpdate.track_sid)
  return _internal_track_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscribedQualityUpdate::set_track_sid(ArgT0&& arg0, ArgT... args) {
 
 track_sid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.SubscribedQualityUpdate.track_sid)
}
inline std::string* SubscribedQualityUpdate::mutable_track_sid() {
  std::string* _s = _internal_mutable_track_sid();
  // @@protoc_insertion_point(field_mutable:livekit.SubscribedQualityUpdate.track_sid)
  return _s;
}
inline const std::string& SubscribedQualityUpdate::_internal_track_sid() const {
  return track_sid_.Get();
}
inline void SubscribedQualityUpdate::_internal_set_track_sid(const std::string& value) {
  
  track_sid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SubscribedQualityUpdate::_internal_mutable_track_sid() {
  
  return track_sid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SubscribedQualityUpdate::release_track_sid() {
  // @@protoc_insertion_point(field_release:livekit.SubscribedQualityUpdate.track_sid)
  return track_sid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SubscribedQualityUpdate::set_allocated_track_sid(std::string* track_sid) {
  if (track_sid != nullptr) {
    
  } else {
    
  }
  track_sid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), track_sid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (track_sid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    track_sid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.SubscribedQualityUpdate.track_sid)
}

// repeated .livekit.SubscribedQuality subscribed_qualities = 2;
inline int SubscribedQualityUpdate::_internal_subscribed_qualities_size() const {
  return subscribed_qualities_.size();
}
inline int SubscribedQualityUpdate::subscribed_qualities_size() const {
  return _internal_subscribed_qualities_size();
}
inline void SubscribedQualityUpdate::clear_subscribed_qualities() {
  subscribed_qualities_.Clear();
}
inline ::livekit::SubscribedQuality* SubscribedQualityUpdate::mutable_subscribed_qualities(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.SubscribedQualityUpdate.subscribed_qualities)
  return subscribed_qualities_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SubscribedQuality >*
SubscribedQualityUpdate::mutable_subscribed_qualities() {
  // @@protoc_insertion_point(field_mutable_list:livekit.SubscribedQualityUpdate.subscribed_qualities)
  return &subscribed_qualities_;
}
inline const ::livekit::SubscribedQuality& SubscribedQualityUpdate::_internal_subscribed_qualities(int index) const {
  return subscribed_qualities_.Get(index);
}
inline const ::livekit::SubscribedQuality& SubscribedQualityUpdate::subscribed_qualities(int index) const {
  // @@protoc_insertion_point(field_get:livekit.SubscribedQualityUpdate.subscribed_qualities)
  return _internal_subscribed_qualities(index);
}
inline ::livekit::SubscribedQuality* SubscribedQualityUpdate::_internal_add_subscribed_qualities() {
  return subscribed_qualities_.Add();
}
inline ::livekit::SubscribedQuality* SubscribedQualityUpdate::add_subscribed_qualities() {
  ::livekit::SubscribedQuality* _add = _internal_add_subscribed_qualities();
  // @@protoc_insertion_point(field_add:livekit.SubscribedQualityUpdate.subscribed_qualities)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SubscribedQuality >&
SubscribedQualityUpdate::subscribed_qualities() const {
  // @@protoc_insertion_point(field_list:livekit.SubscribedQualityUpdate.subscribed_qualities)
  return subscribed_qualities_;
}

// -------------------------------------------------------------------

// TrackPermission

// string participant_sid = 1;
inline void TrackPermission::clear_participant_sid() {
  participant_sid_.ClearToEmpty();
}
inline const std::string& TrackPermission::participant_sid() const {
  // @@protoc_insertion_point(field_get:livekit.TrackPermission.participant_sid)
  return _internal_participant_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackPermission::set_participant_sid(ArgT0&& arg0, ArgT... args) {
 
 participant_sid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.TrackPermission.participant_sid)
}
inline std::string* TrackPermission::mutable_participant_sid() {
  std::string* _s = _internal_mutable_participant_sid();
  // @@protoc_insertion_point(field_mutable:livekit.TrackPermission.participant_sid)
  return _s;
}
inline const std::string& TrackPermission::_internal_participant_sid() const {
  return participant_sid_.Get();
}
inline void TrackPermission::_internal_set_participant_sid(const std::string& value) {
  
  participant_sid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TrackPermission::_internal_mutable_participant_sid() {
  
  return participant_sid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TrackPermission::release_participant_sid() {
  // @@protoc_insertion_point(field_release:livekit.TrackPermission.participant_sid)
  return participant_sid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TrackPermission::set_allocated_participant_sid(std::string* participant_sid) {
  if (participant_sid != nullptr) {
    
  } else {
    
  }
  participant_sid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), participant_sid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (participant_sid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    participant_sid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.TrackPermission.participant_sid)
}

// bool all_tracks = 2;
inline void TrackPermission::clear_all_tracks() {
  all_tracks_ = false;
}
inline bool TrackPermission::_internal_all_tracks() const {
  return all_tracks_;
}
inline bool TrackPermission::all_tracks() const {
  // @@protoc_insertion_point(field_get:livekit.TrackPermission.all_tracks)
  return _internal_all_tracks();
}
inline void TrackPermission::_internal_set_all_tracks(bool value) {
  
  all_tracks_ = value;
}
inline void TrackPermission::set_all_tracks(bool value) {
  _internal_set_all_tracks(value);
  // @@protoc_insertion_point(field_set:livekit.TrackPermission.all_tracks)
}

// repeated string track_sids = 3;
inline int TrackPermission::_internal_track_sids_size() const {
  return track_sids_.size();
}
inline int TrackPermission::track_sids_size() const {
  return _internal_track_sids_size();
}
inline void TrackPermission::clear_track_sids() {
  track_sids_.Clear();
}
inline std::string* TrackPermission::add_track_sids() {
  std::string* _s = _internal_add_track_sids();
  // @@protoc_insertion_point(field_add_mutable:livekit.TrackPermission.track_sids)
  return _s;
}
inline const std::string& TrackPermission::_internal_track_sids(int index) const {
  return track_sids_.Get(index);
}
inline const std::string& TrackPermission::track_sids(int index) const {
  // @@protoc_insertion_point(field_get:livekit.TrackPermission.track_sids)
  return _internal_track_sids(index);
}
inline std::string* TrackPermission::mutable_track_sids(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.TrackPermission.track_sids)
  return track_sids_.Mutable(index);
}
inline void TrackPermission::set_track_sids(int index, const std::string& value) {
  track_sids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:livekit.TrackPermission.track_sids)
}
inline void TrackPermission::set_track_sids(int index, std::string&& value) {
  track_sids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:livekit.TrackPermission.track_sids)
}
inline void TrackPermission::set_track_sids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  track_sids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:livekit.TrackPermission.track_sids)
}
inline void TrackPermission::set_track_sids(int index, const char* value, size_t size) {
  track_sids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:livekit.TrackPermission.track_sids)
}
inline std::string* TrackPermission::_internal_add_track_sids() {
  return track_sids_.Add();
}
inline void TrackPermission::add_track_sids(const std::string& value) {
  track_sids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:livekit.TrackPermission.track_sids)
}
inline void TrackPermission::add_track_sids(std::string&& value) {
  track_sids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:livekit.TrackPermission.track_sids)
}
inline void TrackPermission::add_track_sids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  track_sids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:livekit.TrackPermission.track_sids)
}
inline void TrackPermission::add_track_sids(const char* value, size_t size) {
  track_sids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:livekit.TrackPermission.track_sids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TrackPermission::track_sids() const {
  // @@protoc_insertion_point(field_list:livekit.TrackPermission.track_sids)
  return track_sids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TrackPermission::mutable_track_sids() {
  // @@protoc_insertion_point(field_mutable_list:livekit.TrackPermission.track_sids)
  return &track_sids_;
}

// string participant_identity = 4;
inline void TrackPermission::clear_participant_identity() {
  participant_identity_.ClearToEmpty();
}
inline const std::string& TrackPermission::participant_identity() const {
  // @@protoc_insertion_point(field_get:livekit.TrackPermission.participant_identity)
  return _internal_participant_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackPermission::set_participant_identity(ArgT0&& arg0, ArgT... args) {
 
 participant_identity_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.TrackPermission.participant_identity)
}
inline std::string* TrackPermission::mutable_participant_identity() {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.TrackPermission.participant_identity)
  return _s;
}
inline const std::string& TrackPermission::_internal_participant_identity() const {
  return participant_identity_.Get();
}
inline void TrackPermission::_internal_set_participant_identity(const std::string& value) {
  
  participant_identity_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TrackPermission::_internal_mutable_participant_identity() {
  
  return participant_identity_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TrackPermission::release_participant_identity() {
  // @@protoc_insertion_point(field_release:livekit.TrackPermission.participant_identity)
  return participant_identity_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TrackPermission::set_allocated_participant_identity(std::string* participant_identity) {
  if (participant_identity != nullptr) {
    
  } else {
    
  }
  participant_identity_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), participant_identity,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (participant_identity_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    participant_identity_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.TrackPermission.participant_identity)
}

// -------------------------------------------------------------------

// SubscriptionPermission

// bool all_participants = 1;
inline void SubscriptionPermission::clear_all_participants() {
  all_participants_ = false;
}
inline bool SubscriptionPermission::_internal_all_participants() const {
  return all_participants_;
}
inline bool SubscriptionPermission::all_participants() const {
  // @@protoc_insertion_point(field_get:livekit.SubscriptionPermission.all_participants)
  return _internal_all_participants();
}
inline void SubscriptionPermission::_internal_set_all_participants(bool value) {
  
  all_participants_ = value;
}
inline void SubscriptionPermission::set_all_participants(bool value) {
  _internal_set_all_participants(value);
  // @@protoc_insertion_point(field_set:livekit.SubscriptionPermission.all_participants)
}

// repeated .livekit.TrackPermission track_permissions = 2;
inline int SubscriptionPermission::_internal_track_permissions_size() const {
  return track_permissions_.size();
}
inline int SubscriptionPermission::track_permissions_size() const {
  return _internal_track_permissions_size();
}
inline void SubscriptionPermission::clear_track_permissions() {
  track_permissions_.Clear();
}
inline ::livekit::TrackPermission* SubscriptionPermission::mutable_track_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.SubscriptionPermission.track_permissions)
  return track_permissions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::TrackPermission >*
SubscriptionPermission::mutable_track_permissions() {
  // @@protoc_insertion_point(field_mutable_list:livekit.SubscriptionPermission.track_permissions)
  return &track_permissions_;
}
inline const ::livekit::TrackPermission& SubscriptionPermission::_internal_track_permissions(int index) const {
  return track_permissions_.Get(index);
}
inline const ::livekit::TrackPermission& SubscriptionPermission::track_permissions(int index) const {
  // @@protoc_insertion_point(field_get:livekit.SubscriptionPermission.track_permissions)
  return _internal_track_permissions(index);
}
inline ::livekit::TrackPermission* SubscriptionPermission::_internal_add_track_permissions() {
  return track_permissions_.Add();
}
inline ::livekit::TrackPermission* SubscriptionPermission::add_track_permissions() {
  ::livekit::TrackPermission* _add = _internal_add_track_permissions();
  // @@protoc_insertion_point(field_add:livekit.SubscriptionPermission.track_permissions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::TrackPermission >&
SubscriptionPermission::track_permissions() const {
  // @@protoc_insertion_point(field_list:livekit.SubscriptionPermission.track_permissions)
  return track_permissions_;
}

// -------------------------------------------------------------------

// SubscriptionPermissionUpdate

// string participant_sid = 1;
inline void SubscriptionPermissionUpdate::clear_participant_sid() {
  participant_sid_.ClearToEmpty();
}
inline const std::string& SubscriptionPermissionUpdate::participant_sid() const {
  // @@protoc_insertion_point(field_get:livekit.SubscriptionPermissionUpdate.participant_sid)
  return _internal_participant_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscriptionPermissionUpdate::set_participant_sid(ArgT0&& arg0, ArgT... args) {
 
 participant_sid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.SubscriptionPermissionUpdate.participant_sid)
}
inline std::string* SubscriptionPermissionUpdate::mutable_participant_sid() {
  std::string* _s = _internal_mutable_participant_sid();
  // @@protoc_insertion_point(field_mutable:livekit.SubscriptionPermissionUpdate.participant_sid)
  return _s;
}
inline const std::string& SubscriptionPermissionUpdate::_internal_participant_sid() const {
  return participant_sid_.Get();
}
inline void SubscriptionPermissionUpdate::_internal_set_participant_sid(const std::string& value) {
  
  participant_sid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SubscriptionPermissionUpdate::_internal_mutable_participant_sid() {
  
  return participant_sid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SubscriptionPermissionUpdate::release_participant_sid() {
  // @@protoc_insertion_point(field_release:livekit.SubscriptionPermissionUpdate.participant_sid)
  return participant_sid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SubscriptionPermissionUpdate::set_allocated_participant_sid(std::string* participant_sid) {
  if (participant_sid != nullptr) {
    
  } else {
    
  }
  participant_sid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), participant_sid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (participant_sid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    participant_sid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.SubscriptionPermissionUpdate.participant_sid)
}

// string track_sid = 2;
inline void SubscriptionPermissionUpdate::clear_track_sid() {
  track_sid_.ClearToEmpty();
}
inline const std::string& SubscriptionPermissionUpdate::track_sid() const {
  // @@protoc_insertion_point(field_get:livekit.SubscriptionPermissionUpdate.track_sid)
  return _internal_track_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscriptionPermissionUpdate::set_track_sid(ArgT0&& arg0, ArgT... args) {
 
 track_sid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.SubscriptionPermissionUpdate.track_sid)
}
inline std::string* SubscriptionPermissionUpdate::mutable_track_sid() {
  std::string* _s = _internal_mutable_track_sid();
  // @@protoc_insertion_point(field_mutable:livekit.SubscriptionPermissionUpdate.track_sid)
  return _s;
}
inline const std::string& SubscriptionPermissionUpdate::_internal_track_sid() const {
  return track_sid_.Get();
}
inline void SubscriptionPermissionUpdate::_internal_set_track_sid(const std::string& value) {
  
  track_sid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SubscriptionPermissionUpdate::_internal_mutable_track_sid() {
  
  return track_sid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SubscriptionPermissionUpdate::release_track_sid() {
  // @@protoc_insertion_point(field_release:livekit.SubscriptionPermissionUpdate.track_sid)
  return track_sid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SubscriptionPermissionUpdate::set_allocated_track_sid(std::string* track_sid) {
  if (track_sid != nullptr) {
    
  } else {
    
  }
  track_sid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), track_sid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (track_sid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    track_sid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.SubscriptionPermissionUpdate.track_sid)
}

// bool allowed = 3;
inline void SubscriptionPermissionUpdate::clear_allowed() {
  allowed_ = false;
}
inline bool SubscriptionPermissionUpdate::_internal_allowed() const {
  return allowed_;
}
inline bool SubscriptionPermissionUpdate::allowed() const {
  // @@protoc_insertion_point(field_get:livekit.SubscriptionPermissionUpdate.allowed)
  return _internal_allowed();
}
inline void SubscriptionPermissionUpdate::_internal_set_allowed(bool value) {
  
  allowed_ = value;
}
inline void SubscriptionPermissionUpdate::set_allowed(bool value) {
  _internal_set_allowed(value);
  // @@protoc_insertion_point(field_set:livekit.SubscriptionPermissionUpdate.allowed)
}

// -------------------------------------------------------------------

// SyncState

// .livekit.SessionDescription answer = 1;
inline bool SyncState::_internal_has_answer() const {
  return this != internal_default_instance() && answer_ != nullptr;
}
inline bool SyncState::has_answer() const {
  return _internal_has_answer();
}
inline void SyncState::clear_answer() {
  if (GetArenaForAllocation() == nullptr && answer_ != nullptr) {
    delete answer_;
  }
  answer_ = nullptr;
}
inline const ::livekit::SessionDescription& SyncState::_internal_answer() const {
  const ::livekit::SessionDescription* p = answer_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::SessionDescription&>(
      ::livekit::_SessionDescription_default_instance_);
}
inline const ::livekit::SessionDescription& SyncState::answer() const {
  // @@protoc_insertion_point(field_get:livekit.SyncState.answer)
  return _internal_answer();
}
inline void SyncState::unsafe_arena_set_allocated_answer(
    ::livekit::SessionDescription* answer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(answer_);
  }
  answer_ = answer;
  if (answer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SyncState.answer)
}
inline ::livekit::SessionDescription* SyncState::release_answer() {
  
  ::livekit::SessionDescription* temp = answer_;
  answer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::SessionDescription* SyncState::unsafe_arena_release_answer() {
  // @@protoc_insertion_point(field_release:livekit.SyncState.answer)
  
  ::livekit::SessionDescription* temp = answer_;
  answer_ = nullptr;
  return temp;
}
inline ::livekit::SessionDescription* SyncState::_internal_mutable_answer() {
  
  if (answer_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::SessionDescription>(GetArenaForAllocation());
    answer_ = p;
  }
  return answer_;
}
inline ::livekit::SessionDescription* SyncState::mutable_answer() {
  ::livekit::SessionDescription* _msg = _internal_mutable_answer();
  // @@protoc_insertion_point(field_mutable:livekit.SyncState.answer)
  return _msg;
}
inline void SyncState::set_allocated_answer(::livekit::SessionDescription* answer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete answer_;
  }
  if (answer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::livekit::SessionDescription>::GetOwningArena(answer);
    if (message_arena != submessage_arena) {
      answer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, answer, submessage_arena);
    }
    
  } else {
    
  }
  answer_ = answer;
  // @@protoc_insertion_point(field_set_allocated:livekit.SyncState.answer)
}

// .livekit.UpdateSubscription subscription = 2;
inline bool SyncState::_internal_has_subscription() const {
  return this != internal_default_instance() && subscription_ != nullptr;
}
inline bool SyncState::has_subscription() const {
  return _internal_has_subscription();
}
inline void SyncState::clear_subscription() {
  if (GetArenaForAllocation() == nullptr && subscription_ != nullptr) {
    delete subscription_;
  }
  subscription_ = nullptr;
}
inline const ::livekit::UpdateSubscription& SyncState::_internal_subscription() const {
  const ::livekit::UpdateSubscription* p = subscription_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::UpdateSubscription&>(
      ::livekit::_UpdateSubscription_default_instance_);
}
inline const ::livekit::UpdateSubscription& SyncState::subscription() const {
  // @@protoc_insertion_point(field_get:livekit.SyncState.subscription)
  return _internal_subscription();
}
inline void SyncState::unsafe_arena_set_allocated_subscription(
    ::livekit::UpdateSubscription* subscription) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subscription_);
  }
  subscription_ = subscription;
  if (subscription) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SyncState.subscription)
}
inline ::livekit::UpdateSubscription* SyncState::release_subscription() {
  
  ::livekit::UpdateSubscription* temp = subscription_;
  subscription_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::UpdateSubscription* SyncState::unsafe_arena_release_subscription() {
  // @@protoc_insertion_point(field_release:livekit.SyncState.subscription)
  
  ::livekit::UpdateSubscription* temp = subscription_;
  subscription_ = nullptr;
  return temp;
}
inline ::livekit::UpdateSubscription* SyncState::_internal_mutable_subscription() {
  
  if (subscription_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::UpdateSubscription>(GetArenaForAllocation());
    subscription_ = p;
  }
  return subscription_;
}
inline ::livekit::UpdateSubscription* SyncState::mutable_subscription() {
  ::livekit::UpdateSubscription* _msg = _internal_mutable_subscription();
  // @@protoc_insertion_point(field_mutable:livekit.SyncState.subscription)
  return _msg;
}
inline void SyncState::set_allocated_subscription(::livekit::UpdateSubscription* subscription) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete subscription_;
  }
  if (subscription) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::livekit::UpdateSubscription>::GetOwningArena(subscription);
    if (message_arena != submessage_arena) {
      subscription = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subscription, submessage_arena);
    }
    
  } else {
    
  }
  subscription_ = subscription;
  // @@protoc_insertion_point(field_set_allocated:livekit.SyncState.subscription)
}

// repeated .livekit.TrackPublishedResponse publish_tracks = 3;
inline int SyncState::_internal_publish_tracks_size() const {
  return publish_tracks_.size();
}
inline int SyncState::publish_tracks_size() const {
  return _internal_publish_tracks_size();
}
inline void SyncState::clear_publish_tracks() {
  publish_tracks_.Clear();
}
inline ::livekit::TrackPublishedResponse* SyncState::mutable_publish_tracks(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.SyncState.publish_tracks)
  return publish_tracks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::TrackPublishedResponse >*
SyncState::mutable_publish_tracks() {
  // @@protoc_insertion_point(field_mutable_list:livekit.SyncState.publish_tracks)
  return &publish_tracks_;
}
inline const ::livekit::TrackPublishedResponse& SyncState::_internal_publish_tracks(int index) const {
  return publish_tracks_.Get(index);
}
inline const ::livekit::TrackPublishedResponse& SyncState::publish_tracks(int index) const {
  // @@protoc_insertion_point(field_get:livekit.SyncState.publish_tracks)
  return _internal_publish_tracks(index);
}
inline ::livekit::TrackPublishedResponse* SyncState::_internal_add_publish_tracks() {
  return publish_tracks_.Add();
}
inline ::livekit::TrackPublishedResponse* SyncState::add_publish_tracks() {
  ::livekit::TrackPublishedResponse* _add = _internal_add_publish_tracks();
  // @@protoc_insertion_point(field_add:livekit.SyncState.publish_tracks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::TrackPublishedResponse >&
SyncState::publish_tracks() const {
  // @@protoc_insertion_point(field_list:livekit.SyncState.publish_tracks)
  return publish_tracks_;
}

// repeated .livekit.DataChannelInfo data_channels = 4;
inline int SyncState::_internal_data_channels_size() const {
  return data_channels_.size();
}
inline int SyncState::data_channels_size() const {
  return _internal_data_channels_size();
}
inline void SyncState::clear_data_channels() {
  data_channels_.Clear();
}
inline ::livekit::DataChannelInfo* SyncState::mutable_data_channels(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.SyncState.data_channels)
  return data_channels_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::DataChannelInfo >*
SyncState::mutable_data_channels() {
  // @@protoc_insertion_point(field_mutable_list:livekit.SyncState.data_channels)
  return &data_channels_;
}
inline const ::livekit::DataChannelInfo& SyncState::_internal_data_channels(int index) const {
  return data_channels_.Get(index);
}
inline const ::livekit::DataChannelInfo& SyncState::data_channels(int index) const {
  // @@protoc_insertion_point(field_get:livekit.SyncState.data_channels)
  return _internal_data_channels(index);
}
inline ::livekit::DataChannelInfo* SyncState::_internal_add_data_channels() {
  return data_channels_.Add();
}
inline ::livekit::DataChannelInfo* SyncState::add_data_channels() {
  ::livekit::DataChannelInfo* _add = _internal_add_data_channels();
  // @@protoc_insertion_point(field_add:livekit.SyncState.data_channels)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::DataChannelInfo >&
SyncState::data_channels() const {
  // @@protoc_insertion_point(field_list:livekit.SyncState.data_channels)
  return data_channels_;
}

// -------------------------------------------------------------------

// DataChannelInfo

// string label = 1;
inline void DataChannelInfo::clear_label() {
  label_.ClearToEmpty();
}
inline const std::string& DataChannelInfo::label() const {
  // @@protoc_insertion_point(field_get:livekit.DataChannelInfo.label)
  return _internal_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataChannelInfo::set_label(ArgT0&& arg0, ArgT... args) {
 
 label_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.DataChannelInfo.label)
}
inline std::string* DataChannelInfo::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:livekit.DataChannelInfo.label)
  return _s;
}
inline const std::string& DataChannelInfo::_internal_label() const {
  return label_.Get();
}
inline void DataChannelInfo::_internal_set_label(const std::string& value) {
  
  label_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DataChannelInfo::_internal_mutable_label() {
  
  return label_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DataChannelInfo::release_label() {
  // @@protoc_insertion_point(field_release:livekit.DataChannelInfo.label)
  return label_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DataChannelInfo::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    
  } else {
    
  }
  label_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), label,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (label_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    label_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.DataChannelInfo.label)
}

// uint32 id = 2;
inline void DataChannelInfo::clear_id() {
  id_ = 0u;
}
inline uint32_t DataChannelInfo::_internal_id() const {
  return id_;
}
inline uint32_t DataChannelInfo::id() const {
  // @@protoc_insertion_point(field_get:livekit.DataChannelInfo.id)
  return _internal_id();
}
inline void DataChannelInfo::_internal_set_id(uint32_t value) {
  
  id_ = value;
}
inline void DataChannelInfo::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:livekit.DataChannelInfo.id)
}

// .livekit.SignalTarget target = 3;
inline void DataChannelInfo::clear_target() {
  target_ = 0;
}
inline ::livekit::SignalTarget DataChannelInfo::_internal_target() const {
  return static_cast< ::livekit::SignalTarget >(target_);
}
inline ::livekit::SignalTarget DataChannelInfo::target() const {
  // @@protoc_insertion_point(field_get:livekit.DataChannelInfo.target)
  return _internal_target();
}
inline void DataChannelInfo::_internal_set_target(::livekit::SignalTarget value) {
  
  target_ = value;
}
inline void DataChannelInfo::set_target(::livekit::SignalTarget value) {
  _internal_set_target(value);
  // @@protoc_insertion_point(field_set:livekit.DataChannelInfo.target)
}

// -------------------------------------------------------------------

// SimulateScenario

// int32 speaker_update = 1;
inline bool SimulateScenario::_internal_has_speaker_update() const {
  return scenario_case() == kSpeakerUpdate;
}
inline bool SimulateScenario::has_speaker_update() const {
  return _internal_has_speaker_update();
}
inline void SimulateScenario::set_has_speaker_update() {
  _oneof_case_[0] = kSpeakerUpdate;
}
inline void SimulateScenario::clear_speaker_update() {
  if (_internal_has_speaker_update()) {
    scenario_.speaker_update_ = 0;
    clear_has_scenario();
  }
}
inline int32_t SimulateScenario::_internal_speaker_update() const {
  if (_internal_has_speaker_update()) {
    return scenario_.speaker_update_;
  }
  return 0;
}
inline void SimulateScenario::_internal_set_speaker_update(int32_t value) {
  if (!_internal_has_speaker_update()) {
    clear_scenario();
    set_has_speaker_update();
  }
  scenario_.speaker_update_ = value;
}
inline int32_t SimulateScenario::speaker_update() const {
  // @@protoc_insertion_point(field_get:livekit.SimulateScenario.speaker_update)
  return _internal_speaker_update();
}
inline void SimulateScenario::set_speaker_update(int32_t value) {
  _internal_set_speaker_update(value);
  // @@protoc_insertion_point(field_set:livekit.SimulateScenario.speaker_update)
}

// bool node_failure = 2;
inline bool SimulateScenario::_internal_has_node_failure() const {
  return scenario_case() == kNodeFailure;
}
inline bool SimulateScenario::has_node_failure() const {
  return _internal_has_node_failure();
}
inline void SimulateScenario::set_has_node_failure() {
  _oneof_case_[0] = kNodeFailure;
}
inline void SimulateScenario::clear_node_failure() {
  if (_internal_has_node_failure()) {
    scenario_.node_failure_ = false;
    clear_has_scenario();
  }
}
inline bool SimulateScenario::_internal_node_failure() const {
  if (_internal_has_node_failure()) {
    return scenario_.node_failure_;
  }
  return false;
}
inline void SimulateScenario::_internal_set_node_failure(bool value) {
  if (!_internal_has_node_failure()) {
    clear_scenario();
    set_has_node_failure();
  }
  scenario_.node_failure_ = value;
}
inline bool SimulateScenario::node_failure() const {
  // @@protoc_insertion_point(field_get:livekit.SimulateScenario.node_failure)
  return _internal_node_failure();
}
inline void SimulateScenario::set_node_failure(bool value) {
  _internal_set_node_failure(value);
  // @@protoc_insertion_point(field_set:livekit.SimulateScenario.node_failure)
}

// bool migration = 3;
inline bool SimulateScenario::_internal_has_migration() const {
  return scenario_case() == kMigration;
}
inline bool SimulateScenario::has_migration() const {
  return _internal_has_migration();
}
inline void SimulateScenario::set_has_migration() {
  _oneof_case_[0] = kMigration;
}
inline void SimulateScenario::clear_migration() {
  if (_internal_has_migration()) {
    scenario_.migration_ = false;
    clear_has_scenario();
  }
}
inline bool SimulateScenario::_internal_migration() const {
  if (_internal_has_migration()) {
    return scenario_.migration_;
  }
  return false;
}
inline void SimulateScenario::_internal_set_migration(bool value) {
  if (!_internal_has_migration()) {
    clear_scenario();
    set_has_migration();
  }
  scenario_.migration_ = value;
}
inline bool SimulateScenario::migration() const {
  // @@protoc_insertion_point(field_get:livekit.SimulateScenario.migration)
  return _internal_migration();
}
inline void SimulateScenario::set_migration(bool value) {
  _internal_set_migration(value);
  // @@protoc_insertion_point(field_set:livekit.SimulateScenario.migration)
}

// bool server_leave = 4;
inline bool SimulateScenario::_internal_has_server_leave() const {
  return scenario_case() == kServerLeave;
}
inline bool SimulateScenario::has_server_leave() const {
  return _internal_has_server_leave();
}
inline void SimulateScenario::set_has_server_leave() {
  _oneof_case_[0] = kServerLeave;
}
inline void SimulateScenario::clear_server_leave() {
  if (_internal_has_server_leave()) {
    scenario_.server_leave_ = false;
    clear_has_scenario();
  }
}
inline bool SimulateScenario::_internal_server_leave() const {
  if (_internal_has_server_leave()) {
    return scenario_.server_leave_;
  }
  return false;
}
inline void SimulateScenario::_internal_set_server_leave(bool value) {
  if (!_internal_has_server_leave()) {
    clear_scenario();
    set_has_server_leave();
  }
  scenario_.server_leave_ = value;
}
inline bool SimulateScenario::server_leave() const {
  // @@protoc_insertion_point(field_get:livekit.SimulateScenario.server_leave)
  return _internal_server_leave();
}
inline void SimulateScenario::set_server_leave(bool value) {
  _internal_set_server_leave(value);
  // @@protoc_insertion_point(field_set:livekit.SimulateScenario.server_leave)
}

inline bool SimulateScenario::has_scenario() const {
  return scenario_case() != SCENARIO_NOT_SET;
}
inline void SimulateScenario::clear_has_scenario() {
  _oneof_case_[0] = SCENARIO_NOT_SET;
}
inline SimulateScenario::ScenarioCase SimulateScenario::scenario_case() const {
  return SimulateScenario::ScenarioCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace livekit

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::livekit::SignalTarget> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::SignalTarget>() {
  return ::livekit::SignalTarget_descriptor();
}
template <> struct is_proto_enum< ::livekit::StreamState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::StreamState>() {
  return ::livekit::StreamState_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_livekit_5frtc_2eproto
