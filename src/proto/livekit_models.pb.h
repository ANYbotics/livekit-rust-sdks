// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: livekit_models.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_livekit_5fmodels_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_livekit_5fmodels_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_livekit_5fmodels_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_livekit_5fmodels_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[16]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_livekit_5fmodels_2eproto;
namespace livekit {
class ActiveSpeakerUpdate;
struct ActiveSpeakerUpdateDefaultTypeInternal;
extern ActiveSpeakerUpdateDefaultTypeInternal _ActiveSpeakerUpdate_default_instance_;
class ClientConfiguration;
struct ClientConfigurationDefaultTypeInternal;
extern ClientConfigurationDefaultTypeInternal _ClientConfiguration_default_instance_;
class ClientInfo;
struct ClientInfoDefaultTypeInternal;
extern ClientInfoDefaultTypeInternal _ClientInfo_default_instance_;
class Codec;
struct CodecDefaultTypeInternal;
extern CodecDefaultTypeInternal _Codec_default_instance_;
class DataPacket;
struct DataPacketDefaultTypeInternal;
extern DataPacketDefaultTypeInternal _DataPacket_default_instance_;
class ParticipantInfo;
struct ParticipantInfoDefaultTypeInternal;
extern ParticipantInfoDefaultTypeInternal _ParticipantInfo_default_instance_;
class ParticipantPermission;
struct ParticipantPermissionDefaultTypeInternal;
extern ParticipantPermissionDefaultTypeInternal _ParticipantPermission_default_instance_;
class ParticipantTracks;
struct ParticipantTracksDefaultTypeInternal;
extern ParticipantTracksDefaultTypeInternal _ParticipantTracks_default_instance_;
class RTPStats;
struct RTPStatsDefaultTypeInternal;
extern RTPStatsDefaultTypeInternal _RTPStats_default_instance_;
class RTPStats_GapHistogramEntry_DoNotUse;
struct RTPStats_GapHistogramEntry_DoNotUseDefaultTypeInternal;
extern RTPStats_GapHistogramEntry_DoNotUseDefaultTypeInternal _RTPStats_GapHistogramEntry_DoNotUse_default_instance_;
class Room;
struct RoomDefaultTypeInternal;
extern RoomDefaultTypeInternal _Room_default_instance_;
class SpeakerInfo;
struct SpeakerInfoDefaultTypeInternal;
extern SpeakerInfoDefaultTypeInternal _SpeakerInfo_default_instance_;
class TrackInfo;
struct TrackInfoDefaultTypeInternal;
extern TrackInfoDefaultTypeInternal _TrackInfo_default_instance_;
class UserPacket;
struct UserPacketDefaultTypeInternal;
extern UserPacketDefaultTypeInternal _UserPacket_default_instance_;
class VideoConfiguration;
struct VideoConfigurationDefaultTypeInternal;
extern VideoConfigurationDefaultTypeInternal _VideoConfiguration_default_instance_;
class VideoLayer;
struct VideoLayerDefaultTypeInternal;
extern VideoLayerDefaultTypeInternal _VideoLayer_default_instance_;
}  // namespace livekit
PROTOBUF_NAMESPACE_OPEN
template<> ::livekit::ActiveSpeakerUpdate* Arena::CreateMaybeMessage<::livekit::ActiveSpeakerUpdate>(Arena*);
template<> ::livekit::ClientConfiguration* Arena::CreateMaybeMessage<::livekit::ClientConfiguration>(Arena*);
template<> ::livekit::ClientInfo* Arena::CreateMaybeMessage<::livekit::ClientInfo>(Arena*);
template<> ::livekit::Codec* Arena::CreateMaybeMessage<::livekit::Codec>(Arena*);
template<> ::livekit::DataPacket* Arena::CreateMaybeMessage<::livekit::DataPacket>(Arena*);
template<> ::livekit::ParticipantInfo* Arena::CreateMaybeMessage<::livekit::ParticipantInfo>(Arena*);
template<> ::livekit::ParticipantPermission* Arena::CreateMaybeMessage<::livekit::ParticipantPermission>(Arena*);
template<> ::livekit::ParticipantTracks* Arena::CreateMaybeMessage<::livekit::ParticipantTracks>(Arena*);
template<> ::livekit::RTPStats* Arena::CreateMaybeMessage<::livekit::RTPStats>(Arena*);
template<> ::livekit::RTPStats_GapHistogramEntry_DoNotUse* Arena::CreateMaybeMessage<::livekit::RTPStats_GapHistogramEntry_DoNotUse>(Arena*);
template<> ::livekit::Room* Arena::CreateMaybeMessage<::livekit::Room>(Arena*);
template<> ::livekit::SpeakerInfo* Arena::CreateMaybeMessage<::livekit::SpeakerInfo>(Arena*);
template<> ::livekit::TrackInfo* Arena::CreateMaybeMessage<::livekit::TrackInfo>(Arena*);
template<> ::livekit::UserPacket* Arena::CreateMaybeMessage<::livekit::UserPacket>(Arena*);
template<> ::livekit::VideoConfiguration* Arena::CreateMaybeMessage<::livekit::VideoConfiguration>(Arena*);
template<> ::livekit::VideoLayer* Arena::CreateMaybeMessage<::livekit::VideoLayer>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace livekit {

enum ParticipantInfo_State : int {
  ParticipantInfo_State_JOINING = 0,
  ParticipantInfo_State_JOINED = 1,
  ParticipantInfo_State_ACTIVE = 2,
  ParticipantInfo_State_DISCONNECTED = 3,
  ParticipantInfo_State_ParticipantInfo_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ParticipantInfo_State_ParticipantInfo_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ParticipantInfo_State_IsValid(int value);
constexpr ParticipantInfo_State ParticipantInfo_State_State_MIN = ParticipantInfo_State_JOINING;
constexpr ParticipantInfo_State ParticipantInfo_State_State_MAX = ParticipantInfo_State_DISCONNECTED;
constexpr int ParticipantInfo_State_State_ARRAYSIZE = ParticipantInfo_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ParticipantInfo_State_descriptor();
template<typename T>
inline const std::string& ParticipantInfo_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ParticipantInfo_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ParticipantInfo_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ParticipantInfo_State_descriptor(), enum_t_value);
}
inline bool ParticipantInfo_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ParticipantInfo_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ParticipantInfo_State>(
    ParticipantInfo_State_descriptor(), name, value);
}
enum DataPacket_Kind : int {
  DataPacket_Kind_RELIABLE = 0,
  DataPacket_Kind_LOSSY = 1,
  DataPacket_Kind_DataPacket_Kind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DataPacket_Kind_DataPacket_Kind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DataPacket_Kind_IsValid(int value);
constexpr DataPacket_Kind DataPacket_Kind_Kind_MIN = DataPacket_Kind_RELIABLE;
constexpr DataPacket_Kind DataPacket_Kind_Kind_MAX = DataPacket_Kind_LOSSY;
constexpr int DataPacket_Kind_Kind_ARRAYSIZE = DataPacket_Kind_Kind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataPacket_Kind_descriptor();
template<typename T>
inline const std::string& DataPacket_Kind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataPacket_Kind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataPacket_Kind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataPacket_Kind_descriptor(), enum_t_value);
}
inline bool DataPacket_Kind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataPacket_Kind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataPacket_Kind>(
    DataPacket_Kind_descriptor(), name, value);
}
enum ClientInfo_SDK : int {
  ClientInfo_SDK_UNKNOWN = 0,
  ClientInfo_SDK_JS = 1,
  ClientInfo_SDK_SWIFT = 2,
  ClientInfo_SDK_ANDROID = 3,
  ClientInfo_SDK_FLUTTER = 4,
  ClientInfo_SDK_GO = 5,
  ClientInfo_SDK_UNITY = 6,
  ClientInfo_SDK_ClientInfo_SDK_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ClientInfo_SDK_ClientInfo_SDK_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ClientInfo_SDK_IsValid(int value);
constexpr ClientInfo_SDK ClientInfo_SDK_SDK_MIN = ClientInfo_SDK_UNKNOWN;
constexpr ClientInfo_SDK ClientInfo_SDK_SDK_MAX = ClientInfo_SDK_UNITY;
constexpr int ClientInfo_SDK_SDK_ARRAYSIZE = ClientInfo_SDK_SDK_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ClientInfo_SDK_descriptor();
template<typename T>
inline const std::string& ClientInfo_SDK_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClientInfo_SDK>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClientInfo_SDK_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ClientInfo_SDK_descriptor(), enum_t_value);
}
inline bool ClientInfo_SDK_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientInfo_SDK* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ClientInfo_SDK>(
    ClientInfo_SDK_descriptor(), name, value);
}
enum TrackType : int {
  AUDIO = 0,
  VIDEO = 1,
  DATA = 2,
  TrackType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TrackType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TrackType_IsValid(int value);
constexpr TrackType TrackType_MIN = AUDIO;
constexpr TrackType TrackType_MAX = DATA;
constexpr int TrackType_ARRAYSIZE = TrackType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrackType_descriptor();
template<typename T>
inline const std::string& TrackType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrackType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrackType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrackType_descriptor(), enum_t_value);
}
inline bool TrackType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TrackType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrackType>(
    TrackType_descriptor(), name, value);
}
enum TrackSource : int {
  UNKNOWN = 0,
  CAMERA = 1,
  MICROPHONE = 2,
  SCREEN_SHARE = 3,
  SCREEN_SHARE_AUDIO = 4,
  TrackSource_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TrackSource_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TrackSource_IsValid(int value);
constexpr TrackSource TrackSource_MIN = UNKNOWN;
constexpr TrackSource TrackSource_MAX = SCREEN_SHARE_AUDIO;
constexpr int TrackSource_ARRAYSIZE = TrackSource_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrackSource_descriptor();
template<typename T>
inline const std::string& TrackSource_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrackSource>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrackSource_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrackSource_descriptor(), enum_t_value);
}
inline bool TrackSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TrackSource* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrackSource>(
    TrackSource_descriptor(), name, value);
}
enum VideoQuality : int {
  LOW = 0,
  MEDIUM = 1,
  HIGH = 2,
  OFF = 3,
  VideoQuality_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  VideoQuality_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool VideoQuality_IsValid(int value);
constexpr VideoQuality VideoQuality_MIN = LOW;
constexpr VideoQuality VideoQuality_MAX = OFF;
constexpr int VideoQuality_ARRAYSIZE = VideoQuality_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VideoQuality_descriptor();
template<typename T>
inline const std::string& VideoQuality_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VideoQuality>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VideoQuality_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VideoQuality_descriptor(), enum_t_value);
}
inline bool VideoQuality_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VideoQuality* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VideoQuality>(
    VideoQuality_descriptor(), name, value);
}
enum ConnectionQuality : int {
  POOR = 0,
  GOOD = 1,
  EXCELLENT = 2,
  ConnectionQuality_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ConnectionQuality_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ConnectionQuality_IsValid(int value);
constexpr ConnectionQuality ConnectionQuality_MIN = POOR;
constexpr ConnectionQuality ConnectionQuality_MAX = EXCELLENT;
constexpr int ConnectionQuality_ARRAYSIZE = ConnectionQuality_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ConnectionQuality_descriptor();
template<typename T>
inline const std::string& ConnectionQuality_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConnectionQuality>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConnectionQuality_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ConnectionQuality_descriptor(), enum_t_value);
}
inline bool ConnectionQuality_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConnectionQuality* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ConnectionQuality>(
    ConnectionQuality_descriptor(), name, value);
}
enum ClientConfigSetting : int {
  UNSET = 0,
  DISABLED = 1,
  ENABLED = 2,
  ClientConfigSetting_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ClientConfigSetting_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ClientConfigSetting_IsValid(int value);
constexpr ClientConfigSetting ClientConfigSetting_MIN = UNSET;
constexpr ClientConfigSetting ClientConfigSetting_MAX = ENABLED;
constexpr int ClientConfigSetting_ARRAYSIZE = ClientConfigSetting_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ClientConfigSetting_descriptor();
template<typename T>
inline const std::string& ClientConfigSetting_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClientConfigSetting>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClientConfigSetting_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ClientConfigSetting_descriptor(), enum_t_value);
}
inline bool ClientConfigSetting_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientConfigSetting* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ClientConfigSetting>(
    ClientConfigSetting_descriptor(), name, value);
}
// ===================================================================

class Room final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.Room) */ {
 public:
  inline Room() : Room(nullptr) {}
  ~Room() override;
  explicit constexpr Room(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Room(const Room& from);
  Room(Room&& from) noexcept
    : Room() {
    *this = ::std::move(from);
  }

  inline Room& operator=(const Room& from) {
    CopyFrom(from);
    return *this;
  }
  inline Room& operator=(Room&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Room& default_instance() {
    return *internal_default_instance();
  }
  static inline const Room* internal_default_instance() {
    return reinterpret_cast<const Room*>(
               &_Room_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Room& a, Room& b) {
    a.Swap(&b);
  }
  inline void Swap(Room* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Room* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Room* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Room>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Room& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Room& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Room* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.Room";
  }
  protected:
  explicit Room(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledCodecsFieldNumber = 7,
    kSidFieldNumber = 1,
    kNameFieldNumber = 2,
    kTurnPasswordFieldNumber = 6,
    kMetadataFieldNumber = 8,
    kEmptyTimeoutFieldNumber = 3,
    kMaxParticipantsFieldNumber = 4,
    kCreationTimeFieldNumber = 5,
    kNumParticipantsFieldNumber = 9,
    kActiveRecordingFieldNumber = 10,
  };
  // repeated .livekit.Codec enabled_codecs = 7;
  int enabled_codecs_size() const;
  private:
  int _internal_enabled_codecs_size() const;
  public:
  void clear_enabled_codecs();
  ::livekit::Codec* mutable_enabled_codecs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::Codec >*
      mutable_enabled_codecs();
  private:
  const ::livekit::Codec& _internal_enabled_codecs(int index) const;
  ::livekit::Codec* _internal_add_enabled_codecs();
  public:
  const ::livekit::Codec& enabled_codecs(int index) const;
  ::livekit::Codec* add_enabled_codecs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::Codec >&
      enabled_codecs() const;

  // string sid = 1;
  void clear_sid();
  const std::string& sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sid();
  PROTOBUF_NODISCARD std::string* release_sid();
  void set_allocated_sid(std::string* sid);
  private:
  const std::string& _internal_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sid(const std::string& value);
  std::string* _internal_mutable_sid();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string turn_password = 6;
  void clear_turn_password();
  const std::string& turn_password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_turn_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_turn_password();
  PROTOBUF_NODISCARD std::string* release_turn_password();
  void set_allocated_turn_password(std::string* turn_password);
  private:
  const std::string& _internal_turn_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_turn_password(const std::string& value);
  std::string* _internal_mutable_turn_password();
  public:

  // string metadata = 8;
  void clear_metadata();
  const std::string& metadata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_metadata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_metadata();
  PROTOBUF_NODISCARD std::string* release_metadata();
  void set_allocated_metadata(std::string* metadata);
  private:
  const std::string& _internal_metadata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metadata(const std::string& value);
  std::string* _internal_mutable_metadata();
  public:

  // uint32 empty_timeout = 3;
  void clear_empty_timeout();
  uint32_t empty_timeout() const;
  void set_empty_timeout(uint32_t value);
  private:
  uint32_t _internal_empty_timeout() const;
  void _internal_set_empty_timeout(uint32_t value);
  public:

  // uint32 max_participants = 4;
  void clear_max_participants();
  uint32_t max_participants() const;
  void set_max_participants(uint32_t value);
  private:
  uint32_t _internal_max_participants() const;
  void _internal_set_max_participants(uint32_t value);
  public:

  // int64 creation_time = 5;
  void clear_creation_time();
  int64_t creation_time() const;
  void set_creation_time(int64_t value);
  private:
  int64_t _internal_creation_time() const;
  void _internal_set_creation_time(int64_t value);
  public:

  // uint32 num_participants = 9;
  void clear_num_participants();
  uint32_t num_participants() const;
  void set_num_participants(uint32_t value);
  private:
  uint32_t _internal_num_participants() const;
  void _internal_set_num_participants(uint32_t value);
  public:

  // bool active_recording = 10;
  void clear_active_recording();
  bool active_recording() const;
  void set_active_recording(bool value);
  private:
  bool _internal_active_recording() const;
  void _internal_set_active_recording(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.Room)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::Codec > enabled_codecs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr turn_password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr metadata_;
  uint32_t empty_timeout_;
  uint32_t max_participants_;
  int64_t creation_time_;
  uint32_t num_participants_;
  bool active_recording_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class Codec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.Codec) */ {
 public:
  inline Codec() : Codec(nullptr) {}
  ~Codec() override;
  explicit constexpr Codec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Codec(const Codec& from);
  Codec(Codec&& from) noexcept
    : Codec() {
    *this = ::std::move(from);
  }

  inline Codec& operator=(const Codec& from) {
    CopyFrom(from);
    return *this;
  }
  inline Codec& operator=(Codec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Codec& default_instance() {
    return *internal_default_instance();
  }
  static inline const Codec* internal_default_instance() {
    return reinterpret_cast<const Codec*>(
               &_Codec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Codec& a, Codec& b) {
    a.Swap(&b);
  }
  inline void Swap(Codec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Codec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Codec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Codec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Codec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Codec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Codec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.Codec";
  }
  protected:
  explicit Codec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMimeFieldNumber = 1,
    kFmtpLineFieldNumber = 2,
  };
  // string mime = 1;
  void clear_mime();
  const std::string& mime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mime();
  PROTOBUF_NODISCARD std::string* release_mime();
  void set_allocated_mime(std::string* mime);
  private:
  const std::string& _internal_mime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mime(const std::string& value);
  std::string* _internal_mutable_mime();
  public:

  // string fmtp_line = 2;
  void clear_fmtp_line();
  const std::string& fmtp_line() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fmtp_line(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fmtp_line();
  PROTOBUF_NODISCARD std::string* release_fmtp_line();
  void set_allocated_fmtp_line(std::string* fmtp_line);
  private:
  const std::string& _internal_fmtp_line() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fmtp_line(const std::string& value);
  std::string* _internal_mutable_fmtp_line();
  public:

  // @@protoc_insertion_point(class_scope:livekit.Codec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fmtp_line_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class ParticipantPermission final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.ParticipantPermission) */ {
 public:
  inline ParticipantPermission() : ParticipantPermission(nullptr) {}
  ~ParticipantPermission() override;
  explicit constexpr ParticipantPermission(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ParticipantPermission(const ParticipantPermission& from);
  ParticipantPermission(ParticipantPermission&& from) noexcept
    : ParticipantPermission() {
    *this = ::std::move(from);
  }

  inline ParticipantPermission& operator=(const ParticipantPermission& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParticipantPermission& operator=(ParticipantPermission&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParticipantPermission& default_instance() {
    return *internal_default_instance();
  }
  static inline const ParticipantPermission* internal_default_instance() {
    return reinterpret_cast<const ParticipantPermission*>(
               &_ParticipantPermission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ParticipantPermission& a, ParticipantPermission& b) {
    a.Swap(&b);
  }
  inline void Swap(ParticipantPermission* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParticipantPermission* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ParticipantPermission* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ParticipantPermission>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ParticipantPermission& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ParticipantPermission& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParticipantPermission* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.ParticipantPermission";
  }
  protected:
  explicit ParticipantPermission(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCanSubscribeFieldNumber = 1,
    kCanPublishFieldNumber = 2,
    kCanPublishDataFieldNumber = 3,
    kHiddenFieldNumber = 7,
    kRecorderFieldNumber = 8,
  };
  // bool can_subscribe = 1;
  void clear_can_subscribe();
  bool can_subscribe() const;
  void set_can_subscribe(bool value);
  private:
  bool _internal_can_subscribe() const;
  void _internal_set_can_subscribe(bool value);
  public:

  // bool can_publish = 2;
  void clear_can_publish();
  bool can_publish() const;
  void set_can_publish(bool value);
  private:
  bool _internal_can_publish() const;
  void _internal_set_can_publish(bool value);
  public:

  // bool can_publish_data = 3;
  void clear_can_publish_data();
  bool can_publish_data() const;
  void set_can_publish_data(bool value);
  private:
  bool _internal_can_publish_data() const;
  void _internal_set_can_publish_data(bool value);
  public:

  // bool hidden = 7;
  void clear_hidden();
  bool hidden() const;
  void set_hidden(bool value);
  private:
  bool _internal_hidden() const;
  void _internal_set_hidden(bool value);
  public:

  // bool recorder = 8;
  void clear_recorder();
  bool recorder() const;
  void set_recorder(bool value);
  private:
  bool _internal_recorder() const;
  void _internal_set_recorder(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.ParticipantPermission)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool can_subscribe_;
  bool can_publish_;
  bool can_publish_data_;
  bool hidden_;
  bool recorder_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class ParticipantInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.ParticipantInfo) */ {
 public:
  inline ParticipantInfo() : ParticipantInfo(nullptr) {}
  ~ParticipantInfo() override;
  explicit constexpr ParticipantInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ParticipantInfo(const ParticipantInfo& from);
  ParticipantInfo(ParticipantInfo&& from) noexcept
    : ParticipantInfo() {
    *this = ::std::move(from);
  }

  inline ParticipantInfo& operator=(const ParticipantInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParticipantInfo& operator=(ParticipantInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParticipantInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ParticipantInfo* internal_default_instance() {
    return reinterpret_cast<const ParticipantInfo*>(
               &_ParticipantInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ParticipantInfo& a, ParticipantInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ParticipantInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParticipantInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ParticipantInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ParticipantInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ParticipantInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ParticipantInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParticipantInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.ParticipantInfo";
  }
  protected:
  explicit ParticipantInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ParticipantInfo_State State;
  static constexpr State JOINING =
    ParticipantInfo_State_JOINING;
  static constexpr State JOINED =
    ParticipantInfo_State_JOINED;
  static constexpr State ACTIVE =
    ParticipantInfo_State_ACTIVE;
  static constexpr State DISCONNECTED =
    ParticipantInfo_State_DISCONNECTED;
  static inline bool State_IsValid(int value) {
    return ParticipantInfo_State_IsValid(value);
  }
  static constexpr State State_MIN =
    ParticipantInfo_State_State_MIN;
  static constexpr State State_MAX =
    ParticipantInfo_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    ParticipantInfo_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return ParticipantInfo_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return ParticipantInfo_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return ParticipantInfo_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTracksFieldNumber = 4,
    kSidFieldNumber = 1,
    kIdentityFieldNumber = 2,
    kMetadataFieldNumber = 5,
    kNameFieldNumber = 9,
    kRegionFieldNumber = 12,
    kPermissionFieldNumber = 11,
    kJoinedAtFieldNumber = 6,
    kStateFieldNumber = 3,
    kVersionFieldNumber = 10,
    kIsPublisherFieldNumber = 13,
  };
  // repeated .livekit.TrackInfo tracks = 4;
  int tracks_size() const;
  private:
  int _internal_tracks_size() const;
  public:
  void clear_tracks();
  ::livekit::TrackInfo* mutable_tracks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::TrackInfo >*
      mutable_tracks();
  private:
  const ::livekit::TrackInfo& _internal_tracks(int index) const;
  ::livekit::TrackInfo* _internal_add_tracks();
  public:
  const ::livekit::TrackInfo& tracks(int index) const;
  ::livekit::TrackInfo* add_tracks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::TrackInfo >&
      tracks() const;

  // string sid = 1;
  void clear_sid();
  const std::string& sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sid();
  PROTOBUF_NODISCARD std::string* release_sid();
  void set_allocated_sid(std::string* sid);
  private:
  const std::string& _internal_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sid(const std::string& value);
  std::string* _internal_mutable_sid();
  public:

  // string identity = 2;
  void clear_identity();
  const std::string& identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identity();
  PROTOBUF_NODISCARD std::string* release_identity();
  void set_allocated_identity(std::string* identity);
  private:
  const std::string& _internal_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identity(const std::string& value);
  std::string* _internal_mutable_identity();
  public:

  // string metadata = 5;
  void clear_metadata();
  const std::string& metadata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_metadata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_metadata();
  PROTOBUF_NODISCARD std::string* release_metadata();
  void set_allocated_metadata(std::string* metadata);
  private:
  const std::string& _internal_metadata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metadata(const std::string& value);
  std::string* _internal_mutable_metadata();
  public:

  // string name = 9;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string region = 12;
  void clear_region();
  const std::string& region() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_region(ArgT0&& arg0, ArgT... args);
  std::string* mutable_region();
  PROTOBUF_NODISCARD std::string* release_region();
  void set_allocated_region(std::string* region);
  private:
  const std::string& _internal_region() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region(const std::string& value);
  std::string* _internal_mutable_region();
  public:

  // .livekit.ParticipantPermission permission = 11;
  bool has_permission() const;
  private:
  bool _internal_has_permission() const;
  public:
  void clear_permission();
  const ::livekit::ParticipantPermission& permission() const;
  PROTOBUF_NODISCARD ::livekit::ParticipantPermission* release_permission();
  ::livekit::ParticipantPermission* mutable_permission();
  void set_allocated_permission(::livekit::ParticipantPermission* permission);
  private:
  const ::livekit::ParticipantPermission& _internal_permission() const;
  ::livekit::ParticipantPermission* _internal_mutable_permission();
  public:
  void unsafe_arena_set_allocated_permission(
      ::livekit::ParticipantPermission* permission);
  ::livekit::ParticipantPermission* unsafe_arena_release_permission();

  // int64 joined_at = 6;
  void clear_joined_at();
  int64_t joined_at() const;
  void set_joined_at(int64_t value);
  private:
  int64_t _internal_joined_at() const;
  void _internal_set_joined_at(int64_t value);
  public:

  // .livekit.ParticipantInfo.State state = 3;
  void clear_state();
  ::livekit::ParticipantInfo_State state() const;
  void set_state(::livekit::ParticipantInfo_State value);
  private:
  ::livekit::ParticipantInfo_State _internal_state() const;
  void _internal_set_state(::livekit::ParticipantInfo_State value);
  public:

  // uint32 version = 10;
  void clear_version();
  uint32_t version() const;
  void set_version(uint32_t value);
  private:
  uint32_t _internal_version() const;
  void _internal_set_version(uint32_t value);
  public:

  // bool is_publisher = 13;
  void clear_is_publisher();
  bool is_publisher() const;
  void set_is_publisher(bool value);
  private:
  bool _internal_is_publisher() const;
  void _internal_set_is_publisher(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.ParticipantInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::TrackInfo > tracks_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identity_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
  ::livekit::ParticipantPermission* permission_;
  int64_t joined_at_;
  int state_;
  uint32_t version_;
  bool is_publisher_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class TrackInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.TrackInfo) */ {
 public:
  inline TrackInfo() : TrackInfo(nullptr) {}
  ~TrackInfo() override;
  explicit constexpr TrackInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrackInfo(const TrackInfo& from);
  TrackInfo(TrackInfo&& from) noexcept
    : TrackInfo() {
    *this = ::std::move(from);
  }

  inline TrackInfo& operator=(const TrackInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackInfo& operator=(TrackInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackInfo* internal_default_instance() {
    return reinterpret_cast<const TrackInfo*>(
               &_TrackInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TrackInfo& a, TrackInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrackInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TrackInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.TrackInfo";
  }
  protected:
  explicit TrackInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLayersFieldNumber = 10,
    kSidFieldNumber = 1,
    kNameFieldNumber = 3,
    kMimeTypeFieldNumber = 11,
    kMidFieldNumber = 12,
    kTypeFieldNumber = 2,
    kWidthFieldNumber = 5,
    kHeightFieldNumber = 6,
    kMutedFieldNumber = 4,
    kSimulcastFieldNumber = 7,
    kDisableDtxFieldNumber = 8,
    kSourceFieldNumber = 9,
  };
  // repeated .livekit.VideoLayer layers = 10;
  int layers_size() const;
  private:
  int _internal_layers_size() const;
  public:
  void clear_layers();
  ::livekit::VideoLayer* mutable_layers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::VideoLayer >*
      mutable_layers();
  private:
  const ::livekit::VideoLayer& _internal_layers(int index) const;
  ::livekit::VideoLayer* _internal_add_layers();
  public:
  const ::livekit::VideoLayer& layers(int index) const;
  ::livekit::VideoLayer* add_layers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::VideoLayer >&
      layers() const;

  // string sid = 1;
  void clear_sid();
  const std::string& sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sid();
  PROTOBUF_NODISCARD std::string* release_sid();
  void set_allocated_sid(std::string* sid);
  private:
  const std::string& _internal_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sid(const std::string& value);
  std::string* _internal_mutable_sid();
  public:

  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string mime_type = 11;
  void clear_mime_type();
  const std::string& mime_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mime_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mime_type();
  PROTOBUF_NODISCARD std::string* release_mime_type();
  void set_allocated_mime_type(std::string* mime_type);
  private:
  const std::string& _internal_mime_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mime_type(const std::string& value);
  std::string* _internal_mutable_mime_type();
  public:

  // string mid = 12;
  void clear_mid();
  const std::string& mid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mid();
  PROTOBUF_NODISCARD std::string* release_mid();
  void set_allocated_mid(std::string* mid);
  private:
  const std::string& _internal_mid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mid(const std::string& value);
  std::string* _internal_mutable_mid();
  public:

  // .livekit.TrackType type = 2;
  void clear_type();
  ::livekit::TrackType type() const;
  void set_type(::livekit::TrackType value);
  private:
  ::livekit::TrackType _internal_type() const;
  void _internal_set_type(::livekit::TrackType value);
  public:

  // uint32 width = 5;
  void clear_width();
  uint32_t width() const;
  void set_width(uint32_t value);
  private:
  uint32_t _internal_width() const;
  void _internal_set_width(uint32_t value);
  public:

  // uint32 height = 6;
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // bool muted = 4;
  void clear_muted();
  bool muted() const;
  void set_muted(bool value);
  private:
  bool _internal_muted() const;
  void _internal_set_muted(bool value);
  public:

  // bool simulcast = 7;
  void clear_simulcast();
  bool simulcast() const;
  void set_simulcast(bool value);
  private:
  bool _internal_simulcast() const;
  void _internal_set_simulcast(bool value);
  public:

  // bool disable_dtx = 8;
  void clear_disable_dtx();
  bool disable_dtx() const;
  void set_disable_dtx(bool value);
  private:
  bool _internal_disable_dtx() const;
  void _internal_set_disable_dtx(bool value);
  public:

  // .livekit.TrackSource source = 9;
  void clear_source();
  ::livekit::TrackSource source() const;
  void set_source(::livekit::TrackSource value);
  private:
  ::livekit::TrackSource _internal_source() const;
  void _internal_set_source(::livekit::TrackSource value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.TrackInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::VideoLayer > layers_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mid_;
  int type_;
  uint32_t width_;
  uint32_t height_;
  bool muted_;
  bool simulcast_;
  bool disable_dtx_;
  int source_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class VideoLayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.VideoLayer) */ {
 public:
  inline VideoLayer() : VideoLayer(nullptr) {}
  ~VideoLayer() override;
  explicit constexpr VideoLayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoLayer(const VideoLayer& from);
  VideoLayer(VideoLayer&& from) noexcept
    : VideoLayer() {
    *this = ::std::move(from);
  }

  inline VideoLayer& operator=(const VideoLayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoLayer& operator=(VideoLayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoLayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoLayer* internal_default_instance() {
    return reinterpret_cast<const VideoLayer*>(
               &_VideoLayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(VideoLayer& a, VideoLayer& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoLayer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoLayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoLayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoLayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VideoLayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VideoLayer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoLayer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.VideoLayer";
  }
  protected:
  explicit VideoLayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQualityFieldNumber = 1,
    kWidthFieldNumber = 2,
    kHeightFieldNumber = 3,
    kBitrateFieldNumber = 4,
    kSsrcFieldNumber = 5,
  };
  // .livekit.VideoQuality quality = 1;
  void clear_quality();
  ::livekit::VideoQuality quality() const;
  void set_quality(::livekit::VideoQuality value);
  private:
  ::livekit::VideoQuality _internal_quality() const;
  void _internal_set_quality(::livekit::VideoQuality value);
  public:

  // uint32 width = 2;
  void clear_width();
  uint32_t width() const;
  void set_width(uint32_t value);
  private:
  uint32_t _internal_width() const;
  void _internal_set_width(uint32_t value);
  public:

  // uint32 height = 3;
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // uint32 bitrate = 4;
  void clear_bitrate();
  uint32_t bitrate() const;
  void set_bitrate(uint32_t value);
  private:
  uint32_t _internal_bitrate() const;
  void _internal_set_bitrate(uint32_t value);
  public:

  // uint32 ssrc = 5;
  void clear_ssrc();
  uint32_t ssrc() const;
  void set_ssrc(uint32_t value);
  private:
  uint32_t _internal_ssrc() const;
  void _internal_set_ssrc(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.VideoLayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int quality_;
  uint32_t width_;
  uint32_t height_;
  uint32_t bitrate_;
  uint32_t ssrc_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class DataPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.DataPacket) */ {
 public:
  inline DataPacket() : DataPacket(nullptr) {}
  ~DataPacket() override;
  explicit constexpr DataPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataPacket(const DataPacket& from);
  DataPacket(DataPacket&& from) noexcept
    : DataPacket() {
    *this = ::std::move(from);
  }

  inline DataPacket& operator=(const DataPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataPacket& operator=(DataPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataPacket& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kUser = 2,
    kSpeaker = 3,
    VALUE_NOT_SET = 0,
  };

  static inline const DataPacket* internal_default_instance() {
    return reinterpret_cast<const DataPacket*>(
               &_DataPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DataPacket& a, DataPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(DataPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DataPacket& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.DataPacket";
  }
  protected:
  explicit DataPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DataPacket_Kind Kind;
  static constexpr Kind RELIABLE =
    DataPacket_Kind_RELIABLE;
  static constexpr Kind LOSSY =
    DataPacket_Kind_LOSSY;
  static inline bool Kind_IsValid(int value) {
    return DataPacket_Kind_IsValid(value);
  }
  static constexpr Kind Kind_MIN =
    DataPacket_Kind_Kind_MIN;
  static constexpr Kind Kind_MAX =
    DataPacket_Kind_Kind_MAX;
  static constexpr int Kind_ARRAYSIZE =
    DataPacket_Kind_Kind_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Kind_descriptor() {
    return DataPacket_Kind_descriptor();
  }
  template<typename T>
  static inline const std::string& Kind_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Kind>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Kind_Name.");
    return DataPacket_Kind_Name(enum_t_value);
  }
  static inline bool Kind_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Kind* value) {
    return DataPacket_Kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kKindFieldNumber = 1,
    kUserFieldNumber = 2,
    kSpeakerFieldNumber = 3,
  };
  // .livekit.DataPacket.Kind kind = 1;
  void clear_kind();
  ::livekit::DataPacket_Kind kind() const;
  void set_kind(::livekit::DataPacket_Kind value);
  private:
  ::livekit::DataPacket_Kind _internal_kind() const;
  void _internal_set_kind(::livekit::DataPacket_Kind value);
  public:

  // .livekit.UserPacket user = 2;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::livekit::UserPacket& user() const;
  PROTOBUF_NODISCARD ::livekit::UserPacket* release_user();
  ::livekit::UserPacket* mutable_user();
  void set_allocated_user(::livekit::UserPacket* user);
  private:
  const ::livekit::UserPacket& _internal_user() const;
  ::livekit::UserPacket* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::livekit::UserPacket* user);
  ::livekit::UserPacket* unsafe_arena_release_user();

  // .livekit.ActiveSpeakerUpdate speaker = 3;
  bool has_speaker() const;
  private:
  bool _internal_has_speaker() const;
  public:
  void clear_speaker();
  const ::livekit::ActiveSpeakerUpdate& speaker() const;
  PROTOBUF_NODISCARD ::livekit::ActiveSpeakerUpdate* release_speaker();
  ::livekit::ActiveSpeakerUpdate* mutable_speaker();
  void set_allocated_speaker(::livekit::ActiveSpeakerUpdate* speaker);
  private:
  const ::livekit::ActiveSpeakerUpdate& _internal_speaker() const;
  ::livekit::ActiveSpeakerUpdate* _internal_mutable_speaker();
  public:
  void unsafe_arena_set_allocated_speaker(
      ::livekit::ActiveSpeakerUpdate* speaker);
  ::livekit::ActiveSpeakerUpdate* unsafe_arena_release_speaker();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:livekit.DataPacket)
 private:
  class _Internal;
  void set_has_user();
  void set_has_speaker();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int kind_;
  union ValueUnion {
    constexpr ValueUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::livekit::UserPacket* user_;
    ::livekit::ActiveSpeakerUpdate* speaker_;
  } value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class ActiveSpeakerUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.ActiveSpeakerUpdate) */ {
 public:
  inline ActiveSpeakerUpdate() : ActiveSpeakerUpdate(nullptr) {}
  ~ActiveSpeakerUpdate() override;
  explicit constexpr ActiveSpeakerUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActiveSpeakerUpdate(const ActiveSpeakerUpdate& from);
  ActiveSpeakerUpdate(ActiveSpeakerUpdate&& from) noexcept
    : ActiveSpeakerUpdate() {
    *this = ::std::move(from);
  }

  inline ActiveSpeakerUpdate& operator=(const ActiveSpeakerUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActiveSpeakerUpdate& operator=(ActiveSpeakerUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActiveSpeakerUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActiveSpeakerUpdate* internal_default_instance() {
    return reinterpret_cast<const ActiveSpeakerUpdate*>(
               &_ActiveSpeakerUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ActiveSpeakerUpdate& a, ActiveSpeakerUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(ActiveSpeakerUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActiveSpeakerUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActiveSpeakerUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActiveSpeakerUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActiveSpeakerUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ActiveSpeakerUpdate& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActiveSpeakerUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.ActiveSpeakerUpdate";
  }
  protected:
  explicit ActiveSpeakerUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpeakersFieldNumber = 1,
  };
  // repeated .livekit.SpeakerInfo speakers = 1;
  int speakers_size() const;
  private:
  int _internal_speakers_size() const;
  public:
  void clear_speakers();
  ::livekit::SpeakerInfo* mutable_speakers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SpeakerInfo >*
      mutable_speakers();
  private:
  const ::livekit::SpeakerInfo& _internal_speakers(int index) const;
  ::livekit::SpeakerInfo* _internal_add_speakers();
  public:
  const ::livekit::SpeakerInfo& speakers(int index) const;
  ::livekit::SpeakerInfo* add_speakers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SpeakerInfo >&
      speakers() const;

  // @@protoc_insertion_point(class_scope:livekit.ActiveSpeakerUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SpeakerInfo > speakers_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class SpeakerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.SpeakerInfo) */ {
 public:
  inline SpeakerInfo() : SpeakerInfo(nullptr) {}
  ~SpeakerInfo() override;
  explicit constexpr SpeakerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpeakerInfo(const SpeakerInfo& from);
  SpeakerInfo(SpeakerInfo&& from) noexcept
    : SpeakerInfo() {
    *this = ::std::move(from);
  }

  inline SpeakerInfo& operator=(const SpeakerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpeakerInfo& operator=(SpeakerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpeakerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpeakerInfo* internal_default_instance() {
    return reinterpret_cast<const SpeakerInfo*>(
               &_SpeakerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SpeakerInfo& a, SpeakerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SpeakerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpeakerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpeakerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpeakerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpeakerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SpeakerInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpeakerInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.SpeakerInfo";
  }
  protected:
  explicit SpeakerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSidFieldNumber = 1,
    kLevelFieldNumber = 2,
    kActiveFieldNumber = 3,
  };
  // string sid = 1;
  void clear_sid();
  const std::string& sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sid();
  PROTOBUF_NODISCARD std::string* release_sid();
  void set_allocated_sid(std::string* sid);
  private:
  const std::string& _internal_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sid(const std::string& value);
  std::string* _internal_mutable_sid();
  public:

  // float level = 2;
  void clear_level();
  float level() const;
  void set_level(float value);
  private:
  float _internal_level() const;
  void _internal_set_level(float value);
  public:

  // bool active = 3;
  void clear_active();
  bool active() const;
  void set_active(bool value);
  private:
  bool _internal_active() const;
  void _internal_set_active(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.SpeakerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sid_;
  float level_;
  bool active_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class UserPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.UserPacket) */ {
 public:
  inline UserPacket() : UserPacket(nullptr) {}
  ~UserPacket() override;
  explicit constexpr UserPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserPacket(const UserPacket& from);
  UserPacket(UserPacket&& from) noexcept
    : UserPacket() {
    *this = ::std::move(from);
  }

  inline UserPacket& operator=(const UserPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserPacket& operator=(UserPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserPacket* internal_default_instance() {
    return reinterpret_cast<const UserPacket*>(
               &_UserPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UserPacket& a, UserPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(UserPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserPacket& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.UserPacket";
  }
  protected:
  explicit UserPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDestinationSidsFieldNumber = 3,
    kParticipantSidFieldNumber = 1,
    kPayloadFieldNumber = 2,
  };
  // repeated string destination_sids = 3;
  int destination_sids_size() const;
  private:
  int _internal_destination_sids_size() const;
  public:
  void clear_destination_sids();
  const std::string& destination_sids(int index) const;
  std::string* mutable_destination_sids(int index);
  void set_destination_sids(int index, const std::string& value);
  void set_destination_sids(int index, std::string&& value);
  void set_destination_sids(int index, const char* value);
  void set_destination_sids(int index, const char* value, size_t size);
  std::string* add_destination_sids();
  void add_destination_sids(const std::string& value);
  void add_destination_sids(std::string&& value);
  void add_destination_sids(const char* value);
  void add_destination_sids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& destination_sids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_destination_sids();
  private:
  const std::string& _internal_destination_sids(int index) const;
  std::string* _internal_add_destination_sids();
  public:

  // string participant_sid = 1;
  void clear_participant_sid();
  const std::string& participant_sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_sid();
  PROTOBUF_NODISCARD std::string* release_participant_sid();
  void set_allocated_participant_sid(std::string* participant_sid);
  private:
  const std::string& _internal_participant_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_sid(const std::string& value);
  std::string* _internal_mutable_participant_sid();
  public:

  // bytes payload = 2;
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // @@protoc_insertion_point(class_scope:livekit.UserPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> destination_sids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_sid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class ParticipantTracks final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.ParticipantTracks) */ {
 public:
  inline ParticipantTracks() : ParticipantTracks(nullptr) {}
  ~ParticipantTracks() override;
  explicit constexpr ParticipantTracks(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ParticipantTracks(const ParticipantTracks& from);
  ParticipantTracks(ParticipantTracks&& from) noexcept
    : ParticipantTracks() {
    *this = ::std::move(from);
  }

  inline ParticipantTracks& operator=(const ParticipantTracks& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParticipantTracks& operator=(ParticipantTracks&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParticipantTracks& default_instance() {
    return *internal_default_instance();
  }
  static inline const ParticipantTracks* internal_default_instance() {
    return reinterpret_cast<const ParticipantTracks*>(
               &_ParticipantTracks_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ParticipantTracks& a, ParticipantTracks& b) {
    a.Swap(&b);
  }
  inline void Swap(ParticipantTracks* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParticipantTracks* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ParticipantTracks* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ParticipantTracks>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ParticipantTracks& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ParticipantTracks& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParticipantTracks* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.ParticipantTracks";
  }
  protected:
  explicit ParticipantTracks(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrackSidsFieldNumber = 2,
    kParticipantSidFieldNumber = 1,
  };
  // repeated string track_sids = 2;
  int track_sids_size() const;
  private:
  int _internal_track_sids_size() const;
  public:
  void clear_track_sids();
  const std::string& track_sids(int index) const;
  std::string* mutable_track_sids(int index);
  void set_track_sids(int index, const std::string& value);
  void set_track_sids(int index, std::string&& value);
  void set_track_sids(int index, const char* value);
  void set_track_sids(int index, const char* value, size_t size);
  std::string* add_track_sids();
  void add_track_sids(const std::string& value);
  void add_track_sids(std::string&& value);
  void add_track_sids(const char* value);
  void add_track_sids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& track_sids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_track_sids();
  private:
  const std::string& _internal_track_sids(int index) const;
  std::string* _internal_add_track_sids();
  public:

  // string participant_sid = 1;
  void clear_participant_sid();
  const std::string& participant_sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_sid();
  PROTOBUF_NODISCARD std::string* release_participant_sid();
  void set_allocated_participant_sid(std::string* participant_sid);
  private:
  const std::string& _internal_participant_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_sid(const std::string& value);
  std::string* _internal_mutable_participant_sid();
  public:

  // @@protoc_insertion_point(class_scope:livekit.ParticipantTracks)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> track_sids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_sid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class ClientInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.ClientInfo) */ {
 public:
  inline ClientInfo() : ClientInfo(nullptr) {}
  ~ClientInfo() override;
  explicit constexpr ClientInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientInfo(const ClientInfo& from);
  ClientInfo(ClientInfo&& from) noexcept
    : ClientInfo() {
    *this = ::std::move(from);
  }

  inline ClientInfo& operator=(const ClientInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientInfo& operator=(ClientInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientInfo* internal_default_instance() {
    return reinterpret_cast<const ClientInfo*>(
               &_ClientInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ClientInfo& a, ClientInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ClientInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.ClientInfo";
  }
  protected:
  explicit ClientInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ClientInfo_SDK SDK;
  static constexpr SDK UNKNOWN =
    ClientInfo_SDK_UNKNOWN;
  static constexpr SDK JS =
    ClientInfo_SDK_JS;
  static constexpr SDK SWIFT =
    ClientInfo_SDK_SWIFT;
  static constexpr SDK ANDROID =
    ClientInfo_SDK_ANDROID;
  static constexpr SDK FLUTTER =
    ClientInfo_SDK_FLUTTER;
  static constexpr SDK GO =
    ClientInfo_SDK_GO;
  static constexpr SDK UNITY =
    ClientInfo_SDK_UNITY;
  static inline bool SDK_IsValid(int value) {
    return ClientInfo_SDK_IsValid(value);
  }
  static constexpr SDK SDK_MIN =
    ClientInfo_SDK_SDK_MIN;
  static constexpr SDK SDK_MAX =
    ClientInfo_SDK_SDK_MAX;
  static constexpr int SDK_ARRAYSIZE =
    ClientInfo_SDK_SDK_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SDK_descriptor() {
    return ClientInfo_SDK_descriptor();
  }
  template<typename T>
  static inline const std::string& SDK_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SDK>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SDK_Name.");
    return ClientInfo_SDK_Name(enum_t_value);
  }
  static inline bool SDK_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SDK* value) {
    return ClientInfo_SDK_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 2,
    kOsFieldNumber = 4,
    kOsVersionFieldNumber = 5,
    kDeviceModelFieldNumber = 6,
    kBrowserFieldNumber = 7,
    kBrowserVersionFieldNumber = 8,
    kAddressFieldNumber = 9,
    kSdkFieldNumber = 1,
    kProtocolFieldNumber = 3,
  };
  // string version = 2;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string os = 4;
  void clear_os();
  const std::string& os() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_os(ArgT0&& arg0, ArgT... args);
  std::string* mutable_os();
  PROTOBUF_NODISCARD std::string* release_os();
  void set_allocated_os(std::string* os);
  private:
  const std::string& _internal_os() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_os(const std::string& value);
  std::string* _internal_mutable_os();
  public:

  // string os_version = 5;
  void clear_os_version();
  const std::string& os_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_os_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_os_version();
  PROTOBUF_NODISCARD std::string* release_os_version();
  void set_allocated_os_version(std::string* os_version);
  private:
  const std::string& _internal_os_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_os_version(const std::string& value);
  std::string* _internal_mutable_os_version();
  public:

  // string device_model = 6;
  void clear_device_model();
  const std::string& device_model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_model();
  PROTOBUF_NODISCARD std::string* release_device_model();
  void set_allocated_device_model(std::string* device_model);
  private:
  const std::string& _internal_device_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_model(const std::string& value);
  std::string* _internal_mutable_device_model();
  public:

  // string browser = 7;
  void clear_browser();
  const std::string& browser() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_browser(ArgT0&& arg0, ArgT... args);
  std::string* mutable_browser();
  PROTOBUF_NODISCARD std::string* release_browser();
  void set_allocated_browser(std::string* browser);
  private:
  const std::string& _internal_browser() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_browser(const std::string& value);
  std::string* _internal_mutable_browser();
  public:

  // string browser_version = 8;
  void clear_browser_version();
  const std::string& browser_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_browser_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_browser_version();
  PROTOBUF_NODISCARD std::string* release_browser_version();
  void set_allocated_browser_version(std::string* browser_version);
  private:
  const std::string& _internal_browser_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_browser_version(const std::string& value);
  std::string* _internal_mutable_browser_version();
  public:

  // string address = 9;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // .livekit.ClientInfo.SDK sdk = 1;
  void clear_sdk();
  ::livekit::ClientInfo_SDK sdk() const;
  void set_sdk(::livekit::ClientInfo_SDK value);
  private:
  ::livekit::ClientInfo_SDK _internal_sdk() const;
  void _internal_set_sdk(::livekit::ClientInfo_SDK value);
  public:

  // int32 protocol = 3;
  void clear_protocol();
  int32_t protocol() const;
  void set_protocol(int32_t value);
  private:
  int32_t _internal_protocol() const;
  void _internal_set_protocol(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.ClientInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr os_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr os_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_model_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr browser_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr browser_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  int sdk_;
  int32_t protocol_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class ClientConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.ClientConfiguration) */ {
 public:
  inline ClientConfiguration() : ClientConfiguration(nullptr) {}
  ~ClientConfiguration() override;
  explicit constexpr ClientConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientConfiguration(const ClientConfiguration& from);
  ClientConfiguration(ClientConfiguration&& from) noexcept
    : ClientConfiguration() {
    *this = ::std::move(from);
  }

  inline ClientConfiguration& operator=(const ClientConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientConfiguration& operator=(ClientConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientConfiguration* internal_default_instance() {
    return reinterpret_cast<const ClientConfiguration*>(
               &_ClientConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ClientConfiguration& a, ClientConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientConfiguration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientConfiguration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientConfiguration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ClientConfiguration& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientConfiguration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.ClientConfiguration";
  }
  protected:
  explicit ClientConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVideoFieldNumber = 1,
    kScreenFieldNumber = 2,
    kResumeConnectionFieldNumber = 3,
  };
  // .livekit.VideoConfiguration video = 1;
  bool has_video() const;
  private:
  bool _internal_has_video() const;
  public:
  void clear_video();
  const ::livekit::VideoConfiguration& video() const;
  PROTOBUF_NODISCARD ::livekit::VideoConfiguration* release_video();
  ::livekit::VideoConfiguration* mutable_video();
  void set_allocated_video(::livekit::VideoConfiguration* video);
  private:
  const ::livekit::VideoConfiguration& _internal_video() const;
  ::livekit::VideoConfiguration* _internal_mutable_video();
  public:
  void unsafe_arena_set_allocated_video(
      ::livekit::VideoConfiguration* video);
  ::livekit::VideoConfiguration* unsafe_arena_release_video();

  // .livekit.VideoConfiguration screen = 2;
  bool has_screen() const;
  private:
  bool _internal_has_screen() const;
  public:
  void clear_screen();
  const ::livekit::VideoConfiguration& screen() const;
  PROTOBUF_NODISCARD ::livekit::VideoConfiguration* release_screen();
  ::livekit::VideoConfiguration* mutable_screen();
  void set_allocated_screen(::livekit::VideoConfiguration* screen);
  private:
  const ::livekit::VideoConfiguration& _internal_screen() const;
  ::livekit::VideoConfiguration* _internal_mutable_screen();
  public:
  void unsafe_arena_set_allocated_screen(
      ::livekit::VideoConfiguration* screen);
  ::livekit::VideoConfiguration* unsafe_arena_release_screen();

  // .livekit.ClientConfigSetting resume_connection = 3;
  void clear_resume_connection();
  ::livekit::ClientConfigSetting resume_connection() const;
  void set_resume_connection(::livekit::ClientConfigSetting value);
  private:
  ::livekit::ClientConfigSetting _internal_resume_connection() const;
  void _internal_set_resume_connection(::livekit::ClientConfigSetting value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.ClientConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::livekit::VideoConfiguration* video_;
  ::livekit::VideoConfiguration* screen_;
  int resume_connection_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class VideoConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.VideoConfiguration) */ {
 public:
  inline VideoConfiguration() : VideoConfiguration(nullptr) {}
  ~VideoConfiguration() override;
  explicit constexpr VideoConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoConfiguration(const VideoConfiguration& from);
  VideoConfiguration(VideoConfiguration&& from) noexcept
    : VideoConfiguration() {
    *this = ::std::move(from);
  }

  inline VideoConfiguration& operator=(const VideoConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoConfiguration& operator=(VideoConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoConfiguration* internal_default_instance() {
    return reinterpret_cast<const VideoConfiguration*>(
               &_VideoConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(VideoConfiguration& a, VideoConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoConfiguration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoConfiguration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VideoConfiguration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VideoConfiguration& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoConfiguration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.VideoConfiguration";
  }
  protected:
  explicit VideoConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHardwareEncoderFieldNumber = 1,
  };
  // .livekit.ClientConfigSetting hardware_encoder = 1;
  void clear_hardware_encoder();
  ::livekit::ClientConfigSetting hardware_encoder() const;
  void set_hardware_encoder(::livekit::ClientConfigSetting value);
  private:
  ::livekit::ClientConfigSetting _internal_hardware_encoder() const;
  void _internal_set_hardware_encoder(::livekit::ClientConfigSetting value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.VideoConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int hardware_encoder_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class RTPStats_GapHistogramEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RTPStats_GapHistogramEntry_DoNotUse, 
    int32_t, uint32_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RTPStats_GapHistogramEntry_DoNotUse, 
    int32_t, uint32_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32> SuperType;
  RTPStats_GapHistogramEntry_DoNotUse();
  explicit constexpr RTPStats_GapHistogramEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit RTPStats_GapHistogramEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const RTPStats_GapHistogramEntry_DoNotUse& other);
  static const RTPStats_GapHistogramEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const RTPStats_GapHistogramEntry_DoNotUse*>(&_RTPStats_GapHistogramEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class RTPStats final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.RTPStats) */ {
 public:
  inline RTPStats() : RTPStats(nullptr) {}
  ~RTPStats() override;
  explicit constexpr RTPStats(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RTPStats(const RTPStats& from);
  RTPStats(RTPStats&& from) noexcept
    : RTPStats() {
    *this = ::std::move(from);
  }

  inline RTPStats& operator=(const RTPStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline RTPStats& operator=(RTPStats&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RTPStats& default_instance() {
    return *internal_default_instance();
  }
  static inline const RTPStats* internal_default_instance() {
    return reinterpret_cast<const RTPStats*>(
               &_RTPStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(RTPStats& a, RTPStats& b) {
    a.Swap(&b);
  }
  inline void Swap(RTPStats* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RTPStats* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RTPStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RTPStats>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RTPStats& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RTPStats& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RTPStats* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.RTPStats";
  }
  protected:
  explicit RTPStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kGapHistogramFieldNumber = 24,
    kStartTimeFieldNumber = 1,
    kEndTimeFieldNumber = 2,
    kLastPliFieldNumber = 28,
    kLastFirFieldNumber = 30,
    kLastKeyFrameFieldNumber = 34,
    kLastLayerLockPliFieldNumber = 36,
    kDurationFieldNumber = 3,
    kPacketRateFieldNumber = 5,
    kBytesFieldNumber = 6,
    kPacketsFieldNumber = 4,
    kPacketsLostFieldNumber = 8,
    kBitrateFieldNumber = 7,
    kPacketLossRateFieldNumber = 9,
    kPacketLossPercentageFieldNumber = 10,
    kPacketsDuplicateFieldNumber = 11,
    kPacketDuplicateRateFieldNumber = 12,
    kBytesDuplicateFieldNumber = 13,
    kBitrateDuplicateFieldNumber = 14,
    kPacketPaddingRateFieldNumber = 16,
    kBytesPaddingFieldNumber = 17,
    kPacketsPaddingFieldNumber = 15,
    kPacketsOutOfOrderFieldNumber = 19,
    kBitratePaddingFieldNumber = 18,
    kFrameRateFieldNumber = 21,
    kJitterCurrentFieldNumber = 22,
    kFramesFieldNumber = 20,
    kNacksFieldNumber = 25,
    kJitterMaxFieldNumber = 23,
    kNackMissesFieldNumber = 26,
    kPlisFieldNumber = 27,
    kFirsFieldNumber = 29,
    kRttCurrentFieldNumber = 31,
    kRttMaxFieldNumber = 32,
    kKeyFramesFieldNumber = 33,
    kLayerLockPlisFieldNumber = 35,
  };
  // map<int32, uint32> gap_histogram = 24;
  int gap_histogram_size() const;
  private:
  int _internal_gap_histogram_size() const;
  public:
  void clear_gap_histogram();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, uint32_t >&
      _internal_gap_histogram() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, uint32_t >*
      _internal_mutable_gap_histogram();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, uint32_t >&
      gap_histogram() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, uint32_t >*
      mutable_gap_histogram();

  // .google.protobuf.Timestamp start_time = 1;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& start_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_start_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_start_time();
  void set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_start_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_start_time();
  public:
  void unsafe_arena_set_allocated_start_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_start_time();

  // .google.protobuf.Timestamp end_time = 2;
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& end_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_end_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_end_time();
  void set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_end_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_end_time();
  public:
  void unsafe_arena_set_allocated_end_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_end_time();

  // .google.protobuf.Timestamp last_pli = 28;
  bool has_last_pli() const;
  private:
  bool _internal_has_last_pli() const;
  public:
  void clear_last_pli();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_pli() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_pli();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_pli();
  void set_allocated_last_pli(::PROTOBUF_NAMESPACE_ID::Timestamp* last_pli);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_pli() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_pli();
  public:
  void unsafe_arena_set_allocated_last_pli(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_pli);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_pli();

  // .google.protobuf.Timestamp last_fir = 30;
  bool has_last_fir() const;
  private:
  bool _internal_has_last_fir() const;
  public:
  void clear_last_fir();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_fir() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_fir();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_fir();
  void set_allocated_last_fir(::PROTOBUF_NAMESPACE_ID::Timestamp* last_fir);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_fir() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_fir();
  public:
  void unsafe_arena_set_allocated_last_fir(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_fir);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_fir();

  // .google.protobuf.Timestamp last_key_frame = 34;
  bool has_last_key_frame() const;
  private:
  bool _internal_has_last_key_frame() const;
  public:
  void clear_last_key_frame();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_key_frame() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_key_frame();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_key_frame();
  void set_allocated_last_key_frame(::PROTOBUF_NAMESPACE_ID::Timestamp* last_key_frame);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_key_frame() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_key_frame();
  public:
  void unsafe_arena_set_allocated_last_key_frame(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_key_frame);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_key_frame();

  // .google.protobuf.Timestamp last_layer_lock_pli = 36;
  bool has_last_layer_lock_pli() const;
  private:
  bool _internal_has_last_layer_lock_pli() const;
  public:
  void clear_last_layer_lock_pli();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_layer_lock_pli() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_layer_lock_pli();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_layer_lock_pli();
  void set_allocated_last_layer_lock_pli(::PROTOBUF_NAMESPACE_ID::Timestamp* last_layer_lock_pli);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_layer_lock_pli() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_layer_lock_pli();
  public:
  void unsafe_arena_set_allocated_last_layer_lock_pli(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_layer_lock_pli);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_layer_lock_pli();

  // double duration = 3;
  void clear_duration();
  double duration() const;
  void set_duration(double value);
  private:
  double _internal_duration() const;
  void _internal_set_duration(double value);
  public:

  // double packet_rate = 5;
  void clear_packet_rate();
  double packet_rate() const;
  void set_packet_rate(double value);
  private:
  double _internal_packet_rate() const;
  void _internal_set_packet_rate(double value);
  public:

  // uint64 bytes = 6;
  void clear_bytes();
  uint64_t bytes() const;
  void set_bytes(uint64_t value);
  private:
  uint64_t _internal_bytes() const;
  void _internal_set_bytes(uint64_t value);
  public:

  // uint32 packets = 4;
  void clear_packets();
  uint32_t packets() const;
  void set_packets(uint32_t value);
  private:
  uint32_t _internal_packets() const;
  void _internal_set_packets(uint32_t value);
  public:

  // uint32 packets_lost = 8;
  void clear_packets_lost();
  uint32_t packets_lost() const;
  void set_packets_lost(uint32_t value);
  private:
  uint32_t _internal_packets_lost() const;
  void _internal_set_packets_lost(uint32_t value);
  public:

  // double bitrate = 7;
  void clear_bitrate();
  double bitrate() const;
  void set_bitrate(double value);
  private:
  double _internal_bitrate() const;
  void _internal_set_bitrate(double value);
  public:

  // double packet_loss_rate = 9;
  void clear_packet_loss_rate();
  double packet_loss_rate() const;
  void set_packet_loss_rate(double value);
  private:
  double _internal_packet_loss_rate() const;
  void _internal_set_packet_loss_rate(double value);
  public:

  // float packet_loss_percentage = 10;
  void clear_packet_loss_percentage();
  float packet_loss_percentage() const;
  void set_packet_loss_percentage(float value);
  private:
  float _internal_packet_loss_percentage() const;
  void _internal_set_packet_loss_percentage(float value);
  public:

  // uint32 packets_duplicate = 11;
  void clear_packets_duplicate();
  uint32_t packets_duplicate() const;
  void set_packets_duplicate(uint32_t value);
  private:
  uint32_t _internal_packets_duplicate() const;
  void _internal_set_packets_duplicate(uint32_t value);
  public:

  // double packet_duplicate_rate = 12;
  void clear_packet_duplicate_rate();
  double packet_duplicate_rate() const;
  void set_packet_duplicate_rate(double value);
  private:
  double _internal_packet_duplicate_rate() const;
  void _internal_set_packet_duplicate_rate(double value);
  public:

  // uint64 bytes_duplicate = 13;
  void clear_bytes_duplicate();
  uint64_t bytes_duplicate() const;
  void set_bytes_duplicate(uint64_t value);
  private:
  uint64_t _internal_bytes_duplicate() const;
  void _internal_set_bytes_duplicate(uint64_t value);
  public:

  // double bitrate_duplicate = 14;
  void clear_bitrate_duplicate();
  double bitrate_duplicate() const;
  void set_bitrate_duplicate(double value);
  private:
  double _internal_bitrate_duplicate() const;
  void _internal_set_bitrate_duplicate(double value);
  public:

  // double packet_padding_rate = 16;
  void clear_packet_padding_rate();
  double packet_padding_rate() const;
  void set_packet_padding_rate(double value);
  private:
  double _internal_packet_padding_rate() const;
  void _internal_set_packet_padding_rate(double value);
  public:

  // uint64 bytes_padding = 17;
  void clear_bytes_padding();
  uint64_t bytes_padding() const;
  void set_bytes_padding(uint64_t value);
  private:
  uint64_t _internal_bytes_padding() const;
  void _internal_set_bytes_padding(uint64_t value);
  public:

  // uint32 packets_padding = 15;
  void clear_packets_padding();
  uint32_t packets_padding() const;
  void set_packets_padding(uint32_t value);
  private:
  uint32_t _internal_packets_padding() const;
  void _internal_set_packets_padding(uint32_t value);
  public:

  // uint32 packets_out_of_order = 19;
  void clear_packets_out_of_order();
  uint32_t packets_out_of_order() const;
  void set_packets_out_of_order(uint32_t value);
  private:
  uint32_t _internal_packets_out_of_order() const;
  void _internal_set_packets_out_of_order(uint32_t value);
  public:

  // double bitrate_padding = 18;
  void clear_bitrate_padding();
  double bitrate_padding() const;
  void set_bitrate_padding(double value);
  private:
  double _internal_bitrate_padding() const;
  void _internal_set_bitrate_padding(double value);
  public:

  // double frame_rate = 21;
  void clear_frame_rate();
  double frame_rate() const;
  void set_frame_rate(double value);
  private:
  double _internal_frame_rate() const;
  void _internal_set_frame_rate(double value);
  public:

  // double jitter_current = 22;
  void clear_jitter_current();
  double jitter_current() const;
  void set_jitter_current(double value);
  private:
  double _internal_jitter_current() const;
  void _internal_set_jitter_current(double value);
  public:

  // uint32 frames = 20;
  void clear_frames();
  uint32_t frames() const;
  void set_frames(uint32_t value);
  private:
  uint32_t _internal_frames() const;
  void _internal_set_frames(uint32_t value);
  public:

  // uint32 nacks = 25;
  void clear_nacks();
  uint32_t nacks() const;
  void set_nacks(uint32_t value);
  private:
  uint32_t _internal_nacks() const;
  void _internal_set_nacks(uint32_t value);
  public:

  // double jitter_max = 23;
  void clear_jitter_max();
  double jitter_max() const;
  void set_jitter_max(double value);
  private:
  double _internal_jitter_max() const;
  void _internal_set_jitter_max(double value);
  public:

  // uint32 nack_misses = 26;
  void clear_nack_misses();
  uint32_t nack_misses() const;
  void set_nack_misses(uint32_t value);
  private:
  uint32_t _internal_nack_misses() const;
  void _internal_set_nack_misses(uint32_t value);
  public:

  // uint32 plis = 27;
  void clear_plis();
  uint32_t plis() const;
  void set_plis(uint32_t value);
  private:
  uint32_t _internal_plis() const;
  void _internal_set_plis(uint32_t value);
  public:

  // uint32 firs = 29;
  void clear_firs();
  uint32_t firs() const;
  void set_firs(uint32_t value);
  private:
  uint32_t _internal_firs() const;
  void _internal_set_firs(uint32_t value);
  public:

  // uint32 rtt_current = 31;
  void clear_rtt_current();
  uint32_t rtt_current() const;
  void set_rtt_current(uint32_t value);
  private:
  uint32_t _internal_rtt_current() const;
  void _internal_set_rtt_current(uint32_t value);
  public:

  // uint32 rtt_max = 32;
  void clear_rtt_max();
  uint32_t rtt_max() const;
  void set_rtt_max(uint32_t value);
  private:
  uint32_t _internal_rtt_max() const;
  void _internal_set_rtt_max(uint32_t value);
  public:

  // uint32 key_frames = 33;
  void clear_key_frames();
  uint32_t key_frames() const;
  void set_key_frames(uint32_t value);
  private:
  uint32_t _internal_key_frames() const;
  void _internal_set_key_frames(uint32_t value);
  public:

  // uint32 layer_lock_plis = 35;
  void clear_layer_lock_plis();
  uint32_t layer_lock_plis() const;
  void set_layer_lock_plis(uint32_t value);
  private:
  uint32_t _internal_layer_lock_plis() const;
  void _internal_set_layer_lock_plis(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.RTPStats)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      RTPStats_GapHistogramEntry_DoNotUse,
      int32_t, uint32_t,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32> gap_histogram_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* last_pli_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* last_fir_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* last_key_frame_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* last_layer_lock_pli_;
  double duration_;
  double packet_rate_;
  uint64_t bytes_;
  uint32_t packets_;
  uint32_t packets_lost_;
  double bitrate_;
  double packet_loss_rate_;
  float packet_loss_percentage_;
  uint32_t packets_duplicate_;
  double packet_duplicate_rate_;
  uint64_t bytes_duplicate_;
  double bitrate_duplicate_;
  double packet_padding_rate_;
  uint64_t bytes_padding_;
  uint32_t packets_padding_;
  uint32_t packets_out_of_order_;
  double bitrate_padding_;
  double frame_rate_;
  double jitter_current_;
  uint32_t frames_;
  uint32_t nacks_;
  double jitter_max_;
  uint32_t nack_misses_;
  uint32_t plis_;
  uint32_t firs_;
  uint32_t rtt_current_;
  uint32_t rtt_max_;
  uint32_t key_frames_;
  uint32_t layer_lock_plis_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Room

// string sid = 1;
inline void Room::clear_sid() {
  sid_.ClearToEmpty();
}
inline const std::string& Room::sid() const {
  // @@protoc_insertion_point(field_get:livekit.Room.sid)
  return _internal_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Room::set_sid(ArgT0&& arg0, ArgT... args) {
 
 sid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.Room.sid)
}
inline std::string* Room::mutable_sid() {
  std::string* _s = _internal_mutable_sid();
  // @@protoc_insertion_point(field_mutable:livekit.Room.sid)
  return _s;
}
inline const std::string& Room::_internal_sid() const {
  return sid_.Get();
}
inline void Room::_internal_set_sid(const std::string& value) {
  
  sid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Room::_internal_mutable_sid() {
  
  return sid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Room::release_sid() {
  // @@protoc_insertion_point(field_release:livekit.Room.sid)
  return sid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Room::set_allocated_sid(std::string* sid) {
  if (sid != nullptr) {
    
  } else {
    
  }
  sid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.Room.sid)
}

// string name = 2;
inline void Room::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Room::name() const {
  // @@protoc_insertion_point(field_get:livekit.Room.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Room::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.Room.name)
}
inline std::string* Room::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:livekit.Room.name)
  return _s;
}
inline const std::string& Room::_internal_name() const {
  return name_.Get();
}
inline void Room::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Room::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Room::release_name() {
  // @@protoc_insertion_point(field_release:livekit.Room.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Room::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.Room.name)
}

// uint32 empty_timeout = 3;
inline void Room::clear_empty_timeout() {
  empty_timeout_ = 0u;
}
inline uint32_t Room::_internal_empty_timeout() const {
  return empty_timeout_;
}
inline uint32_t Room::empty_timeout() const {
  // @@protoc_insertion_point(field_get:livekit.Room.empty_timeout)
  return _internal_empty_timeout();
}
inline void Room::_internal_set_empty_timeout(uint32_t value) {
  
  empty_timeout_ = value;
}
inline void Room::set_empty_timeout(uint32_t value) {
  _internal_set_empty_timeout(value);
  // @@protoc_insertion_point(field_set:livekit.Room.empty_timeout)
}

// uint32 max_participants = 4;
inline void Room::clear_max_participants() {
  max_participants_ = 0u;
}
inline uint32_t Room::_internal_max_participants() const {
  return max_participants_;
}
inline uint32_t Room::max_participants() const {
  // @@protoc_insertion_point(field_get:livekit.Room.max_participants)
  return _internal_max_participants();
}
inline void Room::_internal_set_max_participants(uint32_t value) {
  
  max_participants_ = value;
}
inline void Room::set_max_participants(uint32_t value) {
  _internal_set_max_participants(value);
  // @@protoc_insertion_point(field_set:livekit.Room.max_participants)
}

// int64 creation_time = 5;
inline void Room::clear_creation_time() {
  creation_time_ = int64_t{0};
}
inline int64_t Room::_internal_creation_time() const {
  return creation_time_;
}
inline int64_t Room::creation_time() const {
  // @@protoc_insertion_point(field_get:livekit.Room.creation_time)
  return _internal_creation_time();
}
inline void Room::_internal_set_creation_time(int64_t value) {
  
  creation_time_ = value;
}
inline void Room::set_creation_time(int64_t value) {
  _internal_set_creation_time(value);
  // @@protoc_insertion_point(field_set:livekit.Room.creation_time)
}

// string turn_password = 6;
inline void Room::clear_turn_password() {
  turn_password_.ClearToEmpty();
}
inline const std::string& Room::turn_password() const {
  // @@protoc_insertion_point(field_get:livekit.Room.turn_password)
  return _internal_turn_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Room::set_turn_password(ArgT0&& arg0, ArgT... args) {
 
 turn_password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.Room.turn_password)
}
inline std::string* Room::mutable_turn_password() {
  std::string* _s = _internal_mutable_turn_password();
  // @@protoc_insertion_point(field_mutable:livekit.Room.turn_password)
  return _s;
}
inline const std::string& Room::_internal_turn_password() const {
  return turn_password_.Get();
}
inline void Room::_internal_set_turn_password(const std::string& value) {
  
  turn_password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Room::_internal_mutable_turn_password() {
  
  return turn_password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Room::release_turn_password() {
  // @@protoc_insertion_point(field_release:livekit.Room.turn_password)
  return turn_password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Room::set_allocated_turn_password(std::string* turn_password) {
  if (turn_password != nullptr) {
    
  } else {
    
  }
  turn_password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), turn_password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (turn_password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    turn_password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.Room.turn_password)
}

// repeated .livekit.Codec enabled_codecs = 7;
inline int Room::_internal_enabled_codecs_size() const {
  return enabled_codecs_.size();
}
inline int Room::enabled_codecs_size() const {
  return _internal_enabled_codecs_size();
}
inline void Room::clear_enabled_codecs() {
  enabled_codecs_.Clear();
}
inline ::livekit::Codec* Room::mutable_enabled_codecs(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.Room.enabled_codecs)
  return enabled_codecs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::Codec >*
Room::mutable_enabled_codecs() {
  // @@protoc_insertion_point(field_mutable_list:livekit.Room.enabled_codecs)
  return &enabled_codecs_;
}
inline const ::livekit::Codec& Room::_internal_enabled_codecs(int index) const {
  return enabled_codecs_.Get(index);
}
inline const ::livekit::Codec& Room::enabled_codecs(int index) const {
  // @@protoc_insertion_point(field_get:livekit.Room.enabled_codecs)
  return _internal_enabled_codecs(index);
}
inline ::livekit::Codec* Room::_internal_add_enabled_codecs() {
  return enabled_codecs_.Add();
}
inline ::livekit::Codec* Room::add_enabled_codecs() {
  ::livekit::Codec* _add = _internal_add_enabled_codecs();
  // @@protoc_insertion_point(field_add:livekit.Room.enabled_codecs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::Codec >&
Room::enabled_codecs() const {
  // @@protoc_insertion_point(field_list:livekit.Room.enabled_codecs)
  return enabled_codecs_;
}

// string metadata = 8;
inline void Room::clear_metadata() {
  metadata_.ClearToEmpty();
}
inline const std::string& Room::metadata() const {
  // @@protoc_insertion_point(field_get:livekit.Room.metadata)
  return _internal_metadata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Room::set_metadata(ArgT0&& arg0, ArgT... args) {
 
 metadata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.Room.metadata)
}
inline std::string* Room::mutable_metadata() {
  std::string* _s = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:livekit.Room.metadata)
  return _s;
}
inline const std::string& Room::_internal_metadata() const {
  return metadata_.Get();
}
inline void Room::_internal_set_metadata(const std::string& value) {
  
  metadata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Room::_internal_mutable_metadata() {
  
  return metadata_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Room::release_metadata() {
  // @@protoc_insertion_point(field_release:livekit.Room.metadata)
  return metadata_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Room::set_allocated_metadata(std::string* metadata) {
  if (metadata != nullptr) {
    
  } else {
    
  }
  metadata_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), metadata,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (metadata_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    metadata_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.Room.metadata)
}

// uint32 num_participants = 9;
inline void Room::clear_num_participants() {
  num_participants_ = 0u;
}
inline uint32_t Room::_internal_num_participants() const {
  return num_participants_;
}
inline uint32_t Room::num_participants() const {
  // @@protoc_insertion_point(field_get:livekit.Room.num_participants)
  return _internal_num_participants();
}
inline void Room::_internal_set_num_participants(uint32_t value) {
  
  num_participants_ = value;
}
inline void Room::set_num_participants(uint32_t value) {
  _internal_set_num_participants(value);
  // @@protoc_insertion_point(field_set:livekit.Room.num_participants)
}

// bool active_recording = 10;
inline void Room::clear_active_recording() {
  active_recording_ = false;
}
inline bool Room::_internal_active_recording() const {
  return active_recording_;
}
inline bool Room::active_recording() const {
  // @@protoc_insertion_point(field_get:livekit.Room.active_recording)
  return _internal_active_recording();
}
inline void Room::_internal_set_active_recording(bool value) {
  
  active_recording_ = value;
}
inline void Room::set_active_recording(bool value) {
  _internal_set_active_recording(value);
  // @@protoc_insertion_point(field_set:livekit.Room.active_recording)
}

// -------------------------------------------------------------------

// Codec

// string mime = 1;
inline void Codec::clear_mime() {
  mime_.ClearToEmpty();
}
inline const std::string& Codec::mime() const {
  // @@protoc_insertion_point(field_get:livekit.Codec.mime)
  return _internal_mime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Codec::set_mime(ArgT0&& arg0, ArgT... args) {
 
 mime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.Codec.mime)
}
inline std::string* Codec::mutable_mime() {
  std::string* _s = _internal_mutable_mime();
  // @@protoc_insertion_point(field_mutable:livekit.Codec.mime)
  return _s;
}
inline const std::string& Codec::_internal_mime() const {
  return mime_.Get();
}
inline void Codec::_internal_set_mime(const std::string& value) {
  
  mime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Codec::_internal_mutable_mime() {
  
  return mime_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Codec::release_mime() {
  // @@protoc_insertion_point(field_release:livekit.Codec.mime)
  return mime_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Codec::set_allocated_mime(std::string* mime) {
  if (mime != nullptr) {
    
  } else {
    
  }
  mime_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mime,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mime_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    mime_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.Codec.mime)
}

// string fmtp_line = 2;
inline void Codec::clear_fmtp_line() {
  fmtp_line_.ClearToEmpty();
}
inline const std::string& Codec::fmtp_line() const {
  // @@protoc_insertion_point(field_get:livekit.Codec.fmtp_line)
  return _internal_fmtp_line();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Codec::set_fmtp_line(ArgT0&& arg0, ArgT... args) {
 
 fmtp_line_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.Codec.fmtp_line)
}
inline std::string* Codec::mutable_fmtp_line() {
  std::string* _s = _internal_mutable_fmtp_line();
  // @@protoc_insertion_point(field_mutable:livekit.Codec.fmtp_line)
  return _s;
}
inline const std::string& Codec::_internal_fmtp_line() const {
  return fmtp_line_.Get();
}
inline void Codec::_internal_set_fmtp_line(const std::string& value) {
  
  fmtp_line_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Codec::_internal_mutable_fmtp_line() {
  
  return fmtp_line_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Codec::release_fmtp_line() {
  // @@protoc_insertion_point(field_release:livekit.Codec.fmtp_line)
  return fmtp_line_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Codec::set_allocated_fmtp_line(std::string* fmtp_line) {
  if (fmtp_line != nullptr) {
    
  } else {
    
  }
  fmtp_line_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fmtp_line,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fmtp_line_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    fmtp_line_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.Codec.fmtp_line)
}

// -------------------------------------------------------------------

// ParticipantPermission

// bool can_subscribe = 1;
inline void ParticipantPermission::clear_can_subscribe() {
  can_subscribe_ = false;
}
inline bool ParticipantPermission::_internal_can_subscribe() const {
  return can_subscribe_;
}
inline bool ParticipantPermission::can_subscribe() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantPermission.can_subscribe)
  return _internal_can_subscribe();
}
inline void ParticipantPermission::_internal_set_can_subscribe(bool value) {
  
  can_subscribe_ = value;
}
inline void ParticipantPermission::set_can_subscribe(bool value) {
  _internal_set_can_subscribe(value);
  // @@protoc_insertion_point(field_set:livekit.ParticipantPermission.can_subscribe)
}

// bool can_publish = 2;
inline void ParticipantPermission::clear_can_publish() {
  can_publish_ = false;
}
inline bool ParticipantPermission::_internal_can_publish() const {
  return can_publish_;
}
inline bool ParticipantPermission::can_publish() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantPermission.can_publish)
  return _internal_can_publish();
}
inline void ParticipantPermission::_internal_set_can_publish(bool value) {
  
  can_publish_ = value;
}
inline void ParticipantPermission::set_can_publish(bool value) {
  _internal_set_can_publish(value);
  // @@protoc_insertion_point(field_set:livekit.ParticipantPermission.can_publish)
}

// bool can_publish_data = 3;
inline void ParticipantPermission::clear_can_publish_data() {
  can_publish_data_ = false;
}
inline bool ParticipantPermission::_internal_can_publish_data() const {
  return can_publish_data_;
}
inline bool ParticipantPermission::can_publish_data() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantPermission.can_publish_data)
  return _internal_can_publish_data();
}
inline void ParticipantPermission::_internal_set_can_publish_data(bool value) {
  
  can_publish_data_ = value;
}
inline void ParticipantPermission::set_can_publish_data(bool value) {
  _internal_set_can_publish_data(value);
  // @@protoc_insertion_point(field_set:livekit.ParticipantPermission.can_publish_data)
}

// bool hidden = 7;
inline void ParticipantPermission::clear_hidden() {
  hidden_ = false;
}
inline bool ParticipantPermission::_internal_hidden() const {
  return hidden_;
}
inline bool ParticipantPermission::hidden() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantPermission.hidden)
  return _internal_hidden();
}
inline void ParticipantPermission::_internal_set_hidden(bool value) {
  
  hidden_ = value;
}
inline void ParticipantPermission::set_hidden(bool value) {
  _internal_set_hidden(value);
  // @@protoc_insertion_point(field_set:livekit.ParticipantPermission.hidden)
}

// bool recorder = 8;
inline void ParticipantPermission::clear_recorder() {
  recorder_ = false;
}
inline bool ParticipantPermission::_internal_recorder() const {
  return recorder_;
}
inline bool ParticipantPermission::recorder() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantPermission.recorder)
  return _internal_recorder();
}
inline void ParticipantPermission::_internal_set_recorder(bool value) {
  
  recorder_ = value;
}
inline void ParticipantPermission::set_recorder(bool value) {
  _internal_set_recorder(value);
  // @@protoc_insertion_point(field_set:livekit.ParticipantPermission.recorder)
}

// -------------------------------------------------------------------

// ParticipantInfo

// string sid = 1;
inline void ParticipantInfo::clear_sid() {
  sid_.ClearToEmpty();
}
inline const std::string& ParticipantInfo::sid() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantInfo.sid)
  return _internal_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ParticipantInfo::set_sid(ArgT0&& arg0, ArgT... args) {
 
 sid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ParticipantInfo.sid)
}
inline std::string* ParticipantInfo::mutable_sid() {
  std::string* _s = _internal_mutable_sid();
  // @@protoc_insertion_point(field_mutable:livekit.ParticipantInfo.sid)
  return _s;
}
inline const std::string& ParticipantInfo::_internal_sid() const {
  return sid_.Get();
}
inline void ParticipantInfo::_internal_set_sid(const std::string& value) {
  
  sid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ParticipantInfo::_internal_mutable_sid() {
  
  return sid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ParticipantInfo::release_sid() {
  // @@protoc_insertion_point(field_release:livekit.ParticipantInfo.sid)
  return sid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ParticipantInfo::set_allocated_sid(std::string* sid) {
  if (sid != nullptr) {
    
  } else {
    
  }
  sid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ParticipantInfo.sid)
}

// string identity = 2;
inline void ParticipantInfo::clear_identity() {
  identity_.ClearToEmpty();
}
inline const std::string& ParticipantInfo::identity() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantInfo.identity)
  return _internal_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ParticipantInfo::set_identity(ArgT0&& arg0, ArgT... args) {
 
 identity_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ParticipantInfo.identity)
}
inline std::string* ParticipantInfo::mutable_identity() {
  std::string* _s = _internal_mutable_identity();
  // @@protoc_insertion_point(field_mutable:livekit.ParticipantInfo.identity)
  return _s;
}
inline const std::string& ParticipantInfo::_internal_identity() const {
  return identity_.Get();
}
inline void ParticipantInfo::_internal_set_identity(const std::string& value) {
  
  identity_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ParticipantInfo::_internal_mutable_identity() {
  
  return identity_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ParticipantInfo::release_identity() {
  // @@protoc_insertion_point(field_release:livekit.ParticipantInfo.identity)
  return identity_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ParticipantInfo::set_allocated_identity(std::string* identity) {
  if (identity != nullptr) {
    
  } else {
    
  }
  identity_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), identity,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identity_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    identity_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ParticipantInfo.identity)
}

// .livekit.ParticipantInfo.State state = 3;
inline void ParticipantInfo::clear_state() {
  state_ = 0;
}
inline ::livekit::ParticipantInfo_State ParticipantInfo::_internal_state() const {
  return static_cast< ::livekit::ParticipantInfo_State >(state_);
}
inline ::livekit::ParticipantInfo_State ParticipantInfo::state() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantInfo.state)
  return _internal_state();
}
inline void ParticipantInfo::_internal_set_state(::livekit::ParticipantInfo_State value) {
  
  state_ = value;
}
inline void ParticipantInfo::set_state(::livekit::ParticipantInfo_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:livekit.ParticipantInfo.state)
}

// repeated .livekit.TrackInfo tracks = 4;
inline int ParticipantInfo::_internal_tracks_size() const {
  return tracks_.size();
}
inline int ParticipantInfo::tracks_size() const {
  return _internal_tracks_size();
}
inline void ParticipantInfo::clear_tracks() {
  tracks_.Clear();
}
inline ::livekit::TrackInfo* ParticipantInfo::mutable_tracks(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.ParticipantInfo.tracks)
  return tracks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::TrackInfo >*
ParticipantInfo::mutable_tracks() {
  // @@protoc_insertion_point(field_mutable_list:livekit.ParticipantInfo.tracks)
  return &tracks_;
}
inline const ::livekit::TrackInfo& ParticipantInfo::_internal_tracks(int index) const {
  return tracks_.Get(index);
}
inline const ::livekit::TrackInfo& ParticipantInfo::tracks(int index) const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantInfo.tracks)
  return _internal_tracks(index);
}
inline ::livekit::TrackInfo* ParticipantInfo::_internal_add_tracks() {
  return tracks_.Add();
}
inline ::livekit::TrackInfo* ParticipantInfo::add_tracks() {
  ::livekit::TrackInfo* _add = _internal_add_tracks();
  // @@protoc_insertion_point(field_add:livekit.ParticipantInfo.tracks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::TrackInfo >&
ParticipantInfo::tracks() const {
  // @@protoc_insertion_point(field_list:livekit.ParticipantInfo.tracks)
  return tracks_;
}

// string metadata = 5;
inline void ParticipantInfo::clear_metadata() {
  metadata_.ClearToEmpty();
}
inline const std::string& ParticipantInfo::metadata() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantInfo.metadata)
  return _internal_metadata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ParticipantInfo::set_metadata(ArgT0&& arg0, ArgT... args) {
 
 metadata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ParticipantInfo.metadata)
}
inline std::string* ParticipantInfo::mutable_metadata() {
  std::string* _s = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:livekit.ParticipantInfo.metadata)
  return _s;
}
inline const std::string& ParticipantInfo::_internal_metadata() const {
  return metadata_.Get();
}
inline void ParticipantInfo::_internal_set_metadata(const std::string& value) {
  
  metadata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ParticipantInfo::_internal_mutable_metadata() {
  
  return metadata_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ParticipantInfo::release_metadata() {
  // @@protoc_insertion_point(field_release:livekit.ParticipantInfo.metadata)
  return metadata_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ParticipantInfo::set_allocated_metadata(std::string* metadata) {
  if (metadata != nullptr) {
    
  } else {
    
  }
  metadata_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), metadata,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (metadata_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    metadata_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ParticipantInfo.metadata)
}

// int64 joined_at = 6;
inline void ParticipantInfo::clear_joined_at() {
  joined_at_ = int64_t{0};
}
inline int64_t ParticipantInfo::_internal_joined_at() const {
  return joined_at_;
}
inline int64_t ParticipantInfo::joined_at() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantInfo.joined_at)
  return _internal_joined_at();
}
inline void ParticipantInfo::_internal_set_joined_at(int64_t value) {
  
  joined_at_ = value;
}
inline void ParticipantInfo::set_joined_at(int64_t value) {
  _internal_set_joined_at(value);
  // @@protoc_insertion_point(field_set:livekit.ParticipantInfo.joined_at)
}

// string name = 9;
inline void ParticipantInfo::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ParticipantInfo::name() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ParticipantInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ParticipantInfo.name)
}
inline std::string* ParticipantInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:livekit.ParticipantInfo.name)
  return _s;
}
inline const std::string& ParticipantInfo::_internal_name() const {
  return name_.Get();
}
inline void ParticipantInfo::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ParticipantInfo::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ParticipantInfo::release_name() {
  // @@protoc_insertion_point(field_release:livekit.ParticipantInfo.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ParticipantInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ParticipantInfo.name)
}

// uint32 version = 10;
inline void ParticipantInfo::clear_version() {
  version_ = 0u;
}
inline uint32_t ParticipantInfo::_internal_version() const {
  return version_;
}
inline uint32_t ParticipantInfo::version() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantInfo.version)
  return _internal_version();
}
inline void ParticipantInfo::_internal_set_version(uint32_t value) {
  
  version_ = value;
}
inline void ParticipantInfo::set_version(uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:livekit.ParticipantInfo.version)
}

// .livekit.ParticipantPermission permission = 11;
inline bool ParticipantInfo::_internal_has_permission() const {
  return this != internal_default_instance() && permission_ != nullptr;
}
inline bool ParticipantInfo::has_permission() const {
  return _internal_has_permission();
}
inline void ParticipantInfo::clear_permission() {
  if (GetArenaForAllocation() == nullptr && permission_ != nullptr) {
    delete permission_;
  }
  permission_ = nullptr;
}
inline const ::livekit::ParticipantPermission& ParticipantInfo::_internal_permission() const {
  const ::livekit::ParticipantPermission* p = permission_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::ParticipantPermission&>(
      ::livekit::_ParticipantPermission_default_instance_);
}
inline const ::livekit::ParticipantPermission& ParticipantInfo::permission() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantInfo.permission)
  return _internal_permission();
}
inline void ParticipantInfo::unsafe_arena_set_allocated_permission(
    ::livekit::ParticipantPermission* permission) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permission_);
  }
  permission_ = permission;
  if (permission) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.ParticipantInfo.permission)
}
inline ::livekit::ParticipantPermission* ParticipantInfo::release_permission() {
  
  ::livekit::ParticipantPermission* temp = permission_;
  permission_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::ParticipantPermission* ParticipantInfo::unsafe_arena_release_permission() {
  // @@protoc_insertion_point(field_release:livekit.ParticipantInfo.permission)
  
  ::livekit::ParticipantPermission* temp = permission_;
  permission_ = nullptr;
  return temp;
}
inline ::livekit::ParticipantPermission* ParticipantInfo::_internal_mutable_permission() {
  
  if (permission_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::ParticipantPermission>(GetArenaForAllocation());
    permission_ = p;
  }
  return permission_;
}
inline ::livekit::ParticipantPermission* ParticipantInfo::mutable_permission() {
  ::livekit::ParticipantPermission* _msg = _internal_mutable_permission();
  // @@protoc_insertion_point(field_mutable:livekit.ParticipantInfo.permission)
  return _msg;
}
inline void ParticipantInfo::set_allocated_permission(::livekit::ParticipantPermission* permission) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete permission_;
  }
  if (permission) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::livekit::ParticipantPermission>::GetOwningArena(permission);
    if (message_arena != submessage_arena) {
      permission = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, permission, submessage_arena);
    }
    
  } else {
    
  }
  permission_ = permission;
  // @@protoc_insertion_point(field_set_allocated:livekit.ParticipantInfo.permission)
}

// string region = 12;
inline void ParticipantInfo::clear_region() {
  region_.ClearToEmpty();
}
inline const std::string& ParticipantInfo::region() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantInfo.region)
  return _internal_region();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ParticipantInfo::set_region(ArgT0&& arg0, ArgT... args) {
 
 region_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ParticipantInfo.region)
}
inline std::string* ParticipantInfo::mutable_region() {
  std::string* _s = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:livekit.ParticipantInfo.region)
  return _s;
}
inline const std::string& ParticipantInfo::_internal_region() const {
  return region_.Get();
}
inline void ParticipantInfo::_internal_set_region(const std::string& value) {
  
  region_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ParticipantInfo::_internal_mutable_region() {
  
  return region_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ParticipantInfo::release_region() {
  // @@protoc_insertion_point(field_release:livekit.ParticipantInfo.region)
  return region_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ParticipantInfo::set_allocated_region(std::string* region) {
  if (region != nullptr) {
    
  } else {
    
  }
  region_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), region,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (region_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    region_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ParticipantInfo.region)
}

// bool is_publisher = 13;
inline void ParticipantInfo::clear_is_publisher() {
  is_publisher_ = false;
}
inline bool ParticipantInfo::_internal_is_publisher() const {
  return is_publisher_;
}
inline bool ParticipantInfo::is_publisher() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantInfo.is_publisher)
  return _internal_is_publisher();
}
inline void ParticipantInfo::_internal_set_is_publisher(bool value) {
  
  is_publisher_ = value;
}
inline void ParticipantInfo::set_is_publisher(bool value) {
  _internal_set_is_publisher(value);
  // @@protoc_insertion_point(field_set:livekit.ParticipantInfo.is_publisher)
}

// -------------------------------------------------------------------

// TrackInfo

// string sid = 1;
inline void TrackInfo::clear_sid() {
  sid_.ClearToEmpty();
}
inline const std::string& TrackInfo::sid() const {
  // @@protoc_insertion_point(field_get:livekit.TrackInfo.sid)
  return _internal_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackInfo::set_sid(ArgT0&& arg0, ArgT... args) {
 
 sid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.TrackInfo.sid)
}
inline std::string* TrackInfo::mutable_sid() {
  std::string* _s = _internal_mutable_sid();
  // @@protoc_insertion_point(field_mutable:livekit.TrackInfo.sid)
  return _s;
}
inline const std::string& TrackInfo::_internal_sid() const {
  return sid_.Get();
}
inline void TrackInfo::_internal_set_sid(const std::string& value) {
  
  sid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TrackInfo::_internal_mutable_sid() {
  
  return sid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TrackInfo::release_sid() {
  // @@protoc_insertion_point(field_release:livekit.TrackInfo.sid)
  return sid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TrackInfo::set_allocated_sid(std::string* sid) {
  if (sid != nullptr) {
    
  } else {
    
  }
  sid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.TrackInfo.sid)
}

// .livekit.TrackType type = 2;
inline void TrackInfo::clear_type() {
  type_ = 0;
}
inline ::livekit::TrackType TrackInfo::_internal_type() const {
  return static_cast< ::livekit::TrackType >(type_);
}
inline ::livekit::TrackType TrackInfo::type() const {
  // @@protoc_insertion_point(field_get:livekit.TrackInfo.type)
  return _internal_type();
}
inline void TrackInfo::_internal_set_type(::livekit::TrackType value) {
  
  type_ = value;
}
inline void TrackInfo::set_type(::livekit::TrackType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:livekit.TrackInfo.type)
}

// string name = 3;
inline void TrackInfo::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& TrackInfo::name() const {
  // @@protoc_insertion_point(field_get:livekit.TrackInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.TrackInfo.name)
}
inline std::string* TrackInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:livekit.TrackInfo.name)
  return _s;
}
inline const std::string& TrackInfo::_internal_name() const {
  return name_.Get();
}
inline void TrackInfo::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TrackInfo::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TrackInfo::release_name() {
  // @@protoc_insertion_point(field_release:livekit.TrackInfo.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TrackInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.TrackInfo.name)
}

// bool muted = 4;
inline void TrackInfo::clear_muted() {
  muted_ = false;
}
inline bool TrackInfo::_internal_muted() const {
  return muted_;
}
inline bool TrackInfo::muted() const {
  // @@protoc_insertion_point(field_get:livekit.TrackInfo.muted)
  return _internal_muted();
}
inline void TrackInfo::_internal_set_muted(bool value) {
  
  muted_ = value;
}
inline void TrackInfo::set_muted(bool value) {
  _internal_set_muted(value);
  // @@protoc_insertion_point(field_set:livekit.TrackInfo.muted)
}

// uint32 width = 5;
inline void TrackInfo::clear_width() {
  width_ = 0u;
}
inline uint32_t TrackInfo::_internal_width() const {
  return width_;
}
inline uint32_t TrackInfo::width() const {
  // @@protoc_insertion_point(field_get:livekit.TrackInfo.width)
  return _internal_width();
}
inline void TrackInfo::_internal_set_width(uint32_t value) {
  
  width_ = value;
}
inline void TrackInfo::set_width(uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:livekit.TrackInfo.width)
}

// uint32 height = 6;
inline void TrackInfo::clear_height() {
  height_ = 0u;
}
inline uint32_t TrackInfo::_internal_height() const {
  return height_;
}
inline uint32_t TrackInfo::height() const {
  // @@protoc_insertion_point(field_get:livekit.TrackInfo.height)
  return _internal_height();
}
inline void TrackInfo::_internal_set_height(uint32_t value) {
  
  height_ = value;
}
inline void TrackInfo::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:livekit.TrackInfo.height)
}

// bool simulcast = 7;
inline void TrackInfo::clear_simulcast() {
  simulcast_ = false;
}
inline bool TrackInfo::_internal_simulcast() const {
  return simulcast_;
}
inline bool TrackInfo::simulcast() const {
  // @@protoc_insertion_point(field_get:livekit.TrackInfo.simulcast)
  return _internal_simulcast();
}
inline void TrackInfo::_internal_set_simulcast(bool value) {
  
  simulcast_ = value;
}
inline void TrackInfo::set_simulcast(bool value) {
  _internal_set_simulcast(value);
  // @@protoc_insertion_point(field_set:livekit.TrackInfo.simulcast)
}

// bool disable_dtx = 8;
inline void TrackInfo::clear_disable_dtx() {
  disable_dtx_ = false;
}
inline bool TrackInfo::_internal_disable_dtx() const {
  return disable_dtx_;
}
inline bool TrackInfo::disable_dtx() const {
  // @@protoc_insertion_point(field_get:livekit.TrackInfo.disable_dtx)
  return _internal_disable_dtx();
}
inline void TrackInfo::_internal_set_disable_dtx(bool value) {
  
  disable_dtx_ = value;
}
inline void TrackInfo::set_disable_dtx(bool value) {
  _internal_set_disable_dtx(value);
  // @@protoc_insertion_point(field_set:livekit.TrackInfo.disable_dtx)
}

// .livekit.TrackSource source = 9;
inline void TrackInfo::clear_source() {
  source_ = 0;
}
inline ::livekit::TrackSource TrackInfo::_internal_source() const {
  return static_cast< ::livekit::TrackSource >(source_);
}
inline ::livekit::TrackSource TrackInfo::source() const {
  // @@protoc_insertion_point(field_get:livekit.TrackInfo.source)
  return _internal_source();
}
inline void TrackInfo::_internal_set_source(::livekit::TrackSource value) {
  
  source_ = value;
}
inline void TrackInfo::set_source(::livekit::TrackSource value) {
  _internal_set_source(value);
  // @@protoc_insertion_point(field_set:livekit.TrackInfo.source)
}

// repeated .livekit.VideoLayer layers = 10;
inline int TrackInfo::_internal_layers_size() const {
  return layers_.size();
}
inline int TrackInfo::layers_size() const {
  return _internal_layers_size();
}
inline void TrackInfo::clear_layers() {
  layers_.Clear();
}
inline ::livekit::VideoLayer* TrackInfo::mutable_layers(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.TrackInfo.layers)
  return layers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::VideoLayer >*
TrackInfo::mutable_layers() {
  // @@protoc_insertion_point(field_mutable_list:livekit.TrackInfo.layers)
  return &layers_;
}
inline const ::livekit::VideoLayer& TrackInfo::_internal_layers(int index) const {
  return layers_.Get(index);
}
inline const ::livekit::VideoLayer& TrackInfo::layers(int index) const {
  // @@protoc_insertion_point(field_get:livekit.TrackInfo.layers)
  return _internal_layers(index);
}
inline ::livekit::VideoLayer* TrackInfo::_internal_add_layers() {
  return layers_.Add();
}
inline ::livekit::VideoLayer* TrackInfo::add_layers() {
  ::livekit::VideoLayer* _add = _internal_add_layers();
  // @@protoc_insertion_point(field_add:livekit.TrackInfo.layers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::VideoLayer >&
TrackInfo::layers() const {
  // @@protoc_insertion_point(field_list:livekit.TrackInfo.layers)
  return layers_;
}

// string mime_type = 11;
inline void TrackInfo::clear_mime_type() {
  mime_type_.ClearToEmpty();
}
inline const std::string& TrackInfo::mime_type() const {
  // @@protoc_insertion_point(field_get:livekit.TrackInfo.mime_type)
  return _internal_mime_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackInfo::set_mime_type(ArgT0&& arg0, ArgT... args) {
 
 mime_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.TrackInfo.mime_type)
}
inline std::string* TrackInfo::mutable_mime_type() {
  std::string* _s = _internal_mutable_mime_type();
  // @@protoc_insertion_point(field_mutable:livekit.TrackInfo.mime_type)
  return _s;
}
inline const std::string& TrackInfo::_internal_mime_type() const {
  return mime_type_.Get();
}
inline void TrackInfo::_internal_set_mime_type(const std::string& value) {
  
  mime_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TrackInfo::_internal_mutable_mime_type() {
  
  return mime_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TrackInfo::release_mime_type() {
  // @@protoc_insertion_point(field_release:livekit.TrackInfo.mime_type)
  return mime_type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TrackInfo::set_allocated_mime_type(std::string* mime_type) {
  if (mime_type != nullptr) {
    
  } else {
    
  }
  mime_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mime_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mime_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    mime_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.TrackInfo.mime_type)
}

// string mid = 12;
inline void TrackInfo::clear_mid() {
  mid_.ClearToEmpty();
}
inline const std::string& TrackInfo::mid() const {
  // @@protoc_insertion_point(field_get:livekit.TrackInfo.mid)
  return _internal_mid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackInfo::set_mid(ArgT0&& arg0, ArgT... args) {
 
 mid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.TrackInfo.mid)
}
inline std::string* TrackInfo::mutable_mid() {
  std::string* _s = _internal_mutable_mid();
  // @@protoc_insertion_point(field_mutable:livekit.TrackInfo.mid)
  return _s;
}
inline const std::string& TrackInfo::_internal_mid() const {
  return mid_.Get();
}
inline void TrackInfo::_internal_set_mid(const std::string& value) {
  
  mid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TrackInfo::_internal_mutable_mid() {
  
  return mid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TrackInfo::release_mid() {
  // @@protoc_insertion_point(field_release:livekit.TrackInfo.mid)
  return mid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TrackInfo::set_allocated_mid(std::string* mid) {
  if (mid != nullptr) {
    
  } else {
    
  }
  mid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    mid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.TrackInfo.mid)
}

// -------------------------------------------------------------------

// VideoLayer

// .livekit.VideoQuality quality = 1;
inline void VideoLayer::clear_quality() {
  quality_ = 0;
}
inline ::livekit::VideoQuality VideoLayer::_internal_quality() const {
  return static_cast< ::livekit::VideoQuality >(quality_);
}
inline ::livekit::VideoQuality VideoLayer::quality() const {
  // @@protoc_insertion_point(field_get:livekit.VideoLayer.quality)
  return _internal_quality();
}
inline void VideoLayer::_internal_set_quality(::livekit::VideoQuality value) {
  
  quality_ = value;
}
inline void VideoLayer::set_quality(::livekit::VideoQuality value) {
  _internal_set_quality(value);
  // @@protoc_insertion_point(field_set:livekit.VideoLayer.quality)
}

// uint32 width = 2;
inline void VideoLayer::clear_width() {
  width_ = 0u;
}
inline uint32_t VideoLayer::_internal_width() const {
  return width_;
}
inline uint32_t VideoLayer::width() const {
  // @@protoc_insertion_point(field_get:livekit.VideoLayer.width)
  return _internal_width();
}
inline void VideoLayer::_internal_set_width(uint32_t value) {
  
  width_ = value;
}
inline void VideoLayer::set_width(uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:livekit.VideoLayer.width)
}

// uint32 height = 3;
inline void VideoLayer::clear_height() {
  height_ = 0u;
}
inline uint32_t VideoLayer::_internal_height() const {
  return height_;
}
inline uint32_t VideoLayer::height() const {
  // @@protoc_insertion_point(field_get:livekit.VideoLayer.height)
  return _internal_height();
}
inline void VideoLayer::_internal_set_height(uint32_t value) {
  
  height_ = value;
}
inline void VideoLayer::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:livekit.VideoLayer.height)
}

// uint32 bitrate = 4;
inline void VideoLayer::clear_bitrate() {
  bitrate_ = 0u;
}
inline uint32_t VideoLayer::_internal_bitrate() const {
  return bitrate_;
}
inline uint32_t VideoLayer::bitrate() const {
  // @@protoc_insertion_point(field_get:livekit.VideoLayer.bitrate)
  return _internal_bitrate();
}
inline void VideoLayer::_internal_set_bitrate(uint32_t value) {
  
  bitrate_ = value;
}
inline void VideoLayer::set_bitrate(uint32_t value) {
  _internal_set_bitrate(value);
  // @@protoc_insertion_point(field_set:livekit.VideoLayer.bitrate)
}

// uint32 ssrc = 5;
inline void VideoLayer::clear_ssrc() {
  ssrc_ = 0u;
}
inline uint32_t VideoLayer::_internal_ssrc() const {
  return ssrc_;
}
inline uint32_t VideoLayer::ssrc() const {
  // @@protoc_insertion_point(field_get:livekit.VideoLayer.ssrc)
  return _internal_ssrc();
}
inline void VideoLayer::_internal_set_ssrc(uint32_t value) {
  
  ssrc_ = value;
}
inline void VideoLayer::set_ssrc(uint32_t value) {
  _internal_set_ssrc(value);
  // @@protoc_insertion_point(field_set:livekit.VideoLayer.ssrc)
}

// -------------------------------------------------------------------

// DataPacket

// .livekit.DataPacket.Kind kind = 1;
inline void DataPacket::clear_kind() {
  kind_ = 0;
}
inline ::livekit::DataPacket_Kind DataPacket::_internal_kind() const {
  return static_cast< ::livekit::DataPacket_Kind >(kind_);
}
inline ::livekit::DataPacket_Kind DataPacket::kind() const {
  // @@protoc_insertion_point(field_get:livekit.DataPacket.kind)
  return _internal_kind();
}
inline void DataPacket::_internal_set_kind(::livekit::DataPacket_Kind value) {
  
  kind_ = value;
}
inline void DataPacket::set_kind(::livekit::DataPacket_Kind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:livekit.DataPacket.kind)
}

// .livekit.UserPacket user = 2;
inline bool DataPacket::_internal_has_user() const {
  return value_case() == kUser;
}
inline bool DataPacket::has_user() const {
  return _internal_has_user();
}
inline void DataPacket::set_has_user() {
  _oneof_case_[0] = kUser;
}
inline void DataPacket::clear_user() {
  if (_internal_has_user()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.user_;
    }
    clear_has_value();
  }
}
inline ::livekit::UserPacket* DataPacket::release_user() {
  // @@protoc_insertion_point(field_release:livekit.DataPacket.user)
  if (_internal_has_user()) {
    clear_has_value();
      ::livekit::UserPacket* temp = value_.user_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.user_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::UserPacket& DataPacket::_internal_user() const {
  return _internal_has_user()
      ? *value_.user_
      : reinterpret_cast< ::livekit::UserPacket&>(::livekit::_UserPacket_default_instance_);
}
inline const ::livekit::UserPacket& DataPacket::user() const {
  // @@protoc_insertion_point(field_get:livekit.DataPacket.user)
  return _internal_user();
}
inline ::livekit::UserPacket* DataPacket::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.DataPacket.user)
  if (_internal_has_user()) {
    clear_has_value();
    ::livekit::UserPacket* temp = value_.user_;
    value_.user_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DataPacket::unsafe_arena_set_allocated_user(::livekit::UserPacket* user) {
  clear_value();
  if (user) {
    set_has_user();
    value_.user_ = user;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.DataPacket.user)
}
inline ::livekit::UserPacket* DataPacket::_internal_mutable_user() {
  if (!_internal_has_user()) {
    clear_value();
    set_has_user();
    value_.user_ = CreateMaybeMessage< ::livekit::UserPacket >(GetArenaForAllocation());
  }
  return value_.user_;
}
inline ::livekit::UserPacket* DataPacket::mutable_user() {
  ::livekit::UserPacket* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:livekit.DataPacket.user)
  return _msg;
}

// .livekit.ActiveSpeakerUpdate speaker = 3;
inline bool DataPacket::_internal_has_speaker() const {
  return value_case() == kSpeaker;
}
inline bool DataPacket::has_speaker() const {
  return _internal_has_speaker();
}
inline void DataPacket::set_has_speaker() {
  _oneof_case_[0] = kSpeaker;
}
inline void DataPacket::clear_speaker() {
  if (_internal_has_speaker()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.speaker_;
    }
    clear_has_value();
  }
}
inline ::livekit::ActiveSpeakerUpdate* DataPacket::release_speaker() {
  // @@protoc_insertion_point(field_release:livekit.DataPacket.speaker)
  if (_internal_has_speaker()) {
    clear_has_value();
      ::livekit::ActiveSpeakerUpdate* temp = value_.speaker_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.speaker_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::ActiveSpeakerUpdate& DataPacket::_internal_speaker() const {
  return _internal_has_speaker()
      ? *value_.speaker_
      : reinterpret_cast< ::livekit::ActiveSpeakerUpdate&>(::livekit::_ActiveSpeakerUpdate_default_instance_);
}
inline const ::livekit::ActiveSpeakerUpdate& DataPacket::speaker() const {
  // @@protoc_insertion_point(field_get:livekit.DataPacket.speaker)
  return _internal_speaker();
}
inline ::livekit::ActiveSpeakerUpdate* DataPacket::unsafe_arena_release_speaker() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.DataPacket.speaker)
  if (_internal_has_speaker()) {
    clear_has_value();
    ::livekit::ActiveSpeakerUpdate* temp = value_.speaker_;
    value_.speaker_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DataPacket::unsafe_arena_set_allocated_speaker(::livekit::ActiveSpeakerUpdate* speaker) {
  clear_value();
  if (speaker) {
    set_has_speaker();
    value_.speaker_ = speaker;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.DataPacket.speaker)
}
inline ::livekit::ActiveSpeakerUpdate* DataPacket::_internal_mutable_speaker() {
  if (!_internal_has_speaker()) {
    clear_value();
    set_has_speaker();
    value_.speaker_ = CreateMaybeMessage< ::livekit::ActiveSpeakerUpdate >(GetArenaForAllocation());
  }
  return value_.speaker_;
}
inline ::livekit::ActiveSpeakerUpdate* DataPacket::mutable_speaker() {
  ::livekit::ActiveSpeakerUpdate* _msg = _internal_mutable_speaker();
  // @@protoc_insertion_point(field_mutable:livekit.DataPacket.speaker)
  return _msg;
}

inline bool DataPacket::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void DataPacket::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline DataPacket::ValueCase DataPacket::value_case() const {
  return DataPacket::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ActiveSpeakerUpdate

// repeated .livekit.SpeakerInfo speakers = 1;
inline int ActiveSpeakerUpdate::_internal_speakers_size() const {
  return speakers_.size();
}
inline int ActiveSpeakerUpdate::speakers_size() const {
  return _internal_speakers_size();
}
inline void ActiveSpeakerUpdate::clear_speakers() {
  speakers_.Clear();
}
inline ::livekit::SpeakerInfo* ActiveSpeakerUpdate::mutable_speakers(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.ActiveSpeakerUpdate.speakers)
  return speakers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SpeakerInfo >*
ActiveSpeakerUpdate::mutable_speakers() {
  // @@protoc_insertion_point(field_mutable_list:livekit.ActiveSpeakerUpdate.speakers)
  return &speakers_;
}
inline const ::livekit::SpeakerInfo& ActiveSpeakerUpdate::_internal_speakers(int index) const {
  return speakers_.Get(index);
}
inline const ::livekit::SpeakerInfo& ActiveSpeakerUpdate::speakers(int index) const {
  // @@protoc_insertion_point(field_get:livekit.ActiveSpeakerUpdate.speakers)
  return _internal_speakers(index);
}
inline ::livekit::SpeakerInfo* ActiveSpeakerUpdate::_internal_add_speakers() {
  return speakers_.Add();
}
inline ::livekit::SpeakerInfo* ActiveSpeakerUpdate::add_speakers() {
  ::livekit::SpeakerInfo* _add = _internal_add_speakers();
  // @@protoc_insertion_point(field_add:livekit.ActiveSpeakerUpdate.speakers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SpeakerInfo >&
ActiveSpeakerUpdate::speakers() const {
  // @@protoc_insertion_point(field_list:livekit.ActiveSpeakerUpdate.speakers)
  return speakers_;
}

// -------------------------------------------------------------------

// SpeakerInfo

// string sid = 1;
inline void SpeakerInfo::clear_sid() {
  sid_.ClearToEmpty();
}
inline const std::string& SpeakerInfo::sid() const {
  // @@protoc_insertion_point(field_get:livekit.SpeakerInfo.sid)
  return _internal_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpeakerInfo::set_sid(ArgT0&& arg0, ArgT... args) {
 
 sid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.SpeakerInfo.sid)
}
inline std::string* SpeakerInfo::mutable_sid() {
  std::string* _s = _internal_mutable_sid();
  // @@protoc_insertion_point(field_mutable:livekit.SpeakerInfo.sid)
  return _s;
}
inline const std::string& SpeakerInfo::_internal_sid() const {
  return sid_.Get();
}
inline void SpeakerInfo::_internal_set_sid(const std::string& value) {
  
  sid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SpeakerInfo::_internal_mutable_sid() {
  
  return sid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SpeakerInfo::release_sid() {
  // @@protoc_insertion_point(field_release:livekit.SpeakerInfo.sid)
  return sid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SpeakerInfo::set_allocated_sid(std::string* sid) {
  if (sid != nullptr) {
    
  } else {
    
  }
  sid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.SpeakerInfo.sid)
}

// float level = 2;
inline void SpeakerInfo::clear_level() {
  level_ = 0;
}
inline float SpeakerInfo::_internal_level() const {
  return level_;
}
inline float SpeakerInfo::level() const {
  // @@protoc_insertion_point(field_get:livekit.SpeakerInfo.level)
  return _internal_level();
}
inline void SpeakerInfo::_internal_set_level(float value) {
  
  level_ = value;
}
inline void SpeakerInfo::set_level(float value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:livekit.SpeakerInfo.level)
}

// bool active = 3;
inline void SpeakerInfo::clear_active() {
  active_ = false;
}
inline bool SpeakerInfo::_internal_active() const {
  return active_;
}
inline bool SpeakerInfo::active() const {
  // @@protoc_insertion_point(field_get:livekit.SpeakerInfo.active)
  return _internal_active();
}
inline void SpeakerInfo::_internal_set_active(bool value) {
  
  active_ = value;
}
inline void SpeakerInfo::set_active(bool value) {
  _internal_set_active(value);
  // @@protoc_insertion_point(field_set:livekit.SpeakerInfo.active)
}

// -------------------------------------------------------------------

// UserPacket

// string participant_sid = 1;
inline void UserPacket::clear_participant_sid() {
  participant_sid_.ClearToEmpty();
}
inline const std::string& UserPacket::participant_sid() const {
  // @@protoc_insertion_point(field_get:livekit.UserPacket.participant_sid)
  return _internal_participant_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserPacket::set_participant_sid(ArgT0&& arg0, ArgT... args) {
 
 participant_sid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.UserPacket.participant_sid)
}
inline std::string* UserPacket::mutable_participant_sid() {
  std::string* _s = _internal_mutable_participant_sid();
  // @@protoc_insertion_point(field_mutable:livekit.UserPacket.participant_sid)
  return _s;
}
inline const std::string& UserPacket::_internal_participant_sid() const {
  return participant_sid_.Get();
}
inline void UserPacket::_internal_set_participant_sid(const std::string& value) {
  
  participant_sid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserPacket::_internal_mutable_participant_sid() {
  
  return participant_sid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserPacket::release_participant_sid() {
  // @@protoc_insertion_point(field_release:livekit.UserPacket.participant_sid)
  return participant_sid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserPacket::set_allocated_participant_sid(std::string* participant_sid) {
  if (participant_sid != nullptr) {
    
  } else {
    
  }
  participant_sid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), participant_sid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (participant_sid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    participant_sid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.UserPacket.participant_sid)
}

// bytes payload = 2;
inline void UserPacket::clear_payload() {
  payload_.ClearToEmpty();
}
inline const std::string& UserPacket::payload() const {
  // @@protoc_insertion_point(field_get:livekit.UserPacket.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserPacket::set_payload(ArgT0&& arg0, ArgT... args) {
 
 payload_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.UserPacket.payload)
}
inline std::string* UserPacket::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:livekit.UserPacket.payload)
  return _s;
}
inline const std::string& UserPacket::_internal_payload() const {
  return payload_.Get();
}
inline void UserPacket::_internal_set_payload(const std::string& value) {
  
  payload_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserPacket::_internal_mutable_payload() {
  
  return payload_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserPacket::release_payload() {
  // @@protoc_insertion_point(field_release:livekit.UserPacket.payload)
  return payload_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserPacket::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  payload_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payload,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (payload_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    payload_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.UserPacket.payload)
}

// repeated string destination_sids = 3;
inline int UserPacket::_internal_destination_sids_size() const {
  return destination_sids_.size();
}
inline int UserPacket::destination_sids_size() const {
  return _internal_destination_sids_size();
}
inline void UserPacket::clear_destination_sids() {
  destination_sids_.Clear();
}
inline std::string* UserPacket::add_destination_sids() {
  std::string* _s = _internal_add_destination_sids();
  // @@protoc_insertion_point(field_add_mutable:livekit.UserPacket.destination_sids)
  return _s;
}
inline const std::string& UserPacket::_internal_destination_sids(int index) const {
  return destination_sids_.Get(index);
}
inline const std::string& UserPacket::destination_sids(int index) const {
  // @@protoc_insertion_point(field_get:livekit.UserPacket.destination_sids)
  return _internal_destination_sids(index);
}
inline std::string* UserPacket::mutable_destination_sids(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.UserPacket.destination_sids)
  return destination_sids_.Mutable(index);
}
inline void UserPacket::set_destination_sids(int index, const std::string& value) {
  destination_sids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:livekit.UserPacket.destination_sids)
}
inline void UserPacket::set_destination_sids(int index, std::string&& value) {
  destination_sids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:livekit.UserPacket.destination_sids)
}
inline void UserPacket::set_destination_sids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  destination_sids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:livekit.UserPacket.destination_sids)
}
inline void UserPacket::set_destination_sids(int index, const char* value, size_t size) {
  destination_sids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:livekit.UserPacket.destination_sids)
}
inline std::string* UserPacket::_internal_add_destination_sids() {
  return destination_sids_.Add();
}
inline void UserPacket::add_destination_sids(const std::string& value) {
  destination_sids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:livekit.UserPacket.destination_sids)
}
inline void UserPacket::add_destination_sids(std::string&& value) {
  destination_sids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:livekit.UserPacket.destination_sids)
}
inline void UserPacket::add_destination_sids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  destination_sids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:livekit.UserPacket.destination_sids)
}
inline void UserPacket::add_destination_sids(const char* value, size_t size) {
  destination_sids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:livekit.UserPacket.destination_sids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UserPacket::destination_sids() const {
  // @@protoc_insertion_point(field_list:livekit.UserPacket.destination_sids)
  return destination_sids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UserPacket::mutable_destination_sids() {
  // @@protoc_insertion_point(field_mutable_list:livekit.UserPacket.destination_sids)
  return &destination_sids_;
}

// -------------------------------------------------------------------

// ParticipantTracks

// string participant_sid = 1;
inline void ParticipantTracks::clear_participant_sid() {
  participant_sid_.ClearToEmpty();
}
inline const std::string& ParticipantTracks::participant_sid() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantTracks.participant_sid)
  return _internal_participant_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ParticipantTracks::set_participant_sid(ArgT0&& arg0, ArgT... args) {
 
 participant_sid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ParticipantTracks.participant_sid)
}
inline std::string* ParticipantTracks::mutable_participant_sid() {
  std::string* _s = _internal_mutable_participant_sid();
  // @@protoc_insertion_point(field_mutable:livekit.ParticipantTracks.participant_sid)
  return _s;
}
inline const std::string& ParticipantTracks::_internal_participant_sid() const {
  return participant_sid_.Get();
}
inline void ParticipantTracks::_internal_set_participant_sid(const std::string& value) {
  
  participant_sid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ParticipantTracks::_internal_mutable_participant_sid() {
  
  return participant_sid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ParticipantTracks::release_participant_sid() {
  // @@protoc_insertion_point(field_release:livekit.ParticipantTracks.participant_sid)
  return participant_sid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ParticipantTracks::set_allocated_participant_sid(std::string* participant_sid) {
  if (participant_sid != nullptr) {
    
  } else {
    
  }
  participant_sid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), participant_sid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (participant_sid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    participant_sid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ParticipantTracks.participant_sid)
}

// repeated string track_sids = 2;
inline int ParticipantTracks::_internal_track_sids_size() const {
  return track_sids_.size();
}
inline int ParticipantTracks::track_sids_size() const {
  return _internal_track_sids_size();
}
inline void ParticipantTracks::clear_track_sids() {
  track_sids_.Clear();
}
inline std::string* ParticipantTracks::add_track_sids() {
  std::string* _s = _internal_add_track_sids();
  // @@protoc_insertion_point(field_add_mutable:livekit.ParticipantTracks.track_sids)
  return _s;
}
inline const std::string& ParticipantTracks::_internal_track_sids(int index) const {
  return track_sids_.Get(index);
}
inline const std::string& ParticipantTracks::track_sids(int index) const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantTracks.track_sids)
  return _internal_track_sids(index);
}
inline std::string* ParticipantTracks::mutable_track_sids(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.ParticipantTracks.track_sids)
  return track_sids_.Mutable(index);
}
inline void ParticipantTracks::set_track_sids(int index, const std::string& value) {
  track_sids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:livekit.ParticipantTracks.track_sids)
}
inline void ParticipantTracks::set_track_sids(int index, std::string&& value) {
  track_sids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:livekit.ParticipantTracks.track_sids)
}
inline void ParticipantTracks::set_track_sids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  track_sids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:livekit.ParticipantTracks.track_sids)
}
inline void ParticipantTracks::set_track_sids(int index, const char* value, size_t size) {
  track_sids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:livekit.ParticipantTracks.track_sids)
}
inline std::string* ParticipantTracks::_internal_add_track_sids() {
  return track_sids_.Add();
}
inline void ParticipantTracks::add_track_sids(const std::string& value) {
  track_sids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:livekit.ParticipantTracks.track_sids)
}
inline void ParticipantTracks::add_track_sids(std::string&& value) {
  track_sids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:livekit.ParticipantTracks.track_sids)
}
inline void ParticipantTracks::add_track_sids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  track_sids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:livekit.ParticipantTracks.track_sids)
}
inline void ParticipantTracks::add_track_sids(const char* value, size_t size) {
  track_sids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:livekit.ParticipantTracks.track_sids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ParticipantTracks::track_sids() const {
  // @@protoc_insertion_point(field_list:livekit.ParticipantTracks.track_sids)
  return track_sids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ParticipantTracks::mutable_track_sids() {
  // @@protoc_insertion_point(field_mutable_list:livekit.ParticipantTracks.track_sids)
  return &track_sids_;
}

// -------------------------------------------------------------------

// ClientInfo

// .livekit.ClientInfo.SDK sdk = 1;
inline void ClientInfo::clear_sdk() {
  sdk_ = 0;
}
inline ::livekit::ClientInfo_SDK ClientInfo::_internal_sdk() const {
  return static_cast< ::livekit::ClientInfo_SDK >(sdk_);
}
inline ::livekit::ClientInfo_SDK ClientInfo::sdk() const {
  // @@protoc_insertion_point(field_get:livekit.ClientInfo.sdk)
  return _internal_sdk();
}
inline void ClientInfo::_internal_set_sdk(::livekit::ClientInfo_SDK value) {
  
  sdk_ = value;
}
inline void ClientInfo::set_sdk(::livekit::ClientInfo_SDK value) {
  _internal_set_sdk(value);
  // @@protoc_insertion_point(field_set:livekit.ClientInfo.sdk)
}

// string version = 2;
inline void ClientInfo::clear_version() {
  version_.ClearToEmpty();
}
inline const std::string& ClientInfo::version() const {
  // @@protoc_insertion_point(field_get:livekit.ClientInfo.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientInfo::set_version(ArgT0&& arg0, ArgT... args) {
 
 version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ClientInfo.version)
}
inline std::string* ClientInfo::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:livekit.ClientInfo.version)
  return _s;
}
inline const std::string& ClientInfo::_internal_version() const {
  return version_.Get();
}
inline void ClientInfo::_internal_set_version(const std::string& value) {
  
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ClientInfo::_internal_mutable_version() {
  
  return version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ClientInfo::release_version() {
  // @@protoc_insertion_point(field_release:livekit.ClientInfo.version)
  return version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ClientInfo::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ClientInfo.version)
}

// int32 protocol = 3;
inline void ClientInfo::clear_protocol() {
  protocol_ = 0;
}
inline int32_t ClientInfo::_internal_protocol() const {
  return protocol_;
}
inline int32_t ClientInfo::protocol() const {
  // @@protoc_insertion_point(field_get:livekit.ClientInfo.protocol)
  return _internal_protocol();
}
inline void ClientInfo::_internal_set_protocol(int32_t value) {
  
  protocol_ = value;
}
inline void ClientInfo::set_protocol(int32_t value) {
  _internal_set_protocol(value);
  // @@protoc_insertion_point(field_set:livekit.ClientInfo.protocol)
}

// string os = 4;
inline void ClientInfo::clear_os() {
  os_.ClearToEmpty();
}
inline const std::string& ClientInfo::os() const {
  // @@protoc_insertion_point(field_get:livekit.ClientInfo.os)
  return _internal_os();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientInfo::set_os(ArgT0&& arg0, ArgT... args) {
 
 os_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ClientInfo.os)
}
inline std::string* ClientInfo::mutable_os() {
  std::string* _s = _internal_mutable_os();
  // @@protoc_insertion_point(field_mutable:livekit.ClientInfo.os)
  return _s;
}
inline const std::string& ClientInfo::_internal_os() const {
  return os_.Get();
}
inline void ClientInfo::_internal_set_os(const std::string& value) {
  
  os_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ClientInfo::_internal_mutable_os() {
  
  return os_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ClientInfo::release_os() {
  // @@protoc_insertion_point(field_release:livekit.ClientInfo.os)
  return os_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ClientInfo::set_allocated_os(std::string* os) {
  if (os != nullptr) {
    
  } else {
    
  }
  os_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), os,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (os_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    os_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ClientInfo.os)
}

// string os_version = 5;
inline void ClientInfo::clear_os_version() {
  os_version_.ClearToEmpty();
}
inline const std::string& ClientInfo::os_version() const {
  // @@protoc_insertion_point(field_get:livekit.ClientInfo.os_version)
  return _internal_os_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientInfo::set_os_version(ArgT0&& arg0, ArgT... args) {
 
 os_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ClientInfo.os_version)
}
inline std::string* ClientInfo::mutable_os_version() {
  std::string* _s = _internal_mutable_os_version();
  // @@protoc_insertion_point(field_mutable:livekit.ClientInfo.os_version)
  return _s;
}
inline const std::string& ClientInfo::_internal_os_version() const {
  return os_version_.Get();
}
inline void ClientInfo::_internal_set_os_version(const std::string& value) {
  
  os_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ClientInfo::_internal_mutable_os_version() {
  
  return os_version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ClientInfo::release_os_version() {
  // @@protoc_insertion_point(field_release:livekit.ClientInfo.os_version)
  return os_version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ClientInfo::set_allocated_os_version(std::string* os_version) {
  if (os_version != nullptr) {
    
  } else {
    
  }
  os_version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), os_version,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (os_version_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    os_version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ClientInfo.os_version)
}

// string device_model = 6;
inline void ClientInfo::clear_device_model() {
  device_model_.ClearToEmpty();
}
inline const std::string& ClientInfo::device_model() const {
  // @@protoc_insertion_point(field_get:livekit.ClientInfo.device_model)
  return _internal_device_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientInfo::set_device_model(ArgT0&& arg0, ArgT... args) {
 
 device_model_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ClientInfo.device_model)
}
inline std::string* ClientInfo::mutable_device_model() {
  std::string* _s = _internal_mutable_device_model();
  // @@protoc_insertion_point(field_mutable:livekit.ClientInfo.device_model)
  return _s;
}
inline const std::string& ClientInfo::_internal_device_model() const {
  return device_model_.Get();
}
inline void ClientInfo::_internal_set_device_model(const std::string& value) {
  
  device_model_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ClientInfo::_internal_mutable_device_model() {
  
  return device_model_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ClientInfo::release_device_model() {
  // @@protoc_insertion_point(field_release:livekit.ClientInfo.device_model)
  return device_model_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ClientInfo::set_allocated_device_model(std::string* device_model) {
  if (device_model != nullptr) {
    
  } else {
    
  }
  device_model_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_model,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_model_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_model_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ClientInfo.device_model)
}

// string browser = 7;
inline void ClientInfo::clear_browser() {
  browser_.ClearToEmpty();
}
inline const std::string& ClientInfo::browser() const {
  // @@protoc_insertion_point(field_get:livekit.ClientInfo.browser)
  return _internal_browser();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientInfo::set_browser(ArgT0&& arg0, ArgT... args) {
 
 browser_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ClientInfo.browser)
}
inline std::string* ClientInfo::mutable_browser() {
  std::string* _s = _internal_mutable_browser();
  // @@protoc_insertion_point(field_mutable:livekit.ClientInfo.browser)
  return _s;
}
inline const std::string& ClientInfo::_internal_browser() const {
  return browser_.Get();
}
inline void ClientInfo::_internal_set_browser(const std::string& value) {
  
  browser_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ClientInfo::_internal_mutable_browser() {
  
  return browser_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ClientInfo::release_browser() {
  // @@protoc_insertion_point(field_release:livekit.ClientInfo.browser)
  return browser_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ClientInfo::set_allocated_browser(std::string* browser) {
  if (browser != nullptr) {
    
  } else {
    
  }
  browser_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), browser,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (browser_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    browser_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ClientInfo.browser)
}

// string browser_version = 8;
inline void ClientInfo::clear_browser_version() {
  browser_version_.ClearToEmpty();
}
inline const std::string& ClientInfo::browser_version() const {
  // @@protoc_insertion_point(field_get:livekit.ClientInfo.browser_version)
  return _internal_browser_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientInfo::set_browser_version(ArgT0&& arg0, ArgT... args) {
 
 browser_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ClientInfo.browser_version)
}
inline std::string* ClientInfo::mutable_browser_version() {
  std::string* _s = _internal_mutable_browser_version();
  // @@protoc_insertion_point(field_mutable:livekit.ClientInfo.browser_version)
  return _s;
}
inline const std::string& ClientInfo::_internal_browser_version() const {
  return browser_version_.Get();
}
inline void ClientInfo::_internal_set_browser_version(const std::string& value) {
  
  browser_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ClientInfo::_internal_mutable_browser_version() {
  
  return browser_version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ClientInfo::release_browser_version() {
  // @@protoc_insertion_point(field_release:livekit.ClientInfo.browser_version)
  return browser_version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ClientInfo::set_allocated_browser_version(std::string* browser_version) {
  if (browser_version != nullptr) {
    
  } else {
    
  }
  browser_version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), browser_version,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (browser_version_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    browser_version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ClientInfo.browser_version)
}

// string address = 9;
inline void ClientInfo::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& ClientInfo::address() const {
  // @@protoc_insertion_point(field_get:livekit.ClientInfo.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientInfo::set_address(ArgT0&& arg0, ArgT... args) {
 
 address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ClientInfo.address)
}
inline std::string* ClientInfo::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:livekit.ClientInfo.address)
  return _s;
}
inline const std::string& ClientInfo::_internal_address() const {
  return address_.Get();
}
inline void ClientInfo::_internal_set_address(const std::string& value) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ClientInfo::_internal_mutable_address() {
  
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ClientInfo::release_address() {
  // @@protoc_insertion_point(field_release:livekit.ClientInfo.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ClientInfo::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ClientInfo.address)
}

// -------------------------------------------------------------------

// ClientConfiguration

// .livekit.VideoConfiguration video = 1;
inline bool ClientConfiguration::_internal_has_video() const {
  return this != internal_default_instance() && video_ != nullptr;
}
inline bool ClientConfiguration::has_video() const {
  return _internal_has_video();
}
inline void ClientConfiguration::clear_video() {
  if (GetArenaForAllocation() == nullptr && video_ != nullptr) {
    delete video_;
  }
  video_ = nullptr;
}
inline const ::livekit::VideoConfiguration& ClientConfiguration::_internal_video() const {
  const ::livekit::VideoConfiguration* p = video_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::VideoConfiguration&>(
      ::livekit::_VideoConfiguration_default_instance_);
}
inline const ::livekit::VideoConfiguration& ClientConfiguration::video() const {
  // @@protoc_insertion_point(field_get:livekit.ClientConfiguration.video)
  return _internal_video();
}
inline void ClientConfiguration::unsafe_arena_set_allocated_video(
    ::livekit::VideoConfiguration* video) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(video_);
  }
  video_ = video;
  if (video) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.ClientConfiguration.video)
}
inline ::livekit::VideoConfiguration* ClientConfiguration::release_video() {
  
  ::livekit::VideoConfiguration* temp = video_;
  video_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::VideoConfiguration* ClientConfiguration::unsafe_arena_release_video() {
  // @@protoc_insertion_point(field_release:livekit.ClientConfiguration.video)
  
  ::livekit::VideoConfiguration* temp = video_;
  video_ = nullptr;
  return temp;
}
inline ::livekit::VideoConfiguration* ClientConfiguration::_internal_mutable_video() {
  
  if (video_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::VideoConfiguration>(GetArenaForAllocation());
    video_ = p;
  }
  return video_;
}
inline ::livekit::VideoConfiguration* ClientConfiguration::mutable_video() {
  ::livekit::VideoConfiguration* _msg = _internal_mutable_video();
  // @@protoc_insertion_point(field_mutable:livekit.ClientConfiguration.video)
  return _msg;
}
inline void ClientConfiguration::set_allocated_video(::livekit::VideoConfiguration* video) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete video_;
  }
  if (video) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::livekit::VideoConfiguration>::GetOwningArena(video);
    if (message_arena != submessage_arena) {
      video = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, video, submessage_arena);
    }
    
  } else {
    
  }
  video_ = video;
  // @@protoc_insertion_point(field_set_allocated:livekit.ClientConfiguration.video)
}

// .livekit.VideoConfiguration screen = 2;
inline bool ClientConfiguration::_internal_has_screen() const {
  return this != internal_default_instance() && screen_ != nullptr;
}
inline bool ClientConfiguration::has_screen() const {
  return _internal_has_screen();
}
inline void ClientConfiguration::clear_screen() {
  if (GetArenaForAllocation() == nullptr && screen_ != nullptr) {
    delete screen_;
  }
  screen_ = nullptr;
}
inline const ::livekit::VideoConfiguration& ClientConfiguration::_internal_screen() const {
  const ::livekit::VideoConfiguration* p = screen_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::VideoConfiguration&>(
      ::livekit::_VideoConfiguration_default_instance_);
}
inline const ::livekit::VideoConfiguration& ClientConfiguration::screen() const {
  // @@protoc_insertion_point(field_get:livekit.ClientConfiguration.screen)
  return _internal_screen();
}
inline void ClientConfiguration::unsafe_arena_set_allocated_screen(
    ::livekit::VideoConfiguration* screen) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(screen_);
  }
  screen_ = screen;
  if (screen) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.ClientConfiguration.screen)
}
inline ::livekit::VideoConfiguration* ClientConfiguration::release_screen() {
  
  ::livekit::VideoConfiguration* temp = screen_;
  screen_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::VideoConfiguration* ClientConfiguration::unsafe_arena_release_screen() {
  // @@protoc_insertion_point(field_release:livekit.ClientConfiguration.screen)
  
  ::livekit::VideoConfiguration* temp = screen_;
  screen_ = nullptr;
  return temp;
}
inline ::livekit::VideoConfiguration* ClientConfiguration::_internal_mutable_screen() {
  
  if (screen_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::VideoConfiguration>(GetArenaForAllocation());
    screen_ = p;
  }
  return screen_;
}
inline ::livekit::VideoConfiguration* ClientConfiguration::mutable_screen() {
  ::livekit::VideoConfiguration* _msg = _internal_mutable_screen();
  // @@protoc_insertion_point(field_mutable:livekit.ClientConfiguration.screen)
  return _msg;
}
inline void ClientConfiguration::set_allocated_screen(::livekit::VideoConfiguration* screen) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete screen_;
  }
  if (screen) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::livekit::VideoConfiguration>::GetOwningArena(screen);
    if (message_arena != submessage_arena) {
      screen = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, screen, submessage_arena);
    }
    
  } else {
    
  }
  screen_ = screen;
  // @@protoc_insertion_point(field_set_allocated:livekit.ClientConfiguration.screen)
}

// .livekit.ClientConfigSetting resume_connection = 3;
inline void ClientConfiguration::clear_resume_connection() {
  resume_connection_ = 0;
}
inline ::livekit::ClientConfigSetting ClientConfiguration::_internal_resume_connection() const {
  return static_cast< ::livekit::ClientConfigSetting >(resume_connection_);
}
inline ::livekit::ClientConfigSetting ClientConfiguration::resume_connection() const {
  // @@protoc_insertion_point(field_get:livekit.ClientConfiguration.resume_connection)
  return _internal_resume_connection();
}
inline void ClientConfiguration::_internal_set_resume_connection(::livekit::ClientConfigSetting value) {
  
  resume_connection_ = value;
}
inline void ClientConfiguration::set_resume_connection(::livekit::ClientConfigSetting value) {
  _internal_set_resume_connection(value);
  // @@protoc_insertion_point(field_set:livekit.ClientConfiguration.resume_connection)
}

// -------------------------------------------------------------------

// VideoConfiguration

// .livekit.ClientConfigSetting hardware_encoder = 1;
inline void VideoConfiguration::clear_hardware_encoder() {
  hardware_encoder_ = 0;
}
inline ::livekit::ClientConfigSetting VideoConfiguration::_internal_hardware_encoder() const {
  return static_cast< ::livekit::ClientConfigSetting >(hardware_encoder_);
}
inline ::livekit::ClientConfigSetting VideoConfiguration::hardware_encoder() const {
  // @@protoc_insertion_point(field_get:livekit.VideoConfiguration.hardware_encoder)
  return _internal_hardware_encoder();
}
inline void VideoConfiguration::_internal_set_hardware_encoder(::livekit::ClientConfigSetting value) {
  
  hardware_encoder_ = value;
}
inline void VideoConfiguration::set_hardware_encoder(::livekit::ClientConfigSetting value) {
  _internal_set_hardware_encoder(value);
  // @@protoc_insertion_point(field_set:livekit.VideoConfiguration.hardware_encoder)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// RTPStats

// .google.protobuf.Timestamp start_time = 1;
inline bool RTPStats::_internal_has_start_time() const {
  return this != internal_default_instance() && start_time_ != nullptr;
}
inline bool RTPStats::has_start_time() const {
  return _internal_has_start_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RTPStats::_internal_start_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = start_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RTPStats::start_time() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.start_time)
  return _internal_start_time();
}
inline void RTPStats::unsafe_arena_set_allocated_start_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time_);
  }
  start_time_ = start_time;
  if (start_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.RTPStats.start_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::release_start_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = start_time_;
  start_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::unsafe_arena_release_start_time() {
  // @@protoc_insertion_point(field_release:livekit.RTPStats.start_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = start_time_;
  start_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::_internal_mutable_start_time() {
  
  if (start_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    start_time_ = p;
  }
  return start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::mutable_start_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:livekit.RTPStats.start_time)
  return _msg;
}
inline void RTPStats::set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time_);
  }
  if (start_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time));
    if (message_arena != submessage_arena) {
      start_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:livekit.RTPStats.start_time)
}

// .google.protobuf.Timestamp end_time = 2;
inline bool RTPStats::_internal_has_end_time() const {
  return this != internal_default_instance() && end_time_ != nullptr;
}
inline bool RTPStats::has_end_time() const {
  return _internal_has_end_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RTPStats::_internal_end_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = end_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RTPStats::end_time() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.end_time)
  return _internal_end_time();
}
inline void RTPStats::unsafe_arena_set_allocated_end_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_time_);
  }
  end_time_ = end_time;
  if (end_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.RTPStats.end_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::release_end_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = end_time_;
  end_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::unsafe_arena_release_end_time() {
  // @@protoc_insertion_point(field_release:livekit.RTPStats.end_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = end_time_;
  end_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::_internal_mutable_end_time() {
  
  if (end_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    end_time_ = p;
  }
  return end_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::mutable_end_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_end_time();
  // @@protoc_insertion_point(field_mutable:livekit.RTPStats.end_time)
  return _msg;
}
inline void RTPStats::set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_time_);
  }
  if (end_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_time));
    if (message_arena != submessage_arena) {
      end_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_time, submessage_arena);
    }
    
  } else {
    
  }
  end_time_ = end_time;
  // @@protoc_insertion_point(field_set_allocated:livekit.RTPStats.end_time)
}

// double duration = 3;
inline void RTPStats::clear_duration() {
  duration_ = 0;
}
inline double RTPStats::_internal_duration() const {
  return duration_;
}
inline double RTPStats::duration() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.duration)
  return _internal_duration();
}
inline void RTPStats::_internal_set_duration(double value) {
  
  duration_ = value;
}
inline void RTPStats::set_duration(double value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.duration)
}

// uint32 packets = 4;
inline void RTPStats::clear_packets() {
  packets_ = 0u;
}
inline uint32_t RTPStats::_internal_packets() const {
  return packets_;
}
inline uint32_t RTPStats::packets() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.packets)
  return _internal_packets();
}
inline void RTPStats::_internal_set_packets(uint32_t value) {
  
  packets_ = value;
}
inline void RTPStats::set_packets(uint32_t value) {
  _internal_set_packets(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.packets)
}

// double packet_rate = 5;
inline void RTPStats::clear_packet_rate() {
  packet_rate_ = 0;
}
inline double RTPStats::_internal_packet_rate() const {
  return packet_rate_;
}
inline double RTPStats::packet_rate() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.packet_rate)
  return _internal_packet_rate();
}
inline void RTPStats::_internal_set_packet_rate(double value) {
  
  packet_rate_ = value;
}
inline void RTPStats::set_packet_rate(double value) {
  _internal_set_packet_rate(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.packet_rate)
}

// uint64 bytes = 6;
inline void RTPStats::clear_bytes() {
  bytes_ = uint64_t{0u};
}
inline uint64_t RTPStats::_internal_bytes() const {
  return bytes_;
}
inline uint64_t RTPStats::bytes() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.bytes)
  return _internal_bytes();
}
inline void RTPStats::_internal_set_bytes(uint64_t value) {
  
  bytes_ = value;
}
inline void RTPStats::set_bytes(uint64_t value) {
  _internal_set_bytes(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.bytes)
}

// double bitrate = 7;
inline void RTPStats::clear_bitrate() {
  bitrate_ = 0;
}
inline double RTPStats::_internal_bitrate() const {
  return bitrate_;
}
inline double RTPStats::bitrate() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.bitrate)
  return _internal_bitrate();
}
inline void RTPStats::_internal_set_bitrate(double value) {
  
  bitrate_ = value;
}
inline void RTPStats::set_bitrate(double value) {
  _internal_set_bitrate(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.bitrate)
}

// uint32 packets_lost = 8;
inline void RTPStats::clear_packets_lost() {
  packets_lost_ = 0u;
}
inline uint32_t RTPStats::_internal_packets_lost() const {
  return packets_lost_;
}
inline uint32_t RTPStats::packets_lost() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.packets_lost)
  return _internal_packets_lost();
}
inline void RTPStats::_internal_set_packets_lost(uint32_t value) {
  
  packets_lost_ = value;
}
inline void RTPStats::set_packets_lost(uint32_t value) {
  _internal_set_packets_lost(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.packets_lost)
}

// double packet_loss_rate = 9;
inline void RTPStats::clear_packet_loss_rate() {
  packet_loss_rate_ = 0;
}
inline double RTPStats::_internal_packet_loss_rate() const {
  return packet_loss_rate_;
}
inline double RTPStats::packet_loss_rate() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.packet_loss_rate)
  return _internal_packet_loss_rate();
}
inline void RTPStats::_internal_set_packet_loss_rate(double value) {
  
  packet_loss_rate_ = value;
}
inline void RTPStats::set_packet_loss_rate(double value) {
  _internal_set_packet_loss_rate(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.packet_loss_rate)
}

// float packet_loss_percentage = 10;
inline void RTPStats::clear_packet_loss_percentage() {
  packet_loss_percentage_ = 0;
}
inline float RTPStats::_internal_packet_loss_percentage() const {
  return packet_loss_percentage_;
}
inline float RTPStats::packet_loss_percentage() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.packet_loss_percentage)
  return _internal_packet_loss_percentage();
}
inline void RTPStats::_internal_set_packet_loss_percentage(float value) {
  
  packet_loss_percentage_ = value;
}
inline void RTPStats::set_packet_loss_percentage(float value) {
  _internal_set_packet_loss_percentage(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.packet_loss_percentage)
}

// uint32 packets_duplicate = 11;
inline void RTPStats::clear_packets_duplicate() {
  packets_duplicate_ = 0u;
}
inline uint32_t RTPStats::_internal_packets_duplicate() const {
  return packets_duplicate_;
}
inline uint32_t RTPStats::packets_duplicate() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.packets_duplicate)
  return _internal_packets_duplicate();
}
inline void RTPStats::_internal_set_packets_duplicate(uint32_t value) {
  
  packets_duplicate_ = value;
}
inline void RTPStats::set_packets_duplicate(uint32_t value) {
  _internal_set_packets_duplicate(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.packets_duplicate)
}

// double packet_duplicate_rate = 12;
inline void RTPStats::clear_packet_duplicate_rate() {
  packet_duplicate_rate_ = 0;
}
inline double RTPStats::_internal_packet_duplicate_rate() const {
  return packet_duplicate_rate_;
}
inline double RTPStats::packet_duplicate_rate() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.packet_duplicate_rate)
  return _internal_packet_duplicate_rate();
}
inline void RTPStats::_internal_set_packet_duplicate_rate(double value) {
  
  packet_duplicate_rate_ = value;
}
inline void RTPStats::set_packet_duplicate_rate(double value) {
  _internal_set_packet_duplicate_rate(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.packet_duplicate_rate)
}

// uint64 bytes_duplicate = 13;
inline void RTPStats::clear_bytes_duplicate() {
  bytes_duplicate_ = uint64_t{0u};
}
inline uint64_t RTPStats::_internal_bytes_duplicate() const {
  return bytes_duplicate_;
}
inline uint64_t RTPStats::bytes_duplicate() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.bytes_duplicate)
  return _internal_bytes_duplicate();
}
inline void RTPStats::_internal_set_bytes_duplicate(uint64_t value) {
  
  bytes_duplicate_ = value;
}
inline void RTPStats::set_bytes_duplicate(uint64_t value) {
  _internal_set_bytes_duplicate(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.bytes_duplicate)
}

// double bitrate_duplicate = 14;
inline void RTPStats::clear_bitrate_duplicate() {
  bitrate_duplicate_ = 0;
}
inline double RTPStats::_internal_bitrate_duplicate() const {
  return bitrate_duplicate_;
}
inline double RTPStats::bitrate_duplicate() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.bitrate_duplicate)
  return _internal_bitrate_duplicate();
}
inline void RTPStats::_internal_set_bitrate_duplicate(double value) {
  
  bitrate_duplicate_ = value;
}
inline void RTPStats::set_bitrate_duplicate(double value) {
  _internal_set_bitrate_duplicate(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.bitrate_duplicate)
}

// uint32 packets_padding = 15;
inline void RTPStats::clear_packets_padding() {
  packets_padding_ = 0u;
}
inline uint32_t RTPStats::_internal_packets_padding() const {
  return packets_padding_;
}
inline uint32_t RTPStats::packets_padding() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.packets_padding)
  return _internal_packets_padding();
}
inline void RTPStats::_internal_set_packets_padding(uint32_t value) {
  
  packets_padding_ = value;
}
inline void RTPStats::set_packets_padding(uint32_t value) {
  _internal_set_packets_padding(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.packets_padding)
}

// double packet_padding_rate = 16;
inline void RTPStats::clear_packet_padding_rate() {
  packet_padding_rate_ = 0;
}
inline double RTPStats::_internal_packet_padding_rate() const {
  return packet_padding_rate_;
}
inline double RTPStats::packet_padding_rate() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.packet_padding_rate)
  return _internal_packet_padding_rate();
}
inline void RTPStats::_internal_set_packet_padding_rate(double value) {
  
  packet_padding_rate_ = value;
}
inline void RTPStats::set_packet_padding_rate(double value) {
  _internal_set_packet_padding_rate(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.packet_padding_rate)
}

// uint64 bytes_padding = 17;
inline void RTPStats::clear_bytes_padding() {
  bytes_padding_ = uint64_t{0u};
}
inline uint64_t RTPStats::_internal_bytes_padding() const {
  return bytes_padding_;
}
inline uint64_t RTPStats::bytes_padding() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.bytes_padding)
  return _internal_bytes_padding();
}
inline void RTPStats::_internal_set_bytes_padding(uint64_t value) {
  
  bytes_padding_ = value;
}
inline void RTPStats::set_bytes_padding(uint64_t value) {
  _internal_set_bytes_padding(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.bytes_padding)
}

// double bitrate_padding = 18;
inline void RTPStats::clear_bitrate_padding() {
  bitrate_padding_ = 0;
}
inline double RTPStats::_internal_bitrate_padding() const {
  return bitrate_padding_;
}
inline double RTPStats::bitrate_padding() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.bitrate_padding)
  return _internal_bitrate_padding();
}
inline void RTPStats::_internal_set_bitrate_padding(double value) {
  
  bitrate_padding_ = value;
}
inline void RTPStats::set_bitrate_padding(double value) {
  _internal_set_bitrate_padding(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.bitrate_padding)
}

// uint32 packets_out_of_order = 19;
inline void RTPStats::clear_packets_out_of_order() {
  packets_out_of_order_ = 0u;
}
inline uint32_t RTPStats::_internal_packets_out_of_order() const {
  return packets_out_of_order_;
}
inline uint32_t RTPStats::packets_out_of_order() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.packets_out_of_order)
  return _internal_packets_out_of_order();
}
inline void RTPStats::_internal_set_packets_out_of_order(uint32_t value) {
  
  packets_out_of_order_ = value;
}
inline void RTPStats::set_packets_out_of_order(uint32_t value) {
  _internal_set_packets_out_of_order(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.packets_out_of_order)
}

// uint32 frames = 20;
inline void RTPStats::clear_frames() {
  frames_ = 0u;
}
inline uint32_t RTPStats::_internal_frames() const {
  return frames_;
}
inline uint32_t RTPStats::frames() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.frames)
  return _internal_frames();
}
inline void RTPStats::_internal_set_frames(uint32_t value) {
  
  frames_ = value;
}
inline void RTPStats::set_frames(uint32_t value) {
  _internal_set_frames(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.frames)
}

// double frame_rate = 21;
inline void RTPStats::clear_frame_rate() {
  frame_rate_ = 0;
}
inline double RTPStats::_internal_frame_rate() const {
  return frame_rate_;
}
inline double RTPStats::frame_rate() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.frame_rate)
  return _internal_frame_rate();
}
inline void RTPStats::_internal_set_frame_rate(double value) {
  
  frame_rate_ = value;
}
inline void RTPStats::set_frame_rate(double value) {
  _internal_set_frame_rate(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.frame_rate)
}

// double jitter_current = 22;
inline void RTPStats::clear_jitter_current() {
  jitter_current_ = 0;
}
inline double RTPStats::_internal_jitter_current() const {
  return jitter_current_;
}
inline double RTPStats::jitter_current() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.jitter_current)
  return _internal_jitter_current();
}
inline void RTPStats::_internal_set_jitter_current(double value) {
  
  jitter_current_ = value;
}
inline void RTPStats::set_jitter_current(double value) {
  _internal_set_jitter_current(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.jitter_current)
}

// double jitter_max = 23;
inline void RTPStats::clear_jitter_max() {
  jitter_max_ = 0;
}
inline double RTPStats::_internal_jitter_max() const {
  return jitter_max_;
}
inline double RTPStats::jitter_max() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.jitter_max)
  return _internal_jitter_max();
}
inline void RTPStats::_internal_set_jitter_max(double value) {
  
  jitter_max_ = value;
}
inline void RTPStats::set_jitter_max(double value) {
  _internal_set_jitter_max(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.jitter_max)
}

// map<int32, uint32> gap_histogram = 24;
inline int RTPStats::_internal_gap_histogram_size() const {
  return gap_histogram_.size();
}
inline int RTPStats::gap_histogram_size() const {
  return _internal_gap_histogram_size();
}
inline void RTPStats::clear_gap_histogram() {
  gap_histogram_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, uint32_t >&
RTPStats::_internal_gap_histogram() const {
  return gap_histogram_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, uint32_t >&
RTPStats::gap_histogram() const {
  // @@protoc_insertion_point(field_map:livekit.RTPStats.gap_histogram)
  return _internal_gap_histogram();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, uint32_t >*
RTPStats::_internal_mutable_gap_histogram() {
  return gap_histogram_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, uint32_t >*
RTPStats::mutable_gap_histogram() {
  // @@protoc_insertion_point(field_mutable_map:livekit.RTPStats.gap_histogram)
  return _internal_mutable_gap_histogram();
}

// uint32 nacks = 25;
inline void RTPStats::clear_nacks() {
  nacks_ = 0u;
}
inline uint32_t RTPStats::_internal_nacks() const {
  return nacks_;
}
inline uint32_t RTPStats::nacks() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.nacks)
  return _internal_nacks();
}
inline void RTPStats::_internal_set_nacks(uint32_t value) {
  
  nacks_ = value;
}
inline void RTPStats::set_nacks(uint32_t value) {
  _internal_set_nacks(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.nacks)
}

// uint32 nack_misses = 26;
inline void RTPStats::clear_nack_misses() {
  nack_misses_ = 0u;
}
inline uint32_t RTPStats::_internal_nack_misses() const {
  return nack_misses_;
}
inline uint32_t RTPStats::nack_misses() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.nack_misses)
  return _internal_nack_misses();
}
inline void RTPStats::_internal_set_nack_misses(uint32_t value) {
  
  nack_misses_ = value;
}
inline void RTPStats::set_nack_misses(uint32_t value) {
  _internal_set_nack_misses(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.nack_misses)
}

// uint32 plis = 27;
inline void RTPStats::clear_plis() {
  plis_ = 0u;
}
inline uint32_t RTPStats::_internal_plis() const {
  return plis_;
}
inline uint32_t RTPStats::plis() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.plis)
  return _internal_plis();
}
inline void RTPStats::_internal_set_plis(uint32_t value) {
  
  plis_ = value;
}
inline void RTPStats::set_plis(uint32_t value) {
  _internal_set_plis(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.plis)
}

// .google.protobuf.Timestamp last_pli = 28;
inline bool RTPStats::_internal_has_last_pli() const {
  return this != internal_default_instance() && last_pli_ != nullptr;
}
inline bool RTPStats::has_last_pli() const {
  return _internal_has_last_pli();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RTPStats::_internal_last_pli() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = last_pli_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RTPStats::last_pli() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.last_pli)
  return _internal_last_pli();
}
inline void RTPStats::unsafe_arena_set_allocated_last_pli(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_pli) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_pli_);
  }
  last_pli_ = last_pli;
  if (last_pli) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.RTPStats.last_pli)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::release_last_pli() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_pli_;
  last_pli_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::unsafe_arena_release_last_pli() {
  // @@protoc_insertion_point(field_release:livekit.RTPStats.last_pli)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_pli_;
  last_pli_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::_internal_mutable_last_pli() {
  
  if (last_pli_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    last_pli_ = p;
  }
  return last_pli_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::mutable_last_pli() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_pli();
  // @@protoc_insertion_point(field_mutable:livekit.RTPStats.last_pli)
  return _msg;
}
inline void RTPStats::set_allocated_last_pli(::PROTOBUF_NAMESPACE_ID::Timestamp* last_pli) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_pli_);
  }
  if (last_pli) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_pli));
    if (message_arena != submessage_arena) {
      last_pli = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_pli, submessage_arena);
    }
    
  } else {
    
  }
  last_pli_ = last_pli;
  // @@protoc_insertion_point(field_set_allocated:livekit.RTPStats.last_pli)
}

// uint32 firs = 29;
inline void RTPStats::clear_firs() {
  firs_ = 0u;
}
inline uint32_t RTPStats::_internal_firs() const {
  return firs_;
}
inline uint32_t RTPStats::firs() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.firs)
  return _internal_firs();
}
inline void RTPStats::_internal_set_firs(uint32_t value) {
  
  firs_ = value;
}
inline void RTPStats::set_firs(uint32_t value) {
  _internal_set_firs(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.firs)
}

// .google.protobuf.Timestamp last_fir = 30;
inline bool RTPStats::_internal_has_last_fir() const {
  return this != internal_default_instance() && last_fir_ != nullptr;
}
inline bool RTPStats::has_last_fir() const {
  return _internal_has_last_fir();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RTPStats::_internal_last_fir() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = last_fir_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RTPStats::last_fir() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.last_fir)
  return _internal_last_fir();
}
inline void RTPStats::unsafe_arena_set_allocated_last_fir(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_fir) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_fir_);
  }
  last_fir_ = last_fir;
  if (last_fir) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.RTPStats.last_fir)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::release_last_fir() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_fir_;
  last_fir_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::unsafe_arena_release_last_fir() {
  // @@protoc_insertion_point(field_release:livekit.RTPStats.last_fir)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_fir_;
  last_fir_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::_internal_mutable_last_fir() {
  
  if (last_fir_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    last_fir_ = p;
  }
  return last_fir_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::mutable_last_fir() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_fir();
  // @@protoc_insertion_point(field_mutable:livekit.RTPStats.last_fir)
  return _msg;
}
inline void RTPStats::set_allocated_last_fir(::PROTOBUF_NAMESPACE_ID::Timestamp* last_fir) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_fir_);
  }
  if (last_fir) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_fir));
    if (message_arena != submessage_arena) {
      last_fir = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_fir, submessage_arena);
    }
    
  } else {
    
  }
  last_fir_ = last_fir;
  // @@protoc_insertion_point(field_set_allocated:livekit.RTPStats.last_fir)
}

// uint32 rtt_current = 31;
inline void RTPStats::clear_rtt_current() {
  rtt_current_ = 0u;
}
inline uint32_t RTPStats::_internal_rtt_current() const {
  return rtt_current_;
}
inline uint32_t RTPStats::rtt_current() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.rtt_current)
  return _internal_rtt_current();
}
inline void RTPStats::_internal_set_rtt_current(uint32_t value) {
  
  rtt_current_ = value;
}
inline void RTPStats::set_rtt_current(uint32_t value) {
  _internal_set_rtt_current(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.rtt_current)
}

// uint32 rtt_max = 32;
inline void RTPStats::clear_rtt_max() {
  rtt_max_ = 0u;
}
inline uint32_t RTPStats::_internal_rtt_max() const {
  return rtt_max_;
}
inline uint32_t RTPStats::rtt_max() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.rtt_max)
  return _internal_rtt_max();
}
inline void RTPStats::_internal_set_rtt_max(uint32_t value) {
  
  rtt_max_ = value;
}
inline void RTPStats::set_rtt_max(uint32_t value) {
  _internal_set_rtt_max(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.rtt_max)
}

// uint32 key_frames = 33;
inline void RTPStats::clear_key_frames() {
  key_frames_ = 0u;
}
inline uint32_t RTPStats::_internal_key_frames() const {
  return key_frames_;
}
inline uint32_t RTPStats::key_frames() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.key_frames)
  return _internal_key_frames();
}
inline void RTPStats::_internal_set_key_frames(uint32_t value) {
  
  key_frames_ = value;
}
inline void RTPStats::set_key_frames(uint32_t value) {
  _internal_set_key_frames(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.key_frames)
}

// .google.protobuf.Timestamp last_key_frame = 34;
inline bool RTPStats::_internal_has_last_key_frame() const {
  return this != internal_default_instance() && last_key_frame_ != nullptr;
}
inline bool RTPStats::has_last_key_frame() const {
  return _internal_has_last_key_frame();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RTPStats::_internal_last_key_frame() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = last_key_frame_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RTPStats::last_key_frame() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.last_key_frame)
  return _internal_last_key_frame();
}
inline void RTPStats::unsafe_arena_set_allocated_last_key_frame(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_key_frame) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_key_frame_);
  }
  last_key_frame_ = last_key_frame;
  if (last_key_frame) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.RTPStats.last_key_frame)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::release_last_key_frame() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_key_frame_;
  last_key_frame_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::unsafe_arena_release_last_key_frame() {
  // @@protoc_insertion_point(field_release:livekit.RTPStats.last_key_frame)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_key_frame_;
  last_key_frame_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::_internal_mutable_last_key_frame() {
  
  if (last_key_frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    last_key_frame_ = p;
  }
  return last_key_frame_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::mutable_last_key_frame() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_key_frame();
  // @@protoc_insertion_point(field_mutable:livekit.RTPStats.last_key_frame)
  return _msg;
}
inline void RTPStats::set_allocated_last_key_frame(::PROTOBUF_NAMESPACE_ID::Timestamp* last_key_frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_key_frame_);
  }
  if (last_key_frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_key_frame));
    if (message_arena != submessage_arena) {
      last_key_frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_key_frame, submessage_arena);
    }
    
  } else {
    
  }
  last_key_frame_ = last_key_frame;
  // @@protoc_insertion_point(field_set_allocated:livekit.RTPStats.last_key_frame)
}

// uint32 layer_lock_plis = 35;
inline void RTPStats::clear_layer_lock_plis() {
  layer_lock_plis_ = 0u;
}
inline uint32_t RTPStats::_internal_layer_lock_plis() const {
  return layer_lock_plis_;
}
inline uint32_t RTPStats::layer_lock_plis() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.layer_lock_plis)
  return _internal_layer_lock_plis();
}
inline void RTPStats::_internal_set_layer_lock_plis(uint32_t value) {
  
  layer_lock_plis_ = value;
}
inline void RTPStats::set_layer_lock_plis(uint32_t value) {
  _internal_set_layer_lock_plis(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.layer_lock_plis)
}

// .google.protobuf.Timestamp last_layer_lock_pli = 36;
inline bool RTPStats::_internal_has_last_layer_lock_pli() const {
  return this != internal_default_instance() && last_layer_lock_pli_ != nullptr;
}
inline bool RTPStats::has_last_layer_lock_pli() const {
  return _internal_has_last_layer_lock_pli();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RTPStats::_internal_last_layer_lock_pli() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = last_layer_lock_pli_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RTPStats::last_layer_lock_pli() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.last_layer_lock_pli)
  return _internal_last_layer_lock_pli();
}
inline void RTPStats::unsafe_arena_set_allocated_last_layer_lock_pli(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_layer_lock_pli) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_layer_lock_pli_);
  }
  last_layer_lock_pli_ = last_layer_lock_pli;
  if (last_layer_lock_pli) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.RTPStats.last_layer_lock_pli)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::release_last_layer_lock_pli() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_layer_lock_pli_;
  last_layer_lock_pli_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::unsafe_arena_release_last_layer_lock_pli() {
  // @@protoc_insertion_point(field_release:livekit.RTPStats.last_layer_lock_pli)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_layer_lock_pli_;
  last_layer_lock_pli_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::_internal_mutable_last_layer_lock_pli() {
  
  if (last_layer_lock_pli_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    last_layer_lock_pli_ = p;
  }
  return last_layer_lock_pli_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::mutable_last_layer_lock_pli() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_layer_lock_pli();
  // @@protoc_insertion_point(field_mutable:livekit.RTPStats.last_layer_lock_pli)
  return _msg;
}
inline void RTPStats::set_allocated_last_layer_lock_pli(::PROTOBUF_NAMESPACE_ID::Timestamp* last_layer_lock_pli) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_layer_lock_pli_);
  }
  if (last_layer_lock_pli) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_layer_lock_pli));
    if (message_arena != submessage_arena) {
      last_layer_lock_pli = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_layer_lock_pli, submessage_arena);
    }
    
  } else {
    
  }
  last_layer_lock_pli_ = last_layer_lock_pli;
  // @@protoc_insertion_point(field_set_allocated:livekit.RTPStats.last_layer_lock_pli)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace livekit

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::livekit::ParticipantInfo_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::ParticipantInfo_State>() {
  return ::livekit::ParticipantInfo_State_descriptor();
}
template <> struct is_proto_enum< ::livekit::DataPacket_Kind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::DataPacket_Kind>() {
  return ::livekit::DataPacket_Kind_descriptor();
}
template <> struct is_proto_enum< ::livekit::ClientInfo_SDK> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::ClientInfo_SDK>() {
  return ::livekit::ClientInfo_SDK_descriptor();
}
template <> struct is_proto_enum< ::livekit::TrackType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::TrackType>() {
  return ::livekit::TrackType_descriptor();
}
template <> struct is_proto_enum< ::livekit::TrackSource> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::TrackSource>() {
  return ::livekit::TrackSource_descriptor();
}
template <> struct is_proto_enum< ::livekit::VideoQuality> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::VideoQuality>() {
  return ::livekit::VideoQuality_descriptor();
}
template <> struct is_proto_enum< ::livekit::ConnectionQuality> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::ConnectionQuality>() {
  return ::livekit::ConnectionQuality_descriptor();
}
template <> struct is_proto_enum< ::livekit::ClientConfigSetting> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::ClientConfigSetting>() {
  return ::livekit::ClientConfigSetting_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_livekit_5fmodels_2eproto
